{
    "abstractText": "We present DrTM, a fast in-memory transaction processing system that exploits advanced hardware features (i.e., RDMA and HTM) to improve latency and throughput by over one order of magnitude compared to state-of-the-art distributed transaction systems. The high performance of DrTM are enabled by mostly offloading concurrency control within a local machine into HTM and leveraging the strong consistency between RDMA and HTM to ensure serializability among concurrent transactions across machines. We further build an efficient hash table for DrTM by leveraging HTM and RDMA to simplify the design and notably improve the performance. We describe how DrTM supports common database features like read-only transactions and logging for durability. Evaluation using typical OLTP workloads including TPC-C and SmallBank show that DrTM scales well on a 6-node cluster and achieves over 5.52 and 138 million transactions per second for TPC-C and SmallBank respectively. This number outperforms a state-of-theart distributed transaction system (namely Calvin) by at least 17.9X for TPC-C.",
    "authors": [
        {
            "affiliations": [],
            "name": "Xingda Wei"
        },
        {
            "affiliations": [],
            "name": "Jiaxin Shi"
        },
        {
            "affiliations": [],
            "name": "Yanzhe Chen"
        },
        {
            "affiliations": [],
            "name": "Rong Chen"
        },
        {
            "affiliations": [],
            "name": "Haibo Chen"
        }
    ],
    "id": "SP:408b8d34b7467c0b25b27fdafa77ee241ce7f4c4",
    "references": [
        {
            "authors": [
                "M.K. AGUILERA",
                "A. MERCHANT",
                "M. SHAH",
                "A. VEITCH",
                "C. KARAMANOLIS"
            ],
            "title": "Sinfonia: A new paradigm for building scalable distributed systems",
            "venue": "In Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles",
            "year": 2007
        },
        {
            "authors": [
                "M. ALOMARI",
                "M. CAHILL",
                "A. FEKETE",
                "U. R\u00d6HM"
            ],
            "title": "The cost of serializability on platforms that use snapshot isolation",
            "venue": "In IEEE 24th International Conference on Data Engineering",
            "year": 2008
        },
        {
            "authors": [
                "J. BAKER",
                "C. BOND",
                "J.C. CORBETT",
                "J. FURMAN",
                "A. KHORLIN",
                "J. LARSON",
                "LEON",
                "LI J.-M",
                "A. LLOYD",
                "V. YUSHPRAKH"
            ],
            "title": "Megastore: Providing scalable, highly available storage for interactive services",
            "venue": "In Proceedings of the 5th biennial Conference on Innovative Data Systems Research (2011),",
            "year": 2011
        },
        {
            "authors": [
                "D. BATOORY",
                "J. BARNETT",
                "J.F. GARZA",
                "K.P. SMITH",
                "K. TSUKUDA",
                "B. TWICHELL",
                "T. WISE"
            ],
            "title": "Genesis: An extensible database management system",
            "venue": "IEEE Transactions on Software Engineering 14,",
            "year": 1988
        },
        {
            "authors": [
                "A.J. BERNSTEIN",
                "D.S. GERSTL",
                "P.M. LEWIS"
            ],
            "title": "Concurrency control for step-decomposed transactions",
            "venue": "Inf. Syst. 24,",
            "year": 1999
        },
        {
            "authors": [
                "P.A. BERNSTEIN",
                "N. GOODMAN"
            ],
            "title": "Concurrency control in distributed database systems",
            "venue": "ACM Comput. Surv. 13,",
            "year": 1981
        },
        {
            "authors": [
                "P.A. BERNSTEIN",
                "D.W. SHIPMAN"
            ],
            "title": "The correctness of concurrency control mechanisms in a system for distributed databases (SDD-1)",
            "venue": "ACM Trans. Database Syst",
            "year": 1980
        },
        {
            "authors": [
                "C. BLUNDELL",
                "E.C. LEWIS",
                "M.M. MARTIN"
            ],
            "title": "Subtleties of transactional memory atomicity semantics",
            "venue": "Computer Architecture Letters 5,",
            "year": 2006
        },
        {
            "authors": [
                "R.L. BOCCHINO",
                "V.S. ADVE",
                "B.L. CHAMBERLAIN"
            ],
            "title": "Software transactional memory for large scale clusters",
            "venue": "In Proceedings of the 13th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming",
            "year": 2008
        },
        {
            "authors": [
                "N. CARVALHO",
                "P. ROMANO",
                "L. RODRIGUES"
            ],
            "title": "Asynchronous lease-based replication of software transactional memory",
            "venue": "In Proceedings of the ACM/IFIP/USENIX 11th International Conference on Middleware (2010),",
            "year": 2010
        },
        {
            "authors": [
                "M. CASTRO",
                "B. LISKOV"
            ],
            "title": "Practical byzantine fault tolerance",
            "venue": "In Proceedings of the Third Symposium on Operating Systems Design and Implementation",
            "year": 1999
        },
        {
            "authors": [
                "T.D. CHANDRA",
                "R. GRIESEMER",
                "J. REDSTONE"
            ],
            "title": "Paxos made live: An engineering perspective",
            "venue": "In Proceedings of the Twenty-sixth Annual ACM Symposium on Principles of Distributed Computing",
            "year": 2007
        },
        {
            "authors": [
                "P. CHARLES",
                "C. GROTHOFF",
                "V. SARASWAT",
                "C. DONAWA",
                "A. KIELSTRA",
                "K. EBCIOGLU",
                "C. VON PRAUN",
                "V. SARKAR"
            ],
            "title": "X10: An object-oriented approach to nonuniform cluster computing",
            "venue": "In Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-oriented Programming,",
            "year": 2005
        },
        {
            "authors": [
                "C. COARFA",
                "Y. DOTSENKO",
                "J. MELLOR-CRUMMEY",
                "F. CANTONNET",
                "T. EL-GHAZAWI",
                "A. MOHANTI",
                "Y. YAO",
                "D. CHAVARR\u00cdA-MIRANDA"
            ],
            "title": "An evaluation of global address space languages: Co-array fortran and unified parallel C",
            "venue": "In Proceedings of the Tenth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming",
            "year": 2005
        },
        {
            "authors": [
                "B.F. COOPER",
                "A. SILBERSTEIN",
                "E. TAM",
                "R. RAMAKRISH- NAN",
                "R. SEARS"
            ],
            "title": "Benchmarking cloud serving systems with YCSB",
            "venue": "In Proceedings of the 1st ACM Symposium on Cloud Computing",
            "year": 2010
        },
        {
            "authors": [
                "J.C. CORBETT",
                "J. DEAN",
                "M. EPSTEIN",
                "A. FIKES",
                "C. FROST",
                "J.J. FURMAN",
                "S. GHEMAWAT",
                "A. GUBAREV",
                "C. HEISER",
                "P. HOCHSCHILD",
                "W. HSIEH",
                "S. KANTHAK",
                "E. KOGAN",
                "H. LI",
                "A. LLOYD",
                "S. MELNIK",
                "D. MWAURA",
                "D. NAGLE",
                "S. QUINLAN",
                "R. RAO",
                "L. ROLIG",
                "Y. SAITO",
                "M. SZYMANIAK",
                "C. TAYLOR",
                "R. WANG"
            ],
            "title": "AND WOOD- FORD, D. Spanner: Google\u2019s globally-distributed database",
            "venue": "In Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2012
        },
        {
            "authors": [
                "J. COWLING",
                "B. LISKOV"
            ],
            "title": "Granola: low-overhead distributed transaction coordination",
            "venue": "In Proceedings of the 2012 USENIX conference on Annual Technical Conference",
            "year": 2012
        },
        {
            "authors": [
                "C. DIACONU",
                "C. FREEDMAN",
                "E. ISMERT",
                "LARSON",
                "P.- A",
                "P. MITTAL",
                "R. STONECIPHER",
                "N. VERMA",
                "M. ZWILLING"
            ],
            "title": "Hekaton: SQL server\u2019s memory-optimized OLTP engine",
            "venue": "In Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data",
            "year": 2013
        },
        {
            "authors": [
                "A. DRAGOJEVI\u0106",
                "D. NARAYANAN",
                "O. HODSON",
                "M. CASTRO"
            ],
            "title": "FaRM: Fast remote memory",
            "venue": "In Proceedings of the 11th USENIX Conference on Networked Systems Design and Implementation",
            "year": 2014
        },
        {
            "authors": [
                "A. DRAGOJEVIC",
                "D. NARAYANAN",
                "E. NIGHTINGALE",
                "M. RENZELMANN",
                "A. SHAMIS",
                "A. BADAM",
                "M. CAS- TRO"
            ],
            "title": "No compromises: distributed transactions with consistency, availability and performance",
            "venue": "In Proceedings of ACM Symposium on Operating Systems Principles (2015),",
            "year": 2015
        },
        {
            "authors": [
                "C. GRAY",
                "D. CHERITON"
            ],
            "title": "Leases: An efficient faulttolerant mechanism for distributed file cache consistency",
            "venue": "In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles",
            "year": 1989
        },
        {
            "authors": [
                "J. GRAY",
                "A. REUTER"
            ],
            "title": "Transaction processing: Concepts and Techniques",
            "year": 1993
        },
        {
            "authors": [
                "M. HERLIHY",
                "N. SHAVIT",
                "M. TZAFRIR"
            ],
            "title": "Hopscotch hashing",
            "venue": "In Proceedings of the 22Nd International Symposium on Distributed Computing (2008),",
            "year": 2008
        },
        {
            "authors": [
                "HERLIHY M",
                "SUN"
            ],
            "title": "Distributed transactional memory for metric-space networks",
            "venue": "In Proceedings of the 19th International Conference on Distributed Computing (2005),",
            "year": 2005
        },
        {
            "authors": [
                "P. HUNT",
                "M. KONAR",
                "F.P. JUNQUEIRA",
                "B. REED"
            ],
            "title": "Zookeeper: Wait-free coordination for internet-scale systems",
            "venue": "In Proceedings of the 2010 USENIX Conference on USENIX Annual Technical Conference",
            "year": 2010
        },
        {
            "authors": [
                "A. KALIA",
                "M. KAMINSKY",
                "D.G. ANDERSEN"
            ],
            "title": "Using rdma efficiently for key-value services",
            "venue": "In Proceedings of the 2014 ACM Conference on SIGCOMM",
            "year": 2014
        },
        {
            "authors": [
                "R. KOTLA",
                "L. ALVISI",
                "M. DAHLIN",
                "A. CLEMENT",
                "E. WONG"
            ],
            "title": "Zyzzyva: Speculative byzantine fault tolerance",
            "venue": "In Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles",
            "year": 2007
        },
        {
            "authors": [
                "H.T. KUNG",
                "J.T. ROBINSON"
            ],
            "title": "On optimistic methods for concurrency control",
            "venue": "ACM Trans. Database Syst. 6,",
            "year": 1981
        },
        {
            "authors": [
                "V. LEIS",
                "A. KEMPER",
                "T. NEUMANN"
            ],
            "title": "Exploiting hardware transactional memory in main-memory databases",
            "venue": "In IEEE 30th International Conference on Data Engineering",
            "year": 2014
        },
        {
            "authors": [
                "B. LINDSAY",
                "J. MCPHERSON",
                "H. PIRAHESH"
            ],
            "title": "A data management extension architecture",
            "venue": "In Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data",
            "year": 1987
        },
        {
            "authors": [
                "M. MAMMARELLA",
                "S. HOVSEPIAN",
                "E. KOHLER"
            ],
            "title": "Modular data storage with Anvil",
            "venue": "In Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles",
            "year": 2009
        },
        {
            "authors": [
                "K. MANASSIEV",
                "M. MIHAILESCU",
                "C. AMZA"
            ],
            "title": "Exploiting distributed version concurrency in a transactional memory cluster",
            "venue": "In Proceedings of the Eleventh ACM SIG- PLAN Symposium on Principles and Practice of Parallel Programming",
            "year": 2006
        },
        {
            "authors": [
                "Y. MAO",
                "E. KOHLER",
                "R.T. MORRIS"
            ],
            "title": "Cache craftiness for fast multicore key-value storage",
            "venue": "In Proceedings of the 7th ACM European Conference on Computer Systems",
            "year": 2012
        },
        {
            "authors": [
                "C. MITCHELL",
                "Y. GENG",
                "LI"
            ],
            "title": "Using one-sided rdma reads to build a fast, cpu-efficient key-value store",
            "venue": "In Proceedings of the 2013 USENIX Conference on Annual Technical Conference",
            "year": 2013
        },
        {
            "authors": [
                "I. MORARU",
                "D.G. ANDERSEN",
                "M. KAMINSKY"
            ],
            "title": "Paxos quorum leases: Fast reads without sacrificing writes",
            "venue": "In Proceedings of the ACM Symposium on Cloud Computing",
            "year": 2014
        },
        {
            "authors": [
                "MU S",
                "CUI Y",
                "ZHANG Y",
                "LLOYD W",
                "LI"
            ],
            "title": "Extracting more concurrency from distributed transactions",
            "venue": "In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2014
        },
        {
            "authors": [
                "D.G. MURRAY",
                "F. MCSHERRY",
                "R. ISAACS",
                "M. ISARD",
                "P. BARHAM",
                "M. ABADI"
            ],
            "title": "Naiad: A timely dataflow system",
            "venue": "In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles",
            "year": 2013
        },
        {
            "authors": [
                "D. NARAYANAN",
                "O. HODSON"
            ],
            "title": "Whole-system persistence",
            "venue": "In Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems",
            "year": 2012
        },
        {
            "authors": [
                "N. NARULA",
                "C. CUTLER",
                "E. KOHLER",
                "R. MORRIS"
            ],
            "title": "Phase reconciliation for contended in-memory transactions",
            "venue": "In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2014
        },
        {
            "authors": [
                "H. QIAN",
                "Z. WANG",
                "H. GUAN",
                "B. ZANG",
                "H. CHEN"
            ],
            "title": "Exploiting hardware transactional memory for efficient in-memory transaction processing",
            "venue": "Tech. rep., Shanghai Key Laboratory of Scalable Computing and Systems,",
            "year": 2015
        },
        {
            "authors": [
                "D. SHASHA",
                "F. LLIRBAT",
                "E. SIMON",
                "P. VALDURIEZ"
            ],
            "title": "Transaction chopping: Algorithms and performance studies",
            "venue": "ACM Trans. Database Syst. 20,",
            "year": 1995
        },
        {
            "authors": [
                "N. SHAVIT",
                "D. TOUITOU"
            ],
            "title": "Software transactional memory",
            "venue": "In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing",
            "year": 1995
        },
        {
            "authors": [
                "A. THOMSON",
                "T. DIAMOND",
                "WENG",
                "REN S.-C",
                "P. SHAO",
                "D.J. ABADI"
            ],
            "title": "Calvin: Fast distributed transactions for partitioned database systems",
            "venue": "In Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data",
            "year": 2012
        },
        {
            "authors": [
                "R.K. TREIBER"
            ],
            "title": "Systems programming: Coping with parallelism. No. RJ 5118",
            "venue": "IBM Almaden Research Center,",
            "year": 1986
        },
        {
            "authors": [
                "S. TU",
                "W. ZHENG",
                "E. KOHLER",
                "B. LISKOV",
                "S. MADDEN"
            ],
            "title": "Speedy transactions in multicore in-memory databases",
            "venue": "In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles",
            "year": 2013
        },
        {
            "authors": [
                "Y. WANG",
                "X. MENG",
                "L. ZHANG",
                "TAN"
            ],
            "title": "C-hint: An effective and reliable cache management for rdma-accelerated key-value stores",
            "venue": "In Proceedings of the ACM Symposium on Cloud Computing",
            "year": 2014
        },
        {
            "authors": [
                "Z. WANG",
                "H. QIAN",
                "H. CHEN",
                "LI"
            ],
            "title": "Opportunities and pitfalls of multi-core scaling using hardware transaction memory",
            "venue": "In Proceedings of the 4th Asia-Pacific Workshop on Systems",
            "year": 2013
        },
        {
            "authors": [
                "Z. WANG",
                "H. QIAN",
                "J. LI",
                "H. CHEN"
            ],
            "title": "Using restricted transactional memory to build a scalable in-memory database",
            "venue": "In Proceedings of the Ninth European Conference on Computer Systems",
            "year": 2014
        },
        {
            "authors": [
                "C. XIE",
                "C. SU",
                "M. KAPRITSOS",
                "Y. WANG",
                "N. YAGH- MAZADEH",
                "L. ALVISI",
                "P. MAHAJAN"
            ],
            "title": "Salt: Combining ACID and BASE in a distributed database",
            "venue": "In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2014
        },
        {
            "authors": [
                "Y. ZHANG",
                "R. POWER",
                "S. ZHOU",
                "Y. SOVRAN",
                "M.K. AGUIL- ERA",
                "LI"
            ],
            "title": "Transaction chains: Achieving serializability with low latency in geo-distributed storage systems",
            "venue": "In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles",
            "year": 2013
        },
        {
            "authors": [
                "W. ZHENG",
                "S. TU",
                "E. KOHLER",
                "B. LISKOV"
            ],
            "title": "Fast databases with fast durability and recovery through multicore parallelism",
            "venue": "In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2014
        }
    ],
    "sections": [
        {
            "text": "We present DrTM, a fast in-memory transaction processing system that exploits advanced hardware features (i.e., RDMA and HTM) to improve latency and throughput by over one order of magnitude compared to state-of-the-art distributed transaction systems. The high performance of DrTM are enabled by mostly offloading concurrency control within a local machine into HTM and leveraging the strong consistency between RDMA and HTM to ensure serializability among concurrent transactions across machines. We further build an efficient hash table for DrTM by leveraging HTM and RDMA to simplify the design and notably improve the performance. We describe how DrTM supports common database features like read-only transactions and logging for durability. Evaluation using typical OLTP workloads including TPC-C and SmallBank show that DrTM scales well on a 6-node cluster and achieves over 5.52 and 138 million transactions per second for TPC-C and SmallBank respectively. This number outperforms a state-of-theart distributed transaction system (namely Calvin) by at least 17.9X for TPC-C."
        },
        {
            "heading": "1. Introduction",
            "text": "Fast in-memory transaction processing is a key pillar for many systems like Web service, stock exchange and ecommerce. A common way to support transaction processing over a large volume of data is through partitioning data into many shards and spreading the shards over multiple machines. However, this usually necessitates distributed transactions, which are notoriously slow due to the cost of coordination among multiple nodes.\nThis paper tries to answer a natural question: with advanced processor features and fast interconnects, can we\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. SOSP\u201915, October 4-7, 2015, Monterey, CA, USA. Copyright c\u00a9 2015 ACM 978-1-4503-3834-9/15/10. . . $15.00. http://dx.doi.org/10.1145/2815400.2815419\nbuild a transaction processing system that is at least one order of magnitude faster than the state-of-the-art systems without using such features. To answer this question, this paper presents the design and implementation of DrTM, a fast in-memory transaction processing system that exploits HTM and RDMA to run distributed transactions on a modern cluster.\nHardware transactional memory (HTM) has recently come to the mass market in the form of Intel\u2019s restricted transactional memory (RTM). The features like atomicity, consistency and isolation (ACI) make it very promising for database transactions [31, 44, 57]. Meanwhile, RDMA, which provides direct memory access (DMA) to the memory of a remote machine, has recently gained considerable interests in the systems community [21, 28, 37].\nDrTM mainly leverages HTM to do most parts of concurrency control like tracking read/write sets and detecting conflicting accesses in a local machine. For transactions with large working set, DrTM may leverage transaction chopping [44, 45, 59] to fit the read/write set of each chopped transaction piece into the working set of an HTM transaction1. To preserve serializability among concurrent transactions across multiple machines, DrTM provides the first design and implementation of distributed transactions using HTM, by leveraging the strong consistency feature of RDMA (where an RDMA operation will abort an HTM transaction that accesses the same memory location) to glue multiple HTM transactions together while preserving serializability.\nOne main challenge of supporting distributed transactions is the fact that no I/O operations including RDMA are allowed within an HTM region. DrTM addresses this with a concurrency control protocol that combines HTM and two-phase locking (2PL) [7] to preserve serializability. Specifically, DrTM uses RDMA-based compare-and-swap (CAS) to lock and fetch the corresponding database records from remote machines before starting an HTM transaction. Thanks to the strong consistency of RDMA and the strong\n1 This paper uses HTM/RTM transaction or HTM/RTM region to describe the transaction code executed under HTM/RTM\u2019s protection, and uses transaction to denote the original user-written transaction.\natomicity of HTM2, any concurrent conflicting transactions on a remote machine will be aborted. DrTM leverages this property to preserve serializability among distributed transactions. To guarantee forward progress, DrTM further provides contention management by leveraging the fallback handler of HTM to prevent possible deadlock and livelock.\nAs there is no effective way to detect local writes and remote reads, a simple approach is using RDMA to lock a remote record even if a transaction only needs to read that record. This, however, significantly limits the parallelism. DrTM addresses this issue by using a lease-based scheme [23] to unleash parallelism. To allow read-read sharing of database records among transactions across machines, DrTM uses RDMA to atomically acquire a lease of a database record from a remote machine instead of simply locking it, such that other readers can still read-share this record.\nWhile RDMA-friendly hash tables have been intensively studied recently [21, 28, 37], we find that the combination of HTM and RDMA opens new opportunities for a more efficient design that fits the distributed transaction processing in DrTM. Specifically, our RDMA-friendly hash table leverages HTM to simplify race detection among local and remote read, to reduce the overhead of local operations, and to save spaces for hash entries. Besides, based on the observation that structural changes of indexes are usually rare, DrTM provides a host-transparent cache that only caches the addresses of database records as well as an incarnation checking [21] mechanism to detect invalidation. The cache is very space-efficient (caching locations instead of values) and significantly reduces RDMA operations for searching a key-value pair.\nWe have implemented DrTM, which also supports readonly transactions and uses logging for durability [54, 57, 60]. To demonstrate the efficiency of DrTM, we have conducted a set of evaluations of DrTM\u2019s performance using a 6-node cluster connected by InfiniBand NIC with RDMA. Each machine of the cluster has two 10-core RTM-enabled Intel Xeon processors. Using two popular OLTP workloads including TPC-C [51] and SmallBank [49], we show that DrTM can perform over 5.52 and 138 million transactions per second for TPC-C and SmallBank respectively. A simulation of running multiple logical nodes over each machine shows that DrTM may be able to scale out to a larger-scale cluster with tens of nodes. A comparison with a state-of-theart distributed transaction system (i.e., Calvin) shows that DrTM is at least 17.9X faster for TPC-C.\nIn summary, the contributions of this paper are:\n\u2022 The first design and implementation of exploiting the\ncombination of HTM and RDMA to boost distributed transaction processing systems (\u00a73).\n2 This means a concurrent conflicting access outside an HTM region will unconditionally abort a conflicting HTM transaction.\n\u2022 A concurrency control scheme using HTM and 2PL that\nglues together multiple concurrent transactions across machines and a lease-based scheme that enables readread sharing across machines (\u00a74).\n\u2022 An HTM/RDMA-friendly hash table that exploits HTM\nand RDMA to simplify the design and improve performance as well as a location-based cache to further reduce RDMA operations (\u00a75).\n\u2022 A set of evaluations that confirm the extremely high per-\nformance of DrTM (\u00a77)."
        },
        {
            "heading": "2. Background",
            "text": "HTM. To mitigate the challenge of writing efficient multithreaded code with fine-grained locking, hardware transactional memory (HTM) was proposed as an alternative with the goal of providing comparable performance with less complexity. Intel\u2019s Restricted Transactional Memory (RTM) provides strong atomicity [10] within a single machine, where a non-transactional code will unconditionally abort a transaction when their accesses conflict. RTM uses the first-level cache to track the write set and an implementationspecific structure to track the read set, and relies on the cache coherence protocol to detect conflicts. Upon a conflict, at least one transaction will be aborted. RTM provides a set of interfaces including XBEGIN, XEND and XABORT, which will begin, end and abort a transaction accordingly.\nAs a practical hardware mechanism, the usage of RTM has several restrictions [56, 57]. First, the read/write set of an RTM transaction must be limited in size. It is because the underlying CPU uses private caches and various buffers to track the conflicts of reads and writes. The abort rate of an RTM transaction will increase significantly with the increase of working set. Beyond the hardware capacity, the transaction will be always aborted. Second, some instructions and system events such as network I/O may abort the RTM transaction as well. Third, RTM provides no progress guarantees about transactional execution, which implies a non-transactional fallback path is required when the number of RTM transaction aborts exceeds some threshold. Last but not least, RTM is only a compelling hardware feature for single machine platform, which limits a distributed transaction system from getting profit from it. Note that, though this paper mainly uses Intel\u2019s RTM as an example to implement DrTM, we believe it should work similarly for other HTM systems. Specifically, HTM implementations with a large working set would perform extremely well under DrTM.\nRDMA. Remote Direct Memory Access (RDMA) is a networking feature to provide cross-machine accesses with high speed, low latency and low CPU overhead. Much prior work has demonstrated the benefit of using RDMA for inmemory stores [28, 37] and computing platforms [21, 40]. RDMA provides three communication options with different interfaces and performance. First, IPoIB emulates IP over InfiniBand, which can be directly used by exist-\ning socket-based code without modification. Yet, its performance is poor due to the intensive OS involvement. Second, SEND/RECV Verbs provide a message-passing interface and implement message exchanges in user space through bypassing kernel. The communication between machines is two-sided, since each SEND operation requires a RECV operation as a response. Third, the one-sided RDMA allows one machine to directly access the memory of another machine without involving the host CPU, which provides very good performance [21, 28, 37] but much limited interfaces: read, write and two atomic operations (fetch-and-add and compare-and-swap)."
        },
        {
            "heading": "3. Overview",
            "text": "Setting. DrTM is an in-memory transaction processing system, which targets OLTP workloads over a large volume of data. It aims at leveraging emerging processor (HTM) and network (RDMA) features to efficiently run transactions on a modern cluster. DrTM scales by partitioning data into many shards spreading across multiple machines connected by high-performance networking with RDMA support. For each machine with n cores, DrTM employs n worker threads, each of which executes and commits a single transaction at a time, synchronizing with other threads using the HTM transactions.\nApproach Overview. We build DrTM out of two independent components: transaction layer and memory store. Figure 1 illustrates the execution of local and distributed transactions in DrTM. Like other systems [21], DrTM exposes a partitioned global address space [15, 16], where all memory in a cluster is exposed as a shared address space, but a process needs to explicitly distinguish between local and remote accesses. A remote access in DrTM is mainly done using one-sided RDMA operations for efficiency.\nOn each machine, DrTM utilizes HTM to provide transaction support. When a transaction\u2019s size is too large to fit into the working set of HTM or to lead to large abort rate, DrTM leverages transaction chopping with optimizations [44, 45, 59] to decompose larger transactions into smaller pieces. In this case, there is a restriction such that only the first piece may contain a user-initiated abort, as in prior work [59].\nDrTM is further designed with a concurrency control scheme to glue all transactions together while preserving\nstrict serializability. Typical systems mostly either use twophase locking (2PL) [7] or optimistic concurrency control (OCC) [30]. Since HTM relies on hardware (CPU) to do concurrency control for local transactions, which is hard to be aborted and rolled back by software. Therefore, to preserve serializability among conflicting transactions on multiple nodes, we design a 2PL-like protocol to coordinate accesses to the same database records from local and remote worker threads. To bridge HTM (which essentially uses OCC) and 2PL, DrTM implements the exclusive and shared locks using one-sided RDMA operations, which are cachecoherent with local accesses and thus provide strong consistency with HTM.\nThe memory store provides a general key-value store interface to the transaction layer. We design and implement an HTM/RDMA-friendly hash table, which uses one-sided RDMA operations to perform both read and write to remote key-value pairs and provides a RDMA-friendly, locationbased and host-transparent cache.\nLimitation. DrTM currently has three main limitations. First, similar to some prior work [2, 52], DrTM requires advance knowledge of read/write sets of transactions for proper locking to implement the 2PL-like protocol. Second, DrTM only provides an HTM/RDMA-friendly key-value store for the unordered store using hash table and still requires SEND/RECV Verbs for remote accesses of the ordered stores. Finally, DrTM currently preserves durability rather than availability in case of machine failures, as done in recent in-memory databases [54, 57, 60]. We plan to address these issues in our future work."
        },
        {
            "heading": "4. Supporting Distributed Transactions",
            "text": "DrTM uses HTM to provide transaction support within a single machine, and further adopts the two-phase locking (2PL) protocol to coordinate accesses to remote records for distributed transactions."
        },
        {
            "heading": "4.1 Coordinating Local and Distributed Transactions",
            "text": "Since an HTM transaction provides strong atomicity and one-sided RDMA operations are cache-coherent, DrTM uses them to bridge the HTM and 2PL protocol. The one-sided RDMA operation presents as a non-transactional access for remote records in distributed transactions, which can directly abort the conflicting HTM transactions running on the target machine.\nHowever, any RDMA operation inside an HTM transaction will unconditionally cause an HTM abort and thus we cannot directly access remote records through RDMA within HTM transactions. To this end, DrTM uses 2PL to safely accumulate all remote records into a local cache prior to the actual execution in an HTM transaction, and write back the committed updates to other machines until the local commit of the HTM transaction or discard temporal updates after an HTM abort.\nDrTM provides strictly serializable transactions, which are organized into three phases: Start, LocalTX and Commit (see Figure 2(a)). In the Start phase, a transaction locks and prefetches required remote records in advance, and then runs XBEGIN to launch an HTM transaction. In the LocalTX phase, the HTM transaction provides transactional read and write for all local records. In the Commit phase, the distributed transaction first commits the HTM transaction using XEND, and then updates and unlocks all remote records. Figure 3 shows the pseudo-code of the main transaction interfaces provided by DrTM. The confirmation of all leases in the Commit phase will be further explained in \u00a74.3.\nSimilar with prior work [2, 52], DrTM requires advanced knowledge of read/write sets of transactions for locking and prefetching in the Start phase. Fortunately, this is the case for typical OLTP transactions like TPC-C3, SmallBank [3, 49], Article [47] and SEATS [48]. For workloads that do not satisfy this requirement, we can add a read-only reconnaissance query to discover the read/write set of a particular transaction and check again if the set has been changed during the transaction [52].\nSince we use different mechanisms to protect local transactions by HTM and distributed transactions by 2PL, the same type of transactions can correctly cooperate with each other. For example, as shown in Figure 2(e), a distributed transaction will lock the remote records to prevent another distributed transaction from accessing the same record. However, the distributed transactions protected by a software mechanism (2PL) cannot directly work with the local transaction protected by a hardware mechanism (HTM). Since the RDMA operations on remote records in distributed transactions are presented as non-transactional accesses, they can directly abort local transactions which also access the same records earlier within an HTM region (see Figure 2(b)). Unfortunately, if the local accesses happen later than the remote ones, the conflicting local transaction will incorrectly commit (see Figure 2(c) and (d)). To this end, DrTM further checks the state of records inside local read and write oper-\n3 There are two dependent transactions in TPC-C: order-status and payment. Since the order-status transaction is read-only, DrTM will run it using a separate scheme without advanced knowledge of its read set (\u00a74.5). For the payment transaction, transaction chopping will transform dependent results of secondary index lookup into inputs of subsequent transaction pieces.\n! \" #\nations of an HTM transaction and explicitly aborts the HTM transaction if a conflict is detected. Further details will be presented in \u00a74.3."
        },
        {
            "heading": "4.2 Exclusive and Shared Lock",
            "text": "The implementation of the 2PL protocol relies on read/write locks to provide exclusive and shared accesses. The lack of expressiveness of one-sided RDMA operations (e.g., only READ/WRITE/CAS) becomes a major challenge.\nRDMA provides one-sided atomic compare-and-swap (CAS), which is easy to implement the exclusive lock. The semantic of RDMA CAS is equal to the normal CAS instruction (i.e., local CAS), which atomically swaps the current value with a new value if it is equal to the expected value. However, there is an atomicity issue between local CAS and RDMA CAS operations. The atomicity of RDMA CAS is hardware-specific [36], which can implement each of the three levels: IBV ATOMIC NONE, IBV ATOMIC HCA and IBV ATOMIC GLOB. The RDMA CAS can only correctly work with local CAS under IBV ATOMIC GLOB level, while our InfiniBand NIC4 only provides the IBV ATOMIC HCA level of atomicity. This means that only RDMA CASs can correctly lock each other. Fortunately, the lock will only be acquired and released by remote accesses using RDMA CAS. The local access will only check the state of locks, which can correctly work with RDMA CAS due to the cache coherence of RDMA memory.\n4 Mellanox ConnectX-3 MCX353A 56Gbps InfiniBand NIC.\nCompared to the exclusive lock, the shared lock requires extremely complicated operations to handle both sharing and exclusive semantics, which exceeds the expressiveness of one-sided RDMA operations. DrTM uses a variant of lease [23] to implement the shared lock. The lease is a contract that grants some rights to the lock holder in a time period, which is a good alternative to implement shared locking using RDMA due to no requirement of explicit releasing or invalidation.\nThe lease-based shared lock is only acquired by distributed transactions to safely read the remote records in a time period, while the local transactional read can directly overlook the shared lock due to the protection from HTM. All local and remote transactional write will actively check the state of the shared lock and abort itself when the lease is not expired. Further, to ensure the validation of leases up to the commit point, an additional confirmation is inserted into the Commit phase before the commitment of local HTM transaction (i.e., XEND)."
        },
        {
            "heading": "4.3 Transactional Read and Write",
            "text": "Figure 4 illustrates the data structure of the state, which combines exclusive (write) and shared (read) lock into a 64- byte word. The first (least) bit is used to present whether the record is exclusively locked or not, the 8-bit owner id is reserved to store the owner machine ID of each exclusive lock for durability (see \u00a74.6), and the rest of 55-bit read lease is used to store the end time of a lease for sharing the record. We used the end time instead of the duration of the lease since it will be easy to make all leases of a distributed transaction expire in the same time, which can simplify the confirmation of leases (see COMMIT in Figure 3). The duration of read lease may impact on parallelism and abort rate in DrTM. Finding the best duration of a lease is beyond the scope of this paper and is part of our future work. Currently, DrTM simply fixes the lease duration as\n1.0 ms for read-only transactions and 0.4 ms for the rest of transactions according to our cluster setting.\nThe initial state is INIT (i.e., 0x0), and the state will be set to W LOCKED, which is piggybacked with a machine ID for exclusively locking the record. The record is validly shared among readers, only if the first bit is zero and the current time (i.e., now) is earlier than the end time of its lease. The DELTA is used to tolerate the time bias among machines, which depends on the accuracy of synchronized time (see \u00a76.1).\nFigure 5 shows the pseudo-code of remote read and write. The one-sided RDMA CAS is used to lock remote records. For remote read (i.e., REMOTE READ), if the state is INIT or shared locked with unexpired lease, the record will be successfully locked in shared mode with expected or original end time. An additional RDMA READ will fetch the value of record into a local cache, and the end time is returned. If the state is locked with an expired lease, the remote read will retry RDMA CAS to lock the record with the correct current state by RDMA CAS. If the record has been locked in the exclusive mode, the remote read will abort. Similarly, the beginning of remote write (i.e., REMOTE WRITE) will also use RDMA CAS to lock the remote record but with the state LOCKED. Another difference is that the remote write will abort if the state is locked in shared mode and the lease is not expired. The ending of a remote write (i.e.,\nREMOTE WRITE BACK) will write back the update to remote record and release the lock. Note that the abort (i.e., ABORT) needs to explicitly release all owned exclusive locks and the transaction needs to retry. To simplify the exposition, we skip such details in the example code.\nAs shown in Figure 6, before actual accesses to the record, the local read (i.e., LOCAL READ) needs to ensure that the state is not locked in the exclusive mode. For the local write (i.e., LOCAL WRITE), it must further consider that the state is also not locked with an unexpired lease. In addition, the expired lease will be actively cleared in local write to avoid an additional RDMA CAS in remote read and write. Since this optimization has a side effect that adds the state of record into the write set of HTM transaction, it will not be used in local read, avoiding the false abort due to concurrent local reads.\nTable 1 lists the impact of local and remote operations to the state and the value of the record. Despite read or write, local access will only read the state, while remote access will write the state. The false write to the state by remote read may result in false conflict with local read (see Table 2). Furthermore, even though HTM tracks the read/write set at the cache-line granularity, we still contiguously store the state and the value to reduce the working set. Because there is no false sharing between them; they will always be accessed together.\nTable 2 further summarizes the conflict between local and distributed transactions due to different types and interleavings of accesses to the same record. The conflict involved in the remote write back (R WB) is ignored, since it always holds the exclusive lock. There is only one false conflict un-\nder the interleaving as shown in Figure 2(b). The remote read (R RD) will incorrectly abort the transactions which only locally read (L RD) the same record earlier, since the state in the read set of the transaction is written by the remote read for locking. Fortunately, we observe that such a case is rare and have little impact on performance."
        },
        {
            "heading": "4.4 Strict Serializability",
            "text": "This section gives an informal argument on the strict serializability of our hybrid concurrency control protocol. We argue it by reduction that our protocol equals to the strict two-phase locking (S2PL) [24]. S2PL complies with 1) all locks are acquired and no locks are released in the expanding phase, 2) all shared (read) locks are released and no lock is acquired in the shrinking phase, and 3) all exclusive (write) locks are released only after the transaction has committed or aborted.\nFirst, we show that the behavior of HTM region for local records to be written and read is equivalent to the exclusive and shared lock respectively. If both the two conflicting accesses are local and at least one is write, HTM ensures that at least one of the transactions will abort. If one of the conflicting accesses is remote, HTM with the help of the state of record can still correctly check the conflict and abort the local transaction, as shown in Table 2. The false conflict between local and remote reads only affects the performance, not the correctness.\nSecond, we also show that our lease-based shared lock is equivalent to a normal shared lock. Suppose that one record is locked in shared mode with a lease by a transaction before reading it. After that, other reads are able to share this lease, while any write to the record will be rejected until the lease is expired. On the other hand, the transaction will confirm the validation of lease before commitment, and pessimistically abort itself if the lease has expired.\nFinally, we argue that all locks will be released at a right time. The \u201clock\u201d for local records will be released after the HTM transaction commits or aborts. The confirmation after all execution of the transaction means that all shared locks are released in the shrinking phase that no lock will be acquired. After the HTM transaction commits, the updates to local records have been committed, and the updates to remote records will also eventually be committed. All exclusive locks will be released after that time."
        },
        {
            "heading": "4.5 Read-only Transactions",
            "text": "Read-only transaction is a special case which usually has a very large read set involving up to hundreds or even thousands of records. Thus, it will likely abort an HTM transaction. To remedy this, DrTM provides a separate scheme to execute read-only transactions without HTM.\nFigure 8 shows the pseudo-code of the interface for readonly transactions. The transaction first locks all records in shared mode with the same end time and prefetches the values into a local cache. After that, the transaction needs to confirm the validation of all shared locks using the end time. As the use of lease equals to a read lock, this simple scheme ensures that a read-only transaction can always read a consistent state.\nThis simple solution provides two key benefits. First, acquiring and holding shared locks until all records are read can ensure that there are no inflight conflicting transactions on any machine. This preserves the strict serializability of DrTM. Second, prior work [39] uses two-round execution to confirm the two rounds return the same results, which may be lengthy and result in new conflicts. DrTM provides an efficient and lightweight approach by directly checking the end time of shared locks."
        },
        {
            "heading": "4.6 Durability",
            "text": "DrTM currently preserves durability rather than availability in case of machine failures, as done in recent in-memory databases [54, 57, 60]. How to provide availability, e.g., through efficiently replicated logging [21, 22], will be our future work.\nDrTM uses similar failure models as other work [22, 41], where each machine has an uninterruptible power supply\n(UPS) that provides power during an outage. It assumes the flush-on-failure policy [41] and uses the power from the UPS to flush any transient state in processor registers and cache lines to non-volatile DRAM (NVRAM, like NVDIMM [50]) and finally to a persistent storage (e.g., SSD) upon a failure. A machine in a cluster may crash at any time, but only in a fail-stop manner instead of arbitrary failures like Byzantine failures [13, 29]. DrTM uses an external highly reliable coordination service, Zookeeper [27], to detect machine failures through a heartbeat mechanism and to notify surviving machines to assist the recovery of crashed machines. Zookeeper connects DrTM over a separate10GbE network to avoid rewriting it for RDMA.\nUsing HTM and RDMA to implement distributed transactions raises two new challenges for durability by logging. First, as all machines can immediately observe the local updates after the commitment of a local HTM transaction (i.e., XEND), DrTM needs to eventually commit the database transaction enclosing this HTM transaction, even if this machine failed. Second, due to all records in each machine are available to one-sided RDMA accesses without the involvement of this machine, a machine can no longer log all accesses to its owned records.\nDrTM uses cooperative logging and recovery for durability. In each machine, besides logging local updates within an HTM transaction, DrTM also logs remote updates through RDMA operations, including locking (RDMA CAS) and updates (RDMA WRITE) to remote records. The left part of Figure 7 shows that each transaction issues logging operations both before and within the HTM region. Before the HTM region, a transaction first logs chopping information (e.g., the remaining transaction pieces) if it is part of a larger parent transaction when transaction chopping is applied. Such chopping information is used to instruct DrTM on which transaction piece to execute after recovery from a crash. The transaction also logs its remote write set ahead of any exclusive locking (lock-ahead log) so that DrTM knows which records need to be unlocked during recovery. Before committing an HTM region, a transaction logs all updates of both local and remote records (write-ahead log) to NVRAM. These can be used for recovery by writing such records on the target machines. Note that each record piggybacks a version to decide the order of updates from different transactions, which is initially zero by record insertion and is increased by each local and remote write.\nDrTM checks the persisted logs to determine how to do recovery, as shown in the right part of Figure 7. If the machine crashed before the HTM commit (i.e., XEND), it implies that the transaction is not committed and thus the writeahead log will not appear in NVRAM due to the all-ornothing property of HTM. The lock-ahead log will be used to unlock remote records during recovery when necessary (see Figure 7(a)). Note that several bits (e.g., 8) of the state structure (see Figure 4) are reserved to store the owner machine of each exclusive lock, which can be used to identify the machine that locks the record at last. If the machine crashed after the HTM transaction commits, it implies that the transaction should be eventually committed and the write-ahead log in NVRAM can be used to write back and unlock local and remote records when recovery (see Figure 7(b)).\nFrom the perspective of surviving machines, their worker threads suspended their transactions involving the remote records in the crashed machine and wait for the notification from Zookeeper to assist the recovery. Currently, DrTM does not switch the worker thread to the next transaction for simplicity and for beginning the recovery as soon as possible. Figure 7(c), (d) and (e) show three cases of related transactions in a surviving machine to assist the recovery of a crashed machine, which correspond to locking in REMOTE WRITE, unlocking in ABORT and updating in WRITE BACK respectively."
        },
        {
            "heading": "5. Memory Store Layer",
            "text": "The memory store layer of DrTM provides a general keyvalue store interface to the upper transaction layer. The most common usage of this interface is to read or write records by given keys. To optimize for different access patterns [5, 32, 33], DrTM provides both an ordered store in the form of a B+ tree and an unordered store in the form of a hash table. For the ordered store, we use the B+ tree in DBX [57], which uses HTM to protect the major B+ tree operations and was shown to have comparable performance with state-ofthe-art concurrent B+ tree [35]. For the unordered store, we further design and implement a highly optimized hash table based on RDMA and HTM. For ordered store, as there is no inevitable remote access to such database tables in our workloads (i.e., TPC-C and SmallBank), we currently do not provide RDMA-based optimization for such tables. Actually, how to implement a highly-efficient RDMA-friendly B+ tree is still a challenge."
        },
        {
            "heading": "5.1 Design Spaces and Overview",
            "text": "There have been several designs that leverage RDMA to optimize hash tables, as shown in Table 3. For example, Pilaf [37] uses one-sided RDMA READs to perform GETs (i.e., READ), but requires two-sided RDMA SEND/RECV Verbs to ship update requests to the host for PUTs (i.e., INSERT/WRITE/DELETE). It uses two checksums to detect races among concurrent reads and writes and provides\nno transaction support. Cuckoo hashing [43] is used to reduce the number of RDMA operations required to perform GETs. Similarly, the key-value store on top of FaRM [21] (FaRM-KV) also uses one-sided RDMA READs to perform GETs, while a circular buffer and receive-side polling instead of SEND/RECV Verbs are used to support bi-directional accesses for PUTs. Multiple versions, lock and incarnation fields are piggybacked to the key-value pair for race detection. A variant of Hopscotch hashing [25] is used to balance the trade-off between the number and the size of RDMA operations. Another design alternative is HERD [28], which focuses on reducing network round trips. HERD uses a mix of RDMA WRITE and SEND/RECV Verbs to deliver all requests to the host for both GETs and PUTs, which requires non-trivial host CPU involvement. DrTM demands a symmetry memory store layer to support transaction processing on a cluster, in which all machines are busy processing transactions and accessing both local and remote memory stores. Therefore, we do not consider the design of HERD.\nWhile prior designs have successfully demonstrated the benefit of RDMA for memory stores, there are still rooms for improvement and the combination of HTM and RDMA provides a new design space. First, prior RDMA-friendly keyvalue stores adopt a tightly coupled design, where the design of data accesses is restricted by the race detection mechanism. For example, to avoid complex and expensive race detection mechanisms, both Pilaf and FaRM-KV only use onesided RDMA READ. This choice sacrifices the throughput and latency of updates to remote key-value pairs, which are also common operations in remote accesses for distributed transactions in typical OLTP workloads (e.g., TPC-C).\nSecond, prior designs have a bias towards RDMA-based remote operations, which increases the cost of local accesses as well. The race detection mechanisms (e.g., checksums [37] and versioning [21]) increase the pressure on the system resources (CPU and memory). For example, Pilaf uses two 64-bit CRCs to encode and decode hash table entries and key-value pairs accordingly for write and read operations. FaRM-KV adds a version field per cache line of the value for write operations, and checks the consistency of versions when reading the value. Further, all local operations, which commonly dominates the accesses, also have\nto follow the same mechanism as the remote ones with additional overhead.\nFinally, even using one-sided RDMA operations, accessing local memory is still an order-of-magnitude faster than accessing remote memory. However, there is no efficient RDMA-friendly caching scheme in prior work for both read and write operations, since traditional content-based cache has to perform strongly-consistent read locally. A write operation must synchronously invalidate every caches scattered across the entire cluster to avoid stale reads, resulting in high write latency. The cache invalidation will also incur new data race issues that require complex mechanisms to avoid, such as lease [55].\nOverview. DrTM leverages the strong atomicity of HTM and strong consistency of RDMA to design an HTM/RDMAfriendly hash table. First, DrTM decouples the race detection from the hash table by leveraging the strong atomicity of HTM, where all local operations (e.g., READ/WRITE/ INSERT/DELETE) on key-value pairs are protected by HTM transactions and thus any conflicting accesses will abort the HTM transaction. This significantly simplifies the data structures and operations for race detection. Second, DrTM uses one-sided RDMA operations to perform both READ and WRITE to remote key-value pairs without involving the host machine5. Finally, DrTM separates keys and values as well as its metadata into decoupled memory region, resulting in two-level lookups like Pilaf [37]. This makes it efficient to leverage one-sided RDMA READ for lookups, as one RDMA READ can fetch a cluster of keys. Further, the separated key-value pair makes it possible to implement RDMA-friendly, location-based and host-transparent caching (\u00a75.3)."
        },
        {
            "heading": "5.2 Cluster Hashing",
            "text": "DrTM uses Cluster chaining instead of Cuckoo [37] or Hopscotch [21] due to good locality and simple INSERTwithout moving header slots. It is because the INSERT operation is implemented as an HTM transaction and thus excessively moving header slots may exceed the HTM working set, resulting in HTM aborts. The Cluster hashing is similar to tra-\n5 The INSERT and DELETE will be shipped to the host machine using SEND/RECV Verbs and also locally executed within an HTM transaction\nditional chaining hashing with associativity, but uses decoupled memory region and shares indirect headers to achieve high space efficiency and fewer RDMA READs for lookups.\nFigure 9 shows the design of the key-value store, which consists of three regions: main header, indirect header and entry. The main header and indirect header share the same structure of buckets, each of which contains multiple header slots. The header slot is fixed as 128 bits (16 bytes), consisting of 2-bit type, 14-bit lossy incarnation, 48-bit offset and 64-bit key. The lossy incarnation uses the 14 least significant bits of the full-size incarnation, which is used to detect the liveness of entry [53]. Incarnation is initially zero and is monotonously increased by INSERT and DELETE within an HTM region, which guarantees the consistency of lossy and full-size incarnations. The offset can be located to an indirect header or entry according to the type. If the main header is full of key-value pairs, the last header slot will link to a free indirect header and change its type from Entry (T=10) to Header (T=01). The original resident and new key-value pair will be added to the indirect header. To achieve good space efficiency, even for a skewed key distribution, all indirect headers are shared by main headers and can further link each other.\nBesides the key and value fields, the entry contains 32-bit full-size incarnation, 32-bit version and 64-bit state. The version of a key-value pair is initially zero and is monotonously increased by each WRITE, which is used to decide the order of updates by applications. For example, DrTM uses it during recovery (see \u00a74.6). The state provides locking to ensure the strong consistency of remote writes for the key-value pair. DrTM implements an exclusive and shared locks on it using RDMA CAS (see \u00a74.2)."
        },
        {
            "heading": "5.3 Caching",
            "text": "The traditional content-based caching (e.g., replication) is hard to perform strong-consistent read and write locally, especially for RDMA. DrTM takes this fact into account by building location-based caching for RDMA-friendly keyvalue stores, which focuses on minimizing the lookup cost and retaining the full transparency to the host.\nCompared to caching the content of a key-value pair, caching the location (i.e., offset) of the key-value pair (i.e., entry) has several advantages. First, there is no need for invalidation or synchronization on cache as long as the keyvalue pair is not deleted, which is extremely rare compared to the read and write operations. Even if there is a deletion, DrTM implements it logically by increasing its incarnation within an HTM transaction. Consequently, it can be easily detected (e.g., incarnation checking [21]) when reading the key-value pair via caching and treated as a cache miss without worrying about stale reads. All of them are fully transparent to the host. Second, the cached location of entry can be directly shared by multiple client threads on the same machine, since all metadata (i.e., incarnation, version and state) used by the concurrency control mechanisms are encoded\nin the key-value entry. Finally, the size of cached data for the location-based mechanism (e.g., 16 Bytes) is independent to workload and usually much smaller than that of the key-value pair. For example, a 16MB memory is enough to cache one million key-value pairs.\nThe lower-right corner of Figure 9 shows the design of RDMA-friendly caching, which maps to the key-value store on a single remote machine and is shared by all client threads. The location cache adopts the same data structure as the header bucket and stores almost the same content of main and indirect headers, which can be seen as a partially stale snapshot.\nThe entire header bucket will be fetched when a certain slot of the bucket is read. The Offset field in the header slot with Entry type (T=01) can be used to access the keyvalue entry through RDMA operations. The cached header slot with Header type (T=10) can help fetch the indirect header bucket, skipping the lookup of main header bucket on the host. After caching the indirect header bucket, the original Offset field will be refilled by the local virtual address of the cached bucket and the Type field will also be changed to Cached (T=11). The following accesses to this indirect header bucket will do the lookup in local.\nThe buckets for indirect headers are assigned from a preallocated bucket pool. The traditional cache replacement policy (e.g., LRU or Reuse Distance) can be used to limit the size of the cache below a budget. Before reclaiming the evicted bucket, we first recursively reclaim all buckets on the chain starting from the evict bucket, and then reset the header slot pointed to the evicted bucket with the recorded Offset field and the Header type."
        },
        {
            "heading": "5.4 Performance Comparison",
            "text": "We compare our Cluster chaining hash table (DrTM-KV) against simplified implementations of two state-of-the-art RDMA-friendly hash tables in Pilaf [37] and FaRM [21] respectively6. Cuckoo hashing in Pilaf uses 3 orthogonal hash functions and each bucket contains 1 slot. The bucket size is fixed to 32 bytes for the self-verifying data structure. Hopscotch hashing in FaRM-KV configures the neighborhood with 8 and stores value (FaRM-KV/I) or its offset (FaRMKV/O) in the bucket. The Cluster hashing in DrTM-KV con-\n6 As their source code is not publicly available. Our simplified implementations may have better performance than their original ones due to skipping some operations.\nfigures the associativity with 8, and the bucket size is fixed to 128 Bytes.\nAll experiments were conducted on a 6-node cluster connected by Mellanox ConnectX-3 56Gbps InfiniBand, with each machine having two 10-core Intel Xeon processors and 64GB of DRAM7. The machines run Ubuntu 14.04 with Mellanox OFED v3.0-2.0.1 stack. To avoid significant performance degradation of RDMA due to excessively fetching page table entries [21], we enable 1GB hugepage to allocate physically-contiguous memory registered for remote accesses via RDMA. A single machine runs 8 server threads on distinct physical cores of the same socket, and the rest five machines run up to 8 client threads each. We generate 20 million key-value pairs with fixed 8-Byte keys, occupying up to 40GB memory. Two types of workloads, uniform and skewed, are used. Keys were chosen randomly with a uniform distribution or a skewed Zipf distribution prescribed by YCSB [17] with \u03b8=0.99.\nSince only DrTM-KV implements writes using one-sided RDMA, our experiment focuses on comparing the average number of RDMA READs for lookups, as well as the throughput and latency of read operations. Finally, we study the impact of cache size on the throughput of DrTM-KV.\nTable 4 lists the average number of RDMA READs for lookups at different occupancies without caching. The result of Hopscotch hashing in FaRM-KV and Cluster hashing in DrTM-KV is close and notably better than that of Cuckoo hashing in Pilaf for both uniform and skewed workload, since each RDMA READ in Hopscotch and Cluster hashing can acquire up to 8 candidates, while only one candidate is acquired in Cuckoo hashing. The small advantage of Hopscotch hashing at high occupancy is due to gradually refining the location of keys and fine-grained space sharing between different keys. Yet, it makes the insertion operation much complicated and hard to be cached. However, location-based caching can significantly reduce the lookup cost of Cluster hashing. For example, Cluster hashing with only 20MB cache can eliminate about 75% RDMA READs under a skewed workload for 20 million key-value pairs, even the cache starts from empty.\nWe further compare the throughput and latency of read operations on different key-value systems. DrTM-KV disables cache and DrTM-KV/$ starts from a 320MB cold cache per machine shared by all client threads. FaRM-KV/I and FaRM-KV/O put the key-value pairs inside and outside their header slots respectively. Figure 10(b) shows the throughput with different value sizes for a uniform workload. Since all of Pilaf, FaRM-KV/O and DrTM-KV need an additional RDMA READ to read the key-value pair after lookup, their throughput shows a similar trend. The difference of their throughput for small value is mainly due to the difference of lookups cost (see Table 4). Nevertheless, with the increase of value size, the difference decreases since the\n7 Detailed machine configurations can be found in \u00a77.1.\ncost for reading key-value pairs dominates the performance (see Figure 10(a)). FaRM-KV/I has a quite good throughput for a relatively small value due to avoiding an additional RDMA READ, but the performance significantly degrades with the increase of value size, due to fetching 8 times values and poor performance of RDMA READ for a large payload (see Figure 10(a)). DrTM-KV/$ has the best performance even compared with FaRM-KV/I for small value size due to two reasons. First, DrTM-KV/$ fetches the entire bucket (8 slots) at a time which increases the hit rate of location-based cache and decreases the average number of RDMA READs for lookups to 0.178 even from cold cache. Second, sharing the cache among client threads further accelerates the prefetching and decreases the average cost for lookups to 0.024 for 8 client threads per machine. For up to 128-byte value, DrTM-KV/$ can achieve over 23 Mops/sec, which outperforms FaRM-KV/O and Pilaf by up to 2.09X and 2.74X respectively.\nFigure 10(c) shows the average latencies of three systems with 64-byte value for a uniform workload. We varied the load on server by first increasing the number of client threads per machine from 1 to 8 and then increasing the client machine from 1 to 5, until the throughout saturated. DrTM-KV is able to achieve 11.6 Mops/sec with approximately 6.3 \u03bcs average latency, which is almost the same to FaRM-KV/O and notably better than that of Pilaf (8.4 Mops/sec and 8.2 \u03bcs). FaRM-KV/I provides relatively lower average latency (4.5 \u03bcs) but poor throughput (5.6 Mops/sec) due to its design choice that saves one round trip but amplifies the read size. DrTM-KV/$ can achieve both lowest latency (3.4 \u03bcs) and highest throughput (23.4 Mops/sec) due to its RDMAfriendly cache.\nTo study the impact of cache size, we evaluate DrTMKV/$ with different cache sizes using both uniform and skewed workloads. The location-based cache starts from empty (/Cold) or after a 10-second warm-up (/Warm). For 20 million key-value pairs, a 320MB cache is enough to store the entire location information to thoroughly avoid lookup via RDMA. Therefore, as shown in Figure 10(d), the throughput of DrTM-KV with warmed-up cache can achieve 25.1 Mops for skewed workload, which is much close to the\nthroughput of one-sided RDMA READ in Figure 10(a) (26.3 Mops). Since skewed workload is more friendly to cache, the throughput with only 20MB cache still achieves 19.1 Mops. However, the throughput for uniform workload rapidly drops from 24.9 Mops to 11.2 Mops when reducing the cache size from 320MB to 80MB, since it is the worst case and we only use a simple directly mapping. How to improve the cache through heuristic structure (e.g., associativity) and replacement mechanisms (e.g., LRU) will be our future work. The performance of DrTM-KV with cold or warmed-up cache is close, due to fetching the entire bucket at a time (8 slots) and sharing the cache among clients (8 threads)."
        },
        {
            "heading": "6. Implementation Issues",
            "text": "We have implemented DrTM based on Intel\u2019s Restricted Transactional Memory (RTM) and Mellanox ConnectX-3 56Gbps InfiniBand. This section describes some specific implementation issues."
        },
        {
            "heading": "6.1 Synchronized Time",
            "text": "Implementing lease requires synchronized time. Ideally, one could use the TrueTime protocol in Spanner [18] to get synchronized time, which is, however, not available in our cluster. Instead, we use the precision time protocol (PTP) [1], whose precision can reach 50\u03bcs under high-performance networking. Unfortunately, accessing such services inside an RTM region will unconditionally abort RTM transactions. Instead, DrTM uses a timer thread to periodically update a global software time (i.e., softtime). This provides an approximately synchronized time to all transactions.\nThe softtime will be read in the remote read and write in the Start phase, the local read and write in the LocalTX phase and the lease reconfirmation in the Commit phase. The later three cases locate inside an RTM region. They will not directly abort the transaction, but may result in frequent false conflicts with the timer thread due to the strong atomicity of RTM (see Figure 11(b)). On the contrary, as shown in Figure 11(a), a long update interval of softtime can reduce false aborts due to the timer thread. However, it also increases the time skew and then increases the DELTA, resulting in failures when lease confirmation and thus transaction aborts.\nTo remedy this, DrTM reuses the softtime acquired in the Start phase (outside the RTM region) for all local read and write operations first, and then only acquires softtime for lease confirmation (Figure 11(c)). It will significantly narrow the conflict range of an RTM transaction to the timer thread, since the confirmation is close to the commitment of an RTM transaction. Further, the local transactions will never be aborted by timer threads. Note that reusing stale softtime to conservatively check the expiration of a lease acquired by other transactions will not hurt the correctness but only incur some false positives."
        },
        {
            "heading": "6.2 Fallback Handler and Contention Management",
            "text": "As a best-effort mechanism, an RTM transaction does not have guaranteed forward progress even in the absence of conflicts. A fallback handler will be executed after the number of RTM aborts exceeds a threshold. In traditional implementation, the fallback handler first acquires a coarsegrained exclusive lock, and then directly updates all records. To cooperate with the fallback handler, the RTM transaction needs to check this lock before entering its RTM region.\nIn DrTM, however, if the local record will also be remotely accessed by other transactions, the fallback handler may inconsistently update the record out of an RTM region. Therefore, we use remote read and write to access the local records in the fallback handler. The fallback handler follows the 2PL protocol to access all records as well. Further, to avoid deadlock, the fallback handler should release all owned remote locks first, and then acquires appropriate locks for all records in a global order (e.g., using <table id, key>). After that, the fallback handler should confirm the validation of leases before any update to the records since they cannot be rolled back by RTM again. Since all shared locks are still released in the shrinking phase that no lock will be acquired, the modification to fallback handler still preserves the strict serializability of DrTM. Finally, since the fallback handler will lock all of records and update them out of the HTM region, DrTM will perform logs ahead of updates for them as in normal systems for durability."
        },
        {
            "heading": "6.3 Atomicity Issues",
            "text": "As mentioned in \u00a74.2, even if RDMA CAS on our InfiniBand NIC cannot preserve the atomicity with local CAS, it\nwill not incur consistency issues in the normal execution of transactions. However, in RTM\u2019s fallback handler and readonly transactions, DrTM has to lock both local and remote records. A simple solution is to uniformly use the RDMA CAS for local records. However, the current performance of RDMA CAS is two orders of magnitude slower than the local counterpart (14.5 \u03bcs vs. 0.08 \u03bcs). Using RDMA CAS for all records in the RTM fallback handler results in about 15% slowdown of throughput for DrTM. It leaves much room for performance improvement by simply upgrading the NIC with GLOB-level atomicity (e.g., QLogic QLE series)."
        },
        {
            "heading": "6.4 Horizontal Scaling Across Socket",
            "text": "Currently, our B+ tree for ordered store is not NUMAfriendly and thus has limited scalability across sockets. Our evaluation using micro-benchmark shows that it stop scaling after 10 cores (with 3.89X speedup compared to 1 core) and only reaches 2.19X speedup over 1 core using 12 cores (cross sockets); the performance after 12 cores steadily drops. This is mainly due to excessive cross-socket memory accesses, which not only incur higher latency, but also cause contention on a single socket. Currently, we exploit our NUMA machines by placing a memory store of TPC-C on each NUMA node. It will be our future work to design and implement a NUMA-friendly B+ tree."
        },
        {
            "heading": "6.5 Remote Range Query",
            "text": "DrTM only provides an HTM/RDMA-friendly hash table for unordered stores while still requires SEND/RECV Verbs for ordered stores. Fortunately, we found that in TPC-C, the only transaction (i.e., payment) occasionally requiring remote accesses to an ordered store (for range query) only requires local accesses to unordered stores. We optimize this case by sending this transaction to the remote machine hosting the ordered store. In this way, we convert this transaction to have local accesses to an ordered store and remote accesses to unordered stores, which can enjoy the full benefit of RDMA."
        },
        {
            "heading": "7. Evaluation",
            "text": ""
        },
        {
            "heading": "7.1 Experimental Setup",
            "text": "All experiments were conducted on a small-scale cluster with 6 machines. Each machine has two 10-core RTMenabled8 Intel Xeon E5-2650 v3 processors and 64GB of DRAM. Each core has a private 32KB L1 cache and a private 256KB L2 cache, and all 10 cores on a single processor share a 24MB L3 cache. We disabled hyperthreading on all machines. Each machine is equipped with a ConnectX-3 MCX353A 56Gbps InfiniBand NIC via PCIe 3.0 x8 connected to a Mellanox IS5025 40Gbps InfiniBand Switch, and an Intel X520 10GbE NIC connected to a Force10 S4810P\n8 Though a recent hardware bug forced Intel to temporarily turn off this feature on a recent release of processor series, we successfully reenabled it by configuring some model specific registers.\n10/40GbE Switch. All machines run Ubuntu 14.04 with Mellanox OFED v3.0-2.0.1 stack.\nWe evaluate DrTM using TPC-C [51] and SmallBank [3]. TPC-C simulates a warehouse-centric order processing application. It scales by partitioning a database into multiple warehouses spreading across multiple machines. SmallBank models a simple banking application where transactions perform simple read and write operations on user accounts. The access patterns of transactions are skewed such that a few accounts receive most of the requests. TPC-C is a mix of five types of transactions for new-order (NEW), payment (PAY), order-status (OS), delivery (DLY) and stocklevel (SL) procedures. SmallBank is a mix of six type of transactions for send-payment (SP), balance (BAL), depositchecking (DC), withdraw-from-checking (WC), transfer-tosavings (TS) and amalgamate (AMG) procedures. Table 5 shows the percentage of each transaction type and its access pattern in TPC-C and SmallBank. We chopped TPC-C to reduce working set while leaving all transactions in SmallBank unchopped as their working set are already small enough to fit into RTM with small abort rates.\nCross-system comparison between distributed systems is often hard due to various setup requirements and configurations even for the same benchmark. We use the latest Calvin [52] (released in Mar. 2015) in a part of experiments on TPC-C. As Calvin is hard-coded to use 8 worker threads per machine, we have to skip it from the experiment with varying numbers of threads. We run Calvin on our InfiniBand network using IPoIB as it was not designed to use RDMA.\nIn all experiments, we dedicate one processor to run up to 8 worker threads. We use the same machine to generate requests to avoid the impact of networking between clients and servers as done in prior work [52, 54, 57]. All experimental results are the average of five runs. Unless mentioned, logging is turned off for all systems and experiments. We separately evaluate the performance overhead for logging in section 7.5."
        },
        {
            "heading": "7.2 Performance and Scalability",
            "text": "TPC-C: We first run TPC-C with the increase of machines to compare the performance with Calvin. To align with the\nsetting of Calvin, each machine runs 8 worker threads and each of them hosts 1 warehouse with 10 districts. All warehouses in a single machine shares a memory store. Figure 12 shows the throughput of the new-order transaction and the TPC-C\u2019s standard-mix workload. Note that, in TPCC, throughput is defined as how many new-order transactions per second a system processed while the system is executing four other transactions types; Calvin only reported TPC-C\u2019s standard-mix throughput. As shown in Figure 12, DrTM outperforms Calvin by up to 21.9X (from 17.9X), due to exploiting advanced processor features (RTM) and fast interconnects (RDMA). Even without sophisticated techniques to reduce the contention associated with distributed transactions, DrTM can still scale well in term of the number of machines by using our RDMA-friendly 2PL protocol. DrTM can process more than 1.65 million new-order and 3.67 million standard-mix transactions per second (txns/sec) on 6 machines, which is much faster than the result of Calvin on 100 machines reported in [52] (less than 500,000 standard-mix txns/sec).\nHorizontal Scaling: To fully exploit the hardware resources, we run a separate logical node with 8 worker threads on each socket of a single machine (DrTM(S)). The interaction between two logical nodes sharing the same machine still uses our 2PL protocol via one-sided RDMA operations. DrTM(S) achieves more than 2.48 million new-order and 5.52 million standard-mix transactions per second on 6 machines (46,000 txns/sec per core).\nWe further study the scalability of DrTM with the increase of worker threads using 6 machines. As shown in Figure 13, DrTM provides good scalability up to 8 threads. The speedup of throughput using 8 threads reaches 5.56X. However, as our B+ tree is currently not NUMA-friendly and has poor performance cross sockets, its performance starts to de-\ngrade after 8 cores. When using two separate logical nodes, DrTM(S) can further improve the speedup to 8.29X using 16 threads. Note that there is only one data point for Calvin using 8 threads as it cannot run with other number of threads.\nTo overcome the restriction of existing cluster size, we scale separate logical nodes on single machine to emulate the scalability experiment, each of which has fixed 4 worker threads. As shown in Figure 14, DrTM can scale out to 24 nodes, reaching 2.42 million new-order and 5.38 million standard-mix transactions per second.\nSmallBank: We further study the performance and scalability of SmallBank with varying probability of distributed transactions. Figure 15 shows the throughput of SmallBank on DrTM with the increase of machines and threads. For a low probability of distributed transactions (1%), DrTM provides high performance and can scale well in two dimensions. It achieves over 138 million transactions per second using 6 machines and the speedup of throughput reaches 4.52X for 6 machines and 10.85X for 16 threads respectively. With the growing of distributed transactions, DrTM still performs stable throughput increase from 2 machines and scale-well within a single socket."
        },
        {
            "heading": "7.3 Impact from Distributed Transactions",
            "text": "To investigate the performance of DrTM for distributed transactions, we adjust the probability of cross-warehouse accesses for new-order transactions from 1% to 100%. According to the TPC-C specification, the default setting is that there is 1% of accesses to a remote warehouse. Since the average number of items accessed in the new-order transaction is 10, 10% of cross-warehouse accesses will result in approximate 57.2% of distributed transactions.\nFigure 16 shows the throughput of new-order transaction on DrTM with increasing cross-warehouse accesses. The 100% cross-warehouse accesses results in about 85% slowdown, because all transactions are distributed and any accesses are remote ones. Hence, DrTM cannot benefit from RTM in this case. However, the performance slowdown for 5% cross-warehouse accesses (close to 35% distributed transaction) is moderate (15.0%)."
        },
        {
            "heading": "7.4 Read Lease",
            "text": "To study the benefit of read lease, we implement two microbenchmarks, which share most characteristics with the neworder transaction but are easier to adjust the execution behavior. The probability of cross-warehouse accesses is 10%.\nThe first simplified transaction, namely read-write, accesses 10 records and does the original tasks, except that parts of them will not write back the results, becoming a read access to that record. We evaluate the throughput of this read-write transaction on DrTM, as shown in Figure 17. Without read lease, all remote accesses need to acquire the exclusive lock of record, regardless of whether the transaction writes the record or not. Thus, the ratio of read operations has less impact on per-node throughput without read lease. With the increase of read accesses, read lease exposes more concurrency and notably improves the throughput.\nIn the second micro-benchmark, the hotspot transaction also accesses 10 records and do the original tasks, except that one of 10 records is chosen from a much small set of \u201chot\u201d records and do read. Figure 17 shows the per-node throughput for this transaction enabling read lease or not. The 120 hot records are evenly assigned to all machines. With the increase of machines, the improvement from read lease increases steadily, reaching up to 29% for 6 machines."
        },
        {
            "heading": "7.5 Durability",
            "text": "To investigate the performance cost for durability, we evaluate TPC-C with durability enabled. Currently, we directly use a dedicated region of DRAM to emulate battery-backed NVRAM. Table 6 shows the performance difference on 6 machines with 8 threads. Due to additional writes to NVRAM, the throughput of the new-order transaction on DrTM degrades by 11.6% and the rate of capacity aborts and executing fallback handler increase by 4.42% and 4.78% respectively. Since DrTM does not use multiple versioning [57] or durability epoch [60], as well as only writes logs to NVRAM in critical path, the increase of latency for 50%, 90% and 99% transactions is lower than 10\u03bcs for logging or not respectively, which is still two orders of magnitude better than that of Calvin even without logging (6.04, 15.84 and 60.54 ms)."
        },
        {
            "heading": "8. Related Work",
            "text": "Distributed transactions: DrTM continues the line of research of providing fast transactions for multicore and clusters [18\u201320, 42, 52, 54, 58\u201360], but explores an additional design dimension by demonstrating that advanced hardware features like HTM and RDMA may be used together to provide notably fast ACID transactions with a local cluster. FaRM [21] also leverages RDMA (but no HTM) to provide limited transactions support using OCC and 2PC, but lacks evaluation of general transactions. DrTM steps further to combine HTM and strict 2PL with a set of optimizations to provide fast transactions and was shown to orders of magnitude faster than prior work for OLTP workloads like TPCC and SmallBank.\nDistributed transactional memory: Researchers have started to investigate the use of transactional memory abstraction for distributed systems. Herlihy and Sun [26] described a hierarchical cache coherence protocol that takes distance and locality into account to support transactional memory in a cluster but has no actual implementation and evaluation. The hardware limitation forces researchers to switch to software transactional memory [46] and investigate how to scale it out in a cluster environment [11, 12, 34]. DrTM instead leverages the strong consistency of RDMA and strong atomicity of HTM to support fast database trans-\nactions, by offloading main transaction operations inside a hardware transaction.\nLeveraging HTM for database transactions: The commercial availability of HTM has stimulated several recent efforts of leveraging HTM to provide database transactions on multicore [31, 44, 57]. While Wang et al. [57] and Leis et al. [31] only leverage RTM to implement traditional concurrency control protocols (e.g., OCC [30] and TSO [8]), DBXTC [44] uses RTM to directly protect the entire transactional execution. It leverages static analysis and transaction chopping [6, 9, 39, 45, 59] to decompose a large transaction into smaller pieces with a set of optimizations, which exposes notably more opportunities for decomposition. DrTM extends it by leveraging RDMA and strict 2PL to support fast crossmachine transactions.\nLease: Lease [23] is widely used to improve the read performance, which is also used in DrTM to unleash concurrency among local and remote readers, as well as to simply conflict checking for read-only transactions. Megastore [4] grants a read lease to all nodes. All reads can be handled locally, while the involved writes invalidate all other replicas synchronously or just wait for the timeout of the lease before committing a write. Spanner [18] uses the leader lease [14] and snapshot reads to save the performance of write by relaxed consistency. Quorum leases [38] allow a majority of replicas to perform strongly consistent local reads, which substantially reduces read latency at those replicas."
        },
        {
            "heading": "9. Conclusion",
            "text": "The emergence of advanced hardware features like HTM and RDMA exposed new opportunities to rethink the design of transaction processing systems. This paper described DrTM, an in-memory transaction processing system that exploits the strong atomicity of HTM and strong consistency of RDMA to provide orders of magnitude higher throughput and lower latency of in-memory transaction processing than prior general designs. DrTM was built with a set of optimizations like leases and HTM/RDMA-friendly hash table that expose more parallelism and reduced RDMA operations. Evaluations using typical OLTP workloads like TPC-C and SmallBank confirmed the benefit of designs in DrTM. The source code of DrTM will be available at http://ipads. se.sjtu.edu.cn/drtm."
        },
        {
            "heading": "Acknowledgment",
            "text": "We sincerely thank our shepherd Emmett Witchel and the anonymous reviewers for their insightful suggestions, Anuj Kalia for sharing his experience on RDMA, and Yingjun Wu for the valuable feedback. This work is supported in part by National Youth Top-notch Talent Support Program of China, China National Natural Science Foundation (61402284, 61572314), Doctoral Fund of Ministry of Education of China (No. 20130073120040), a foundation for the Author of National Excellent Doctoral Dissertation of PR China(No. TS0220103006), and Singapore CREATE E2S2."
        }
    ],
    "title": "Fast In-memory Transaction Processing using RDMA and HTM",
    "year": 2015
}