{
    "abstractText": "Learning with recurrent neural networks (RNNs) on long sequences is a notoriously difficult task. There are three major challenges: 1) complex dependencies, 2) vanishing and exploding gradients, and 3) efficient parallelization. In this paper, we introduce a simple yet effective RNN connection structure, the DILATEDRNN, which simultaneously tackles all of these challenges. The proposed architecture is characterized by multi-resolution dilated recurrent skip connections, and can be combined flexibly with diverse RNN cells. Moreover, the DILATEDRNN reduces the number of parameters needed and enhances training efficiency significantly, while matching state-of-the-art performance (even with standard RNN cells) in tasks involving very long-term dependencies. To provide a theory-based quantification of the architecture\u2019s advantages, we introduce a memory capacity measure, the mean recurrent length, which is more suitable for RNNs with long skip connections than existing measures. We rigorously prove the advantages of the DILATEDRNN over other recurrent neural architectures. The code for our method is publicly available1.",
    "authors": [
        {
            "affiliations": [],
            "name": "Shiyu Chang"
        },
        {
            "affiliations": [],
            "name": "Yang Zhang"
        },
        {
            "affiliations": [],
            "name": "Wei Han"
        },
        {
            "affiliations": [],
            "name": "Mo Yu"
        },
        {
            "affiliations": [],
            "name": "Xiaoxiao Guo"
        },
        {
            "affiliations": [],
            "name": "Wei Tan"
        },
        {
            "affiliations": [],
            "name": "Xiaodong Cui"
        },
        {
            "affiliations": [],
            "name": "Michael Witbrock"
        },
        {
            "affiliations": [],
            "name": "Mark Hasegawa-Johnson"
        },
        {
            "affiliations": [],
            "name": "Thomas S. Huang"
        },
        {
            "affiliations": [],
            "name": "Thomas J. Watson"
        }
    ],
    "id": "SP:8b60c9ae964cc8fa8daa6d2da098bef1581600ba",
    "references": [
        {
            "authors": [
                "Mart\u00edn Abadi",
                "Ashish Agarwal",
                "Paul Barham",
                "Eugene Brevdo",
                "Zhifeng Chen",
                "Craig Citro",
                "Greg S Corrado",
                "Andy Davis",
                "Jeffrey Dean",
                "Matthieu Devin"
            ],
            "title": "Tensorflow: Large-scale machine learning on heterogeneous distributed systems",
            "venue": "arXiv preprint arXiv:1603.04467,",
            "year": 2016
        },
        {
            "authors": [
                "Martin Arjovsky",
                "Amar Shah",
                "Yoshua Bengio"
            ],
            "title": "Unitary evolution recurrent neural networks",
            "venue": "In International Conference on Machine Learning,",
            "year": 2016
        },
        {
            "authors": [
                "Eduardo R Caianiello",
                "Gaetano Scarpetta",
                "Giovanna Simoncelli"
            ],
            "title": "A systemic study of monetary systems",
            "venue": "International Journal Of General System,",
            "year": 1982
        },
        {
            "authors": [
                "Junyoung Chung",
                "Sungjin Ahn",
                "Yoshua Bengio"
            ],
            "title": "Hierarchical multiscale recurrent neural networks",
            "venue": "arXiv preprint arXiv:1609.01704,",
            "year": 2016
        },
        {
            "authors": [
                "Junyoung Chung",
                "Caglar Gulcehre",
                "KyungHyun Cho",
                "Yoshua Bengio"
            ],
            "title": "Empirical evaluation of gated recurrent neural networks on sequence modeling",
            "venue": "arXiv preprint arXiv:1412.3555,",
            "year": 2014
        },
        {
            "authors": [
                "Tim Cooijmans",
                "Nicolas Ballas",
                "C\u00e9sar Laurent",
                "\u00c7a\u011flar G\u00fcl\u00e7ehre",
                "Aaron Courville"
            ],
            "title": "Recurrent batch normalization",
            "venue": "arXiv preprint arXiv:1603.09025,",
            "year": 2016
        },
        {
            "authors": [
                "Salah El Hihi",
                "Yoshua Bengio"
            ],
            "title": "Hierarchical recurrent neural networks for long-term dependencies",
            "venue": "In Nips,",
            "year": 1995
        },
        {
            "authors": [
                "Sepp Hochreiter",
                "J\u00fcrgen Schmidhuber"
            ],
            "title": "Long short-term memory",
            "venue": "Neural computation,",
            "year": 1997
        },
        {
            "authors": [
                "Herbert Jaeger"
            ],
            "title": "Short term memory in echo state networks, volume 5",
            "venue": "GMD-Forschungszentrum Informationstechnik,",
            "year": 2001
        },
        {
            "authors": [
                "Jan Koutnik",
                "Klaus Greff",
                "Faustino Gomez",
                "Juergen Schmidhuber"
            ],
            "title": "A clockwork rnn",
            "venue": "arXiv preprint arXiv:1402.3511,",
            "year": 2014
        },
        {
            "authors": [
                "David Krueger",
                "Tegan Maharaj",
                "J\u00e1nos Kram\u00e1r",
                "Mohammad Pezeshki",
                "Nicolas Ballas",
                "Nan Rosemary Ke",
                "Anirudh Goyal",
                "Yoshua Bengio",
                "Hugo Larochelle",
                "Aaron Courville"
            ],
            "title": "Zoneout: Regularizing rnns by randomly preserving hidden activations",
            "venue": "arXiv preprint arXiv:1606.01305,",
            "year": 2016
        },
        {
            "authors": [
                "Quoc V Le",
                "Navdeep Jaitly",
                "Geoffrey E Hinton"
            ],
            "title": "A simple way to initialize recurrent networks of rectified linear units",
            "venue": "arXiv preprint arXiv:1504.00941,",
            "year": 2015
        },
        {
            "authors": [
                "Yann LeCun",
                "L\u00e9on Bottou",
                "Yoshua Bengio",
                "Patrick Haffner"
            ],
            "title": "Gradient-based learning applied to document recognition",
            "venue": "Proceedings of the IEEE,",
            "year": 1998
        },
        {
            "authors": [
                "Mitchell P Marcus",
                "Mary Ann Marcinkiewicz",
                "Beatrice Santorini"
            ],
            "title": "Building a large annotated corpus of english: The penn treebank",
            "venue": "Computational linguistics,",
            "year": 1993
        },
        {
            "authors": [
                "Daniel Neil",
                "Michael Pfeiffer",
                "Shih-Chii Liu"
            ],
            "title": "Phased LSTM: accelerating recurrent network training for long or event-based sequences",
            "venue": "arXiv preprint arXiv:1610.09513,",
            "year": 2016
        },
        {
            "authors": [
                "Razvan Pascanu",
                "Tomas Mikolov",
                "Yoshua Bengio"
            ],
            "title": "On the difficulty of training recurrent neural networks",
            "venue": "ICML (3),",
            "year": 2013
        },
        {
            "authors": [
                "Tara N Sainath",
                "Ron J Weiss",
                "Andrew Senior",
                "Kevin W Wilson",
                "Oriol Vinyals"
            ],
            "title": "Learning the speech frontend with raw waveform cldnns",
            "venue": "In Sixteenth Annual Conference of the International Speech Communication Association,",
            "year": 2015
        },
        {
            "authors": [
                "Stanislau Semeniuta",
                "Aliaksei Severyn",
                "Erhardt Barth"
            ],
            "title": "Recurrent dropout without memory loss",
            "venue": "arXiv preprint arXiv:1603.05118,",
            "year": 2016
        },
        {
            "authors": [
                "Tijmen Tieleman",
                "Geoffrey Hinton"
            ],
            "title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude",
            "venue": "COURSERA: Neural networks for machine learning,",
            "year": 2012
        },
        {
            "authors": [
                "A\u00e4ron van den Oord",
                "Sander Dieleman",
                "Heiga Zen",
                "Karen Simonyan",
                "Oriol Vinyals",
                "Alex Graves",
                "Nal Kalchbrenner",
                "Andrew Senior",
                "Koray Kavukcuoglu"
            ],
            "title": "Wavenet: A generative model for raw audio",
            "venue": "CoRR abs/1609.03499,",
            "year": 2016
        },
        {
            "authors": [
                "Alexander Sasha Vezhnevets",
                "Simon Osindero",
                "Tom Schaul",
                "Nicolas Heess",
                "Max Jaderberg",
                "David Silver",
                "Koray Kavukcuoglu"
            ],
            "title": "Feudal networks for hierarchical reinforcement learning",
            "venue": "arXiv preprint arXiv:1703.01161,",
            "year": 2017
        },
        {
            "authors": [
                "Scott Wisdom",
                "Thomas Powers",
                "John Hershey",
                "Jonathan Le Roux",
                "Les Atlas"
            ],
            "title": "Full-capacity unitary recurrent neural networks",
            "venue": "In Advances in Neural Information Processing Systems,",
            "year": 2016
        },
        {
            "authors": [
                "Zhengzheng Xing",
                "Jian Pei",
                "Eamonn Keogh"
            ],
            "title": "A brief survey on sequence classification",
            "venue": "ACM Sigkdd Explorations Newsletter,",
            "year": 2010
        },
        {
            "authors": [
                "Junichi Yamagishi"
            ],
            "title": "English multi-speaker corpus for cstr voice cloning",
            "venue": "toolkit. http://homepages.inf. ed.ac.uk/jyamagis/page3/page58/page58.html,",
            "year": 2012
        },
        {
            "authors": [
                "Adams W Yu",
                "Hongrae Lee",
                "Quoc V Le"
            ],
            "title": "Learning to skim text",
            "venue": "arXiv preprint arXiv:1704.06877,",
            "year": 2017
        },
        {
            "authors": [
                "Fisher Yu",
                "Vladlen Koltun"
            ],
            "title": "Multi-scale context aggregation by dilated convolutions",
            "venue": "arXiv preprint arXiv:1511.07122,",
            "year": 2015
        },
        {
            "authors": [
                "Fisher Yu",
                "Vladlen Koltun",
                "Thomas Funkhouser"
            ],
            "title": "Dilated residual networks",
            "venue": "arXiv preprint arXiv:1705.09914,",
            "year": 2017
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "Recurrent neural networks (RNNs) have been shown to have remarkable performance on many sequential learning problems. However, long sequence learning with RNNs remains a challenging problem for the following reasons: first, memorizing extremely long-term dependencies while maintaining mid- and short-term memory is difficult; second, training RNNs using back-propagationthrough-time is impeded by vanishing and exploding gradients; And lastly, both forward- and back-propagation are performed in a sequential manner, which makes the training time-consuming.\nMany attempts have been made to overcome these difficulties using specialized neural structures, cells, and optimization techniques. Long short-term memory (LSTM) [10] and gated recurrent units (GRU) [6] powerfully model complex data dependencies. Recent attempts have focused on multi-timescale designs, including clockwork RNNs [12], phased LSTM [17], hierarchical multi-scale RNNs [5], etc. The problem of vanishing and exploding gradients is mitigated by LSTM and GRU memory gates; other partial solutions include gradient clipping [18], orthogonal and unitary weight optimization [2, 14, 24], and skip connections across multiple timestamps [8, 30]. For efficient sequential training, WaveNet [22] abandoned RNN structures, proposing instead the dilated causal convolutional neural network (CNN) architecture, which provides significant advantages in working directly with raw audio waveforms. However, the length of dependencies captured by a dilated CNN is limited by its kernel size, whereas an RNN\u2019s autoregressive modeling can, in theory, capture potentially infinitely \u2217Denotes equal contribution. 1https://github.com/code-terminator/DilatedRNN\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\nar X\niv :1\n71 0.\n02 22\n4v 3\n[ cs\n.A I]\n2 N\nov 2\nlong dependencies with a small number of parameters. Recently, Yu et al. [27] proposed learningbased RNNs with the ability to jump (skim input text) after seeing a few timestamps worth of data; although the authors showed that the modified LSTM with jumping provides up to a six-fold speed increase, the efficiency gain is mainly in the testing phase.\nIn this paper, we introduce the DILATEDRNN, a neural connection architecture analogous to the dilated CNN [22, 28], but under a recurrent setting. Our approach provides a simple yet useful solution that tries to alleviate all challenges simultaneously. The DILATEDRNN is a multi-layer, and cell-independent architecture characterized by multi-resolution dilated recurrent skip connections. The main contributions of this work are as follows. 1) We introduce a new dilated recurrent skip connection as the key building block of the proposed architecture. These alleviate gradient problems and extend the range of temporal dependencies like conventional recurrent skip connections, but in the dilated version require fewer parameters and significantly enhance computational efficiency. 2) We stack multiple dilated recurrent layers with hierarchical dilations to construct a DILATEDRNN, which learns temporal dependencies of different scales at different layers. 3) We present the mean recurrent length as a new neural memory capacity measure that reveals the performance difference between the previously developed recurrent skip-connections and the dilated version. We also verify the optimality of the exponentially increasing dilation distribution used in the proposed architecture. It is worth mentioning that, the recent proposed Dilated LSTM [23] can be viewed as a special case of our model, which contains only one dilated recurrent layer with fixed dilation. The main purpose of their model is to reduce the temporal resolution on time-sensitive tasks. Thus, the Dilated LSTM is not a general solution for modeling at multiple temporal resolutions.\nWe empirically validate the DILATEDRNN in multiple RNN settings on a variety of sequential learning tasks, including long-term memorization, pixel-by-pixel classification of handwritten digits (with permutation and noise), character-level language modeling, and speaker identification with raw audio waveforms. The DILATEDRNN improves significantly on the performance of a regular RNN, LSTM, or GRU with far fewer parameters. Many studies [6, 14] have shown that vanilla RNN cells perform poorly in these learning tasks. However, within the proposed structure, even vanilla RNN cells outperform more sophisticated designs, and match the state-of-the-art. We believe that the DILATEDRNN provides a simple and generic approach to learning on very long sequences."
        },
        {
            "heading": "2 Dilated Recurrent Neural Networks",
            "text": "The main ingredients of the DILATEDRNN are its dilated recurrent skip connection and its use of exponentially increasing dilation; these will be discussed in the following two subsections respectively."
        },
        {
            "heading": "2.1 Dilated Recurrent Skip Connection",
            "text": "Denote c(l)t as the cell in layer l at time t. The dilated skip connection can be represented as\nc (l) t = f ( x (l) t , c (l)\nt\u2212s(l)\n) . (1)\nThis is similar to the regular skip connection[8, 30], which can be represented as\nc (l) t = f ( x (l) t , c (l) t\u22121, c (l)\nt\u2212s(l)\n) . (2)\ns(l) is referred to as the skip length, or dilation of layer l; x(l)t as the input to layer l at time t; and f(\u00b7) denotes any RNN cell and output operations, e.g. Vanilla RNN cell, LSTM, GRU etc. Both skip connections allow information to travel along fewer edges. The difference between dilated and\nHidden Layer Dilation = 4\nHidden Layer Dilation = 2\nHidden Layer Dilation = 1\nInput\nOutput\nFigure 2: (left) An example of a three-layer DILATEDRNN with dilation 1, 2, and 4. (right) An example of a two-layer DILATEDRNN, with dilation 2 in the first layer. In such a case, extra embedding connections are required (red arrows) to compensate missing data dependencies.\nregular skip connection is that the dependency on c(l)t\u22121 is removed in dilated skip connection. The left and middle graphs in figure 1 illustrate the differences between two architectures with dilation or skip length s(l) = 4, where W \u2032r is removed in the middle graph. This reduces the number of parameters.\nMore importantly, computational efficiency of a parallel implementation (e.g., using GPUs) can be greatly improved by parallelizing operations that, in a regular RNN, would be impossible. The middle and right graphs in figure 1 illustrate the idea with s(l) = 4 as an example. The input subsequences {x(l)4t }, {x (l) 4t+1}, {x (l) 4t+2} and {x (l) 4t+3} are given four different colors. The four cell chains, {c (l) 4t }, {c(l)4t+1}, {c (l) 4t+2} and {c (l) 4t+3}, can be computed in parallel by feeding the four subsequences into a regular RNN, as shown in the right of figure 1. The output can then be obtained by interweaving among the four output chains. The degree of parallelization is increased by s(l) times."
        },
        {
            "heading": "2.2 Exponentially Increasing Dilation",
            "text": "To extract complex data dependencies, we stack dilated recurrent layers to construct DILATEDRNN. Similar to settings that were introduced in WaveNet [22], the dilation increases exponentially across layers. Denote s(l) as the dilation of the l-th layer. Then,\ns(l) = M l\u22121, l = 1, \u00b7 \u00b7 \u00b7 , L. (3)\nThe left side of figure 2 depicts an example of DILATEDRNN with L = 3 and M = 2. On one hand, stacking multiple dilated recurrent layers increases the model capacity. On the other hand, exponentially increasing dilation brings two benefits. First, it makes different layers focus on different temporal resolutions. Second, it reduces the average length of paths between nodes at different timestamps, which improves the ability of RNNs to extract long-term dependencies and prevents vanishing and exploding gradients. A formal proof of this statement will be given in section 3.\nTo improve overall computational efficiency, a generalization of our standard DILATEDRNN is also proposed. The dilation in the generalized DILATEDRNN does not start at one, but M l0 . Formally,\ns(l) = M (l\u22121+l0), l = 1, \u00b7 \u00b7 \u00b7 , L and l0 \u2265 0, (4)\nwhere M l0 is called the starting dilation. To compensate for the missing dependencies shorter than M l0 , a 1-by-M (l0) convolutional layer is appended as the final layer. The right side of figure 2 illustrates an example of l0 = 1, i.e. dilations start at two. Without the red edges, there would be no edges connecting nodes at odd and even time stamps. As discussed in section 2.1, the computational efficiency can be increased by M l0 by breaking the input sequence into M l0 downsampled subsequences, and feeding each into a L\u2212 l0-layer regular DILATEDRNN with shared weights."
        },
        {
            "heading": "3 The Memory Capacity of DILATEDRNN",
            "text": "In this section, we extend the analysis framework in [30] to establish better measures of memory capacity and parameter efficiency, which will be discussed in the following two sections respectively."
        },
        {
            "heading": "3.1 Memory Capacity",
            "text": "To facilitate theoretical analysis, we apply the cyclic graph Gc notation introduced in [30]. Definition 3.1 (Cyclic Graph). The cyclic graph representation of an RNN structure is a directed multi-graph, GC = (VC , EC). Each edge is labeled as e = (u, v, \u03c3) \u2208 EC , where u is the origin\nnode, v is the destination node, and \u03c3 is the number of time steps the edge travels. Each node is labeled as v = (i, p) \u2208 VC , where i is the time index of the node modulo m, m is the period of the graph, and p is the node index. GC must contain at least one directed cycle. Along the edges of any directed cycle, the summation of \u03c3 must not be zero.\nDefine di(n) as the length of the shortest path from any input node at time i to any output node at time i + n. In [30], a measure of the memory capacity is proposed that essentially only looks at di(m), where m is the period of the graph. This is reasonable when the period is small. However, when the period is large, the entire distribution of di(n),\u2200n \u2264 m makes a difference, not just the one at span m. As a concrete example, suppose there is an RNN architecture of period m = 10, 000, implemented using equation (2) with skip length s(l) = m, so that di(n) = n for n = 1, \u00b7 \u00b7 \u00b7 , 9, 999 and di(m) = 1. This network rapidly memorizes the dependence on inputs at time i of the outputs at time i + m = i + 10, 000, but shorter dependencies 2 \u2264 n \u2264 9, 999 are much harder to learn. Motivated by this, we proposed the following additional measure of memory capacity. Definition 3.2 (Mean Recurrent Length). For an RNN with cycle m, the mean recurrent length is\nd\u0304 = 1\nm m\u2211 n=1 max i\u2208V di(n). (5)\nMean recurrent length studies the average dilation across different time spans within a cycle. An architecture with good memory capacity should generally have a small recurrent length for all time spans. Otherwise the network can only selectively memorize information at a few time spans. Also, we take the maximum over i, so as to punish networks that have good length only for a few starting times, which can only well memorize information originating from those specific times. The proposed mean recurrent length has an interesting reciprocal relation with the short-term memory (STM) measure proposed in [11], but mean recurrent length emphasizes more on long-term memory capacity, which is more suitable for our intended applications.\nWith this, we are ready to illustrate the memory advantage of DILATEDRNN . Consider two RNN architectures. One is the proposed DILATEDRNN structure with d layers and M = 2 (equation (1)). The other is a regular d-layer RNN with skip connections (equation (2)). If the skip connections are of skip s(l) = 2l\u22121, then connections in the RNN are a strict superset of those in the DILATEDRNN , and the RNN accomplishes exactly the same d\u0304 as the DILATEDRNN , but with twice the number of trainable parameters (see section 3.2). Suppose one were to give every layer in the RNN the largest possible skip for any graph with a period of m = 2d\u22121: set s(l) = 2d\u22121 in every layer, which is the regular skip RNN setting. This apparent advantage turns out to be a disadvantage, because time spans of 2 \u2264 n < m suffer from increased path lengths, and therefore\nd\u0304 = (m\u2212 1)/2 + log2m+ 1/m+ 1, (6) which grows linearly with m. On the other hand, for the proposed DILATEDRNN,\nd\u0304 = (3m\u2212 1)/2m log2m+ 1/m+ 1, (7) where d\u0304 only grows logarithmically with m, which is much smaller than that of regular skip RNN. It implies that the information in the past on average travels along much fewer edges, and thus undergoes far less attenuation. The derivation is given in appendix A in the supplementary materials."
        },
        {
            "heading": "3.2 Parameter Efficiency",
            "text": "The advantage of DILATEDRNN lies not only in the memory capacity but also the number of parameters that achieves such memory capacity. To quantify the analysis, the following measure is introduced. Definition 3.3 (Number of Recurrent Edges per Node). Denote Card{\u00b7} as the set cardinality. For an RNN represented as GC = (VC , EC), the number of recurrent edges per node, Nr, is defined as\nNr = Card {e = (u, v, \u03c3) \u2208 EC : \u03c3 6= 0} / Card{VC}. (8)\nIdeally, we would want a network that has large recurrent skips while maintaining a small number of recurrent weights. It is easy to show that Nr for DILATEDRNN is 1 and that for RNNs with regular skip connections is 2. The DILATEDRNN has half the recurrent complexity as the RNN with regular skip RNN because of the removal of the direct recurrent edge. The following theorem states that the DILATEDRNN is able to achieve the best memory capacity among a class of connection structures with Nr = 1, and thus is among the most parameter efficient RNN architectures.\nTheorem 3.1 (Parameter Efficiency of DILATEDRNN). Consider a subset of d-layer RNNs with period m = Md\u22121 that consists purely of dilated skip connections (hence Nr = 1). For the RNNs in this subset, there are d different dilations, 1 = s1 \u2264 s2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 sd = m, and\nsi = nisi\u22121, (9)\nwhere ni is any arbitrary positive integer. Among this subset, the d-layer DILATEDRNN with dilation rate {M0, \u00b7 \u00b7 \u00b7 ,Md\u22121} achieves the smallest d\u0304.\nThe proof is motivated by [4], and is given in appendix B."
        },
        {
            "heading": "3.3 Comparing with Dilated CNN",
            "text": "Since DILATEDRNN is motivated by dilated CNN [22, 28], it is useful to compare their memory capacities. Although cyclic graph, mean recurrent length and number of recurrent edges per node are designed for recurrent structures, they happen to be applicable to dilated CNN as well. What\u2019s more, it can be easily shown that, compared to a DILATEDRNN with the same number of layers and dilation rate of each layer, a dilated CNN has exactly the same number of recurrent edges per node, and a slightly smaller (by log2m) mean recurrent length. Hence both architectures have the same model complexity, and it looks like a dilated CNN has a slightly better memory capacity.\nHowever, mean recurrent length only measures the memory capacity within a cycle. When going beyond a cycle, it is already shown that the recurrent length grows linearly with the number of cycles [30] for RNN structures, including DILATEDRNN, whereas for a dilated CNN, the receptive field size is always finite (thus mean recurrent length goes to infinity beyond the receptive field size). For example, with dilation rate M = 2l\u22121 and d layers l = 1, \u00b7 \u00b7 \u00b7 , d, a dilated CNN has a receptive field size of 2d, which is two cycles. On the other hand, the memory of a DILATEDRNN can go far beyond two cycles, particularly with the sophisticated units like GRU and LSTM. Hence the memory capacity advantage of DILATEDRNN over a dilated CNN is obvious."
        },
        {
            "heading": "3.4 Comparing with Clockwork RNN",
            "text": "Clockwork RNN [12] also utilizes the exponentially decreasing temporal resolutions to strengthen its memory capacity, but in a different way. Clockwork RNN controls the update rate of each hidden node, whereas DILATEDRNN updates all the nodes at each time step, but controls the data dependency. As a result, the memory capacity of the Clockwork RNN is undesirably time-dependent \u2013 at some output times, e.g. exponentials of 2, the output node has short shortest paths connecting to the input nodes in the past, matching the case of DILATEDRNN; at other times, the recurrent paths can be much longer. Since mean recurrent length penalizes such time-variant memory capacity by taking the worst case over the absolute times, a DILATEDRNN has a much better mean recurrent length than a Clockwork RNN with number of groups matching the number of layers in the DILATEDRNN."
        },
        {
            "heading": "4 Experiments",
            "text": "In this section, we evaluate the performance of DILATEDRNN on four different tasks, which include long-term memorization, pixel-by-pixel MNIST classification [15], character-level language modeling on the Penn Treebank [16], and speaker identification with raw waveforms on VCTK [26]. We also investigate the effect of dilation on performance and computational efficiency.\nUnless specified otherwise, all the models are implemented with Tensorflow [1]. We use the default nonlinearities and RMSProp optimizer [21] with learning rate 0.001 and decay rate of 0.9. All weight matrices are initialized by the standard normal distribution. The batch size is set to 128. Furthermore, in all the experiments, we apply the sequence classification setting [25], where the output layer only adds at the end of the sequence. Results are reported for trained models that achieve the best validation loss. Unless stated otherwise, no tricks, such as gradient clipping [18], learning rate annealing, recurrent weight dropout [20], recurrent batch norm [20], layer norm [3], etc., are applied. All the tasks are sequence level classification tasks, and therefore the \u201cgridding\u201d problem [29] is irrelevant. No \u201cdegridded\u201d module is needed.\nThree RNN cells, Vanilla, LSTM and GRU cells, are combined with the DILATEDRNN , which we refer to as dilated Vanilla, dilated LSTM and dilated GRU, respectively. The common baselines\ninclude single-layer RNNs (denoted as Vanilla RNN, LSTM, and GRU), multi-layer RNNs (denoted as stack Vanilla, stack LSTM, and stack GRU), and Vanilla RNN with regular skip connections (denoted as Skip Vanilla). Additional baselines will be specified in the corresponding subsections."
        },
        {
            "heading": "4.1 Copy memory problem",
            "text": "This task tests the ability of recurrent models in memorizing long-term information. We follow a similar setup in [2, 24, 10]. Each input sequence is of length T + 20. The first ten values are randomly generated from integers 0 to 7; the next T \u2212 1 values are all 8; the last 11 values are all 9, where the first 9 signals that the model needs to start to output the first 10 values of the inputs. Different from the settings in [2, 24], the average cross-entropy loss is only measured at the last 10 timestamps. Therefore, the random guess yields an expected average cross entropy of ln(8) \u2248 2.079. The DILATEDRNN uses 9 layers with hidden state size of 10. The dilation starts from one to 256 at the last hidden layer. The single-layer baselines have 256 hidden units. The multi-layer baselines use the same number of layers and hidden state size as the DILATEDRNN . The skip Vanilla has 9 layers, and the skip length at each layer is 256, which matches the maximum dilation of the DILATEDRNN.\nThe convergence curves in two settings, T = 500 and 1, 000, are shown in figure 3. In both settings, the DILATEDRNN with vanilla cells converges to a good optimum after about 1,000 training iterations, whereas dilated LSTM and GRU converge slower. It might be because the LSTM and GRU cells are much more complex than the vanilla unit. Except for the proposed models, all the other models are unable to do better than the random guess, including the skip Vanilla. These results suggest that the proposed structure as a simple renovation is very useful for problems requiring very long memory."
        },
        {
            "heading": "4.2 Pixel-by-pixel MNIST",
            "text": "Sequential classification on the MNIST digits [15] is commonly used to test the performance of RNNs. We first implement two settings. In the first setting, called the unpermuted setting, we follow the same setups in [2, 13, 14, 24, 30] by serializing each image into a 784 x 1 sequence. The second setting, called permuted setting, rearranges the input sequence with a fixed permutations. Training, validation and testing sets are the default ones in Tensorflow. Hyperparameters and results are reported in table 1. In addition to the baselines already described, we also implement the dilated CNN. However, the receptive fields size of a nine-layer dilated CNN is 512, and is insufficient to cover the sequence length of 784. Therefore, we added one more layer to the dilated CNN, which enlarges its receptive field size to 1,024. It also forms a slight advantage of dilated CNN over the DILATEDRNN structures.\nIn the unpermuted setting, the dilated GRU achieves the best evaluation accuracy of 99.2. However, the performance improvements of dilated GRU and LSTM over both the single- and multi-layer ones are marginal, which might be because the task is too simple. Further, we observe significant performance differences between stack Vanilla and skip vanilla, which is consistent with the findings in [30] that RNNs can better model long-term dependencies and achieves good results when recurrent skip connections added. Nevertheless, the dilated vanilla has yet another significant performance gain over the skip Vanilla, which is consistent with our argument in section 3, that the DILATEDRNN has a much more balanced memory over a wide range of time periods than RNNs with the regular skips. The performance of the dilated CNN is dominated by dilated LSTM and GRU, even when the latter have fewer parameters (in the 20 hidden units case) than the former (in the 50 hidden units case).\nIn the permuted setting, almost all performances are lower. However, the DILATEDRNN models maintain very high evaluation accuracies. In particular, dilated Vanilla outperforms the previous RNN-based state-of-the-art Zoneout [13] with a comparable number of parameters. It achieves test accuracy of 96.1 with only 44k parameters. Note that the previous state-of-the-art utilizes the recurrent batch normalization. The version without it has a much lower performance compared to all the dilated models. We believe the consistently high performance of the DILATEDRNN across different permutations is due to its hierarchical multi-resolution dilations. In addition, the dilated CNN is able the achieve the best performance, which is in accordance with our claim in section 3.3 that dilated CNN has a slightly shorter mean recurrent length than DILATEDRNN architectures, when sequence length fall within its receptive field size. However, note that this is achieved by adding one additional layer to expand its receptive field size compared to the RNN counterparts. When the useful information lies outside its receptive field, the dilated CNN might fail completely.\nIn addition to these two settings, we propose a more challenging task called the noisy MNIST, where we pad the unpermuted pixel sequences with [0, 1] uniform random noise to the length of T . The results with two setups T = 1, 000 and T = 2, 000 are shown in figure 4. The dilated recurrent models and skip RNN have 9 layers and 20 hidden units per layer. The number of skips at each layer of skip RNN is 256. The dilated CNN has 10 layers and 11 layers for T = 1, 000 and T = 2, 000, respectively. This expands the receptive field size of the dilated CNN to the entire input sequence. The number of filters per layer is 20. It is worth mentioning that, in the case of T = 2, 000, if we use a 10-layer dilated CNN instead, it will only produce random guesses. This is because the output node only sees the last 1, 024 input samples which do not contain any informative data. All the other reported models have the same hyperparameters as shown in the first three row of table 1. We found that none of the models without skip connections is able to learn. Although skip Vanilla remains learning, its performance drops compared to the first unpermuted setup. On the contrary, the DILATEDRNN and dilated CNN models obtain almost the same performances as before. It is also worth mentioning that in all three experiments, the DILATEDRNN models are able to achieve comparable results with an extremely small number of parameters.\n2with recurrent batch norm [20]."
        },
        {
            "heading": "4.3 Language modeling",
            "text": "We further investigate the task of predicting the next character on the Penn Treebank dataset [16]. We follow the data splitting rule with the sequence length of 100 that are commonly used in previous studies. This corpus contains 1 million words, which is small and prone to over-fitting. Therefore model regularization methods have been shown effective on the validation and test set performances. Unlike many existing approaches, we apply no regularization other than a dropout on the input layer. Instead, we focus on investigating the regularization effect of the dilated structure itself. Results are shown in table 2. Although Zoneout, LayerNorm HM-LSTM and HyperNetowrks outperform the DILATEDRNN models, they apply batch or layer normalizations as regularization. To the best of our knowledge, the dilated GRU with 1.27 BPC achieves the best result among models of similar sizes without layer normalizations. Also, the dilated models outperform their regular counterparts, Vanilla (didn\u2019t converge, omitted), LSTM and GRU, without increasing the model complexity."
        },
        {
            "heading": "4.4 Speaker identification from raw waveform",
            "text": "We also perform the speaker identification task using the corpus from VCTK [26]. Learning audio models directly from the raw waveform poses a difficult challenge for recurrent models because of the vastly long-term dependency. Recently the CLDNN family of models [19] managed to match or surpass the log mel-frequency features in several speech problems using waveform. However, CLDNNs coarsen the temporal granularity by pooling the first-layer CNN output before feeding it into the subsequent RNN layers, so as to solve the memory challenge. Instead, the DILATEDRNN directly works on the raw waveform without pooling, which is considered more difficult.\nTo achieve a feasible training time, we adopt the efficient generalization of the DILATEDRNN as proposed in equation (4) with l0 = 3 and l0 = 5 . As mentioned before, if the dilations do not start at one, the model is equivalent to multiple shared-weight networks, each working on partial inputs, and the predictions are made by fusing the information using a 1-by-M l0 convolutional layer. Our baseline GRU model follows the same setting with various resolutions (referred to as fused-GRU), with dilation starting at 8. This baseline has 8 share-weight GRU networks, and each subnetwork works on 1/8 of the subsampled sequences. The same fusion layer is used to obtain the final prediction. Since most other regular baselines failed to converge, we also implemented the MFCC-based models on the same task setting for reference. The 13-dimensional log-mel frequency features are computed with 25ms window and 5ms shift. The inputs of MFCC models are of length 100 to match the input duration in the waveform-based models. The MFCC feature has two natural advantages: 1) no information loss from operating on subsequences; 2) shorter sequence length. Nevertheless, our dilated models operating directly on the waveform still offer a competitive performance (Table 3).\n3with layer normalization [3]."
        },
        {
            "heading": "4.5 Discussion",
            "text": "In this subsection, we first investigate the relationship between performance and the number of dilations. We compare the DILATEDRNN models with different numbers of layers on the noisy MNIST T = 1, 000 task. All models use vanilla RNN cells with hidden state size 20. The number of dilations starts at one. In figure 5, we observe that the classification accuracy and rate of convergence increases as the models become deeper. Recall the maximum skip is exponential in the number of layers. Thus, the deeper model has a larger maximum skip and mean recurrent length.\nSecond, we consider maintaining a large maximum skip with a smaller number of layers, by increasing the dilation at the bottom layer of DILATEDRNN . First, we construct a nine-layer DILATEDRNN model with vanilla RNN cells. The number of dilations starts at 1, and hidden state size is 20. This architecture is referred to as \u201cstarts at 1\u201d in figure 6. Then, we remove the bottom hidden layers one-by-one to construct seven new models. The last created model has three layers, and the number of dilations starts at 64. Figure 6 demonstrates both the wall time and evaluation accuracy for 50,000 training iterations of noisy MNIST dataset. The training time reduces by roughly 50% for every dropped layer (for every doubling of the minimum dilation). Although the testing performance decreases when the dilation does not start at one, the effect is marginal with s(0) = 2, and small with 4 \u2264 s(0) \u2264 16. Notably, the model with dilation starting at 64 is able to train within 17 minutes by using a single Nvidia P-100 GPU while maintaining a 93.5% test accuracy."
        },
        {
            "heading": "5 Conclusion",
            "text": "Our experiments with DILATEDRNN provide strong evidence that this simple multi-timescale architectural choice can reliably improve the ability of recurrent models to learn long-term dependency in problems from different domains. We found that the DILATEDRNN trains faster, requires less hyperparameter tuning, and needs fewer parameters to achieve the state-of-the-arts. In complement to the experimental results, we have provided a theoretical analysis showing the advantages of DILATEDRNN and proved its optimality under a meaningful architectural measure of RNNs."
        },
        {
            "heading": "Acknowledgement",
            "text": "Authors would like to thank Tom Le Paine (paine1@illinois.edu) and Ryan Musa (ramusa@us.ibm.com) for their insightful discussions."
        },
        {
            "heading": "A Mean Recurrent Length",
            "text": "This appendix gives the detailed derivation of the conclusions in section 3.1. Consider two RNN architectures. One is the proposed DILATEDRNN structure with d layers. The other is a regular d-layer RNN with skip edges of length 2d\u22121 (hance m = 2d\u22121), as shown in figure 1. For the regular skip RNN, it is obvious that di(n) grows linearly within a cycle.\ndi(n) = { n+ d if n < m 1 + d if n = m ,\nand therefore\nd\u0304 = 1 m ( m(m\u2212 1) 2 + 1) + d = m\u2212 1 2 + log2m+ 1 m + 1,\nwhich grows linearly with m. On the other hand, for the proposed DILATEDRNN structure, we have the following conclusion.\nTheorem A.1. For the DILATEDRNN with d layers.\ndi(n) = d\u22121\u2211 j=0 bj + d,\u2200n \u2264 m, (10)\nwhere b0, \u00b7 \u00b7 \u00b7 , bj\u0304 are digits of the binary representation of n, and j\u0304 is the index of the highest binary bit. Thus\nd\u0304 = 3m\u2212 1\n2m log2m+\n1 m + 1. (11)\nProof. For any path that travels from input to output through n time steps consists of edges that travel through time and those that travel through layers. Therefore\ndi(n) = ri(n) + d, (12)\nwhere ri(n) is the minimum aggregate length of the edges that travel through time. d is the minimum aggregate length of the edges that travel through layers, which is fixed. The problem of finding di(n) is reduced to finding ri(n), which can then be reformulated as the change-making problem: Given a set of banknotes valued {20, 21, \u00b7 \u00b7 \u00b7 2d\u22121} and an amount n. Denote the number of each banknote {a1, \u00b7, ad make the amount, such that the total number of banknotes used is minimized. Formally\nmin {ai} d\u2211 j=1 aj , s.t. d\u2211 i=j aj2 j\u22121 = n. (13)\nSince dilations si\u2019s are multiples of each other, the simple greedy algorithm suffices to find out the shortest path spanning n time steps. That is, first use the largest skip edge, sd, bn/sdc times, and then use the rest of the dilations to fit the residuals. This process is analogous to converting n into its binary representation. Hence the optimal solution to equation (13), {a\u2217i } is given by\na\u2217i = bi. (14)\nFor n traversing 1 through m, each a\u2217i will be 1 50% of the time, except for a \u2217 d\u22121, which equals one only once. Therefore\nd\u0304 = 1 m ( m\u2212 1 2 (d\u2212 1) + 1) + d = 3m\u2212 1 2m log2m+ 1 m + 1. (15)"
        },
        {
            "heading": "B Optimality of the Proposed Skip Distribution",
            "text": "This appendix provides the proof to theorem 3.1. By analogy to the change-making problem, this theorem can be reformulated as the optimal denomination problem, which involves finding the a set of banknote denominations 1 = s1 \u2264 s2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 sL = m such that the average number of banknotes for making the change of values ranging from 1 to m, i.e. d\u0304, is minimized.\nThe optimal denomination problem remains to be an open problem in mathematics, but solutions are readily available when the candidate denominations are confined to those satisfying equation (9), as shown in [4]. The proof here is adapted from that in [4].\nProof to theorem 3.1:\nProof. First, it is easy to show that the RNN architecture that minimizes d\u0304 must have the same dilation rate within the same layer, because 1) it has all the paths that consist of all the combinations of recurrent edges with different dilations, where the optimal shortest paths must lie; 2) in such architectures di(n) does not depend on i, so that the maximum over i in equation (5) does not have an effect.\nNow that we have confined the candidate set, the problem is reduced to finding a set of 1 = s1 \u2264 s2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 sL = m such that d\u0304 is minimized. We can apply equation (12),\nri(n) = argmin {ai} d\u2211 j=1 ai, s.t. \u2211 j ajsj = n. (16)\nDefine\nr\u0304 = 1\nm m\u2211 n=1 max i ri(n), (17)\nas the average number of recurrent edge usage. Hence minimizing d\u0304 is further reduced to minimizing r\u0304. Since dilations si\u2019s are multiples of each other, the simple greedy algorithm suffices to find out the shortest path spanning n time steps. That is, first use the largest skip edge, sd, bn/sdc times, and then use the rest of the skip lengths to fit the residuals. Therefore, to fit all the time spans ranging from 0 to m \u2212 1, the histogram of uses of recurrent edge of length si < m per time span is distributed uniformly across 0 through si+1/si time. Formally, the total uses of recurrent skips of length si < m is m\n2 ( si+1 si \u2212 1). (18)\nTo fit the time span m, only the edge sd = m will be used once. Hence\nr\u0304 = 1\n2 ( d\u22121\u2211 i=1 si+1 si \u2212 d+ 1). (19)\nSince the arithmetic mean is alway greater than or equal to the geometric mean d\u22121\u2211 i=1 si+1 si \u2265 d\u22121 \u221a m = M, (20)\nwith equality if and only if si+1 si = M,\u2200i. (21)"
        }
    ],
    "title": "Dilated Recurrent Neural Networks",
    "year": 2017
}