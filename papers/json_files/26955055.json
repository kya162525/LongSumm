{
    "abstractText": "In lifelong learning, the learner is presented with a sequence of tasks, incrementally building a data-driven prior which may be leveraged to speed up learning of a new task. In this work, we investigate the efficiency of current lifelong approaches, in terms of sample complexity, computational and memory cost. Towards this end, we first introduce a new and a more realistic evaluation protocol, whereby learners observe each example only once and hyper-parameter selection is done on a small and disjoint set of tasks, which is not used for the actual learning experience and evaluation. Second, we introduce a new metric measuring how quickly a learner acquires a new skill. Third, we propose an improved version of GEM (Lopez-Paz & Ranzato, 2017), dubbed Averaged GEM (A-GEM), which enjoys the same or even better performance as GEM, while being almost as computationally and memory efficient as EWC (Kirkpatrick et al., 2016) and other regularizationbased methods. Finally, we show that all algorithms including A-GEM can learn even more quickly if they are provided with task descriptors specifying the classification tasks under consideration. Our experiments on several standard lifelong learning benchmarks demonstrate that A-GEM has the best trade-off between accuracy and efficiency.1",
    "authors": [
        {
            "affiliations": [],
            "name": "Arslan Chaudhry"
        },
        {
            "affiliations": [],
            "name": "Marc\u2019Aurelio Ranzato"
        },
        {
            "affiliations": [],
            "name": "Marcus Rohrbach"
        },
        {
            "affiliations": [],
            "name": "Mohamed Elhoseiny"
        }
    ],
    "id": "SP:96110ffab7461e5ec61f43b2cb09da3cc2b42b47",
    "references": [
        {
            "authors": [
                "Rahaf Aljundi",
                "Punarjay Chakravarty",
                "Tinne Tuytelaars"
            ],
            "title": "Expert gate: Lifelong learning with a network of experts",
            "venue": "In CVPR,",
            "year": 2017
        },
        {
            "authors": [
                "Rahaf Aljundi",
                "Francesca Babiloni",
                "Mohamed Elhoseiny",
                "Marcus Rohrbach",
                "Tinne Tuytelaars"
            ],
            "title": "Memory aware synapses: Learning what (not) to forget",
            "year": 2018
        },
        {
            "authors": [
                "Marco Baroni",
                "Armand Joulin",
                "Allan Jabri",
                "Germ\u00e0n Kruszewski",
                "Angeliki Lazaridou",
                "Klemen Simonic",
                "Tomas Mikolov"
            ],
            "title": "Commai: Evaluating the first steps towards a useful general ai",
            "venue": "arXiv preprint arXiv:1701.08954,",
            "year": 2017
        },
        {
            "authors": [
                "Michael Chang",
                "Abhishek Gupta",
                "Sergey Levine",
                "Thomas L. Griffiths"
            ],
            "title": "Automatically composing representation transformations as a means for generalization",
            "venue": "In ICML workshop Neural Abstract Machines and Program Induction",
            "year": 2018
        },
        {
            "authors": [
                "Arslan Chaudhry",
                "Puneet K Dokania",
                "Thalaiyasingam Ajanthan",
                "Philip HS Torr"
            ],
            "title": "Riemannian walk for incremental learning: Understanding forgetting and intransigence",
            "year": 2018
        },
        {
            "authors": [
                "Mohamed Elhoseiny",
                "Ahmed Elgammal",
                "Babak Saleh"
            ],
            "title": "Write a classifier: Predicting visual classifiers from unstructured text",
            "venue": "IEEE TPAMI,",
            "year": 2017
        },
        {
            "authors": [
                "Chrisantha Fernando",
                "Dylan Banarse",
                "Charles Blundell",
                "Yori Zwols",
                "David Ha",
                "Andrei A Rusu",
                "Alexander Pritzel",
                "Daan Wierstra"
            ],
            "title": "Pathnet: Evolution channels gradient descent in super neural networks",
            "venue": "arXiv preprint arXiv:1701.08734,",
            "year": 2017
        },
        {
            "authors": [
                "Leslie P. Kaelbling Ferran Alet",
                "Tomas Lozano-Perez"
            ],
            "title": "Modular meta-learning",
            "venue": "arXiv preprint arXiv:1806.10166v1,",
            "year": 2018
        },
        {
            "authors": [
                "Kaiming He",
                "Xiangyu Zhang",
                "Shaoqing Ren",
                "Jian Sun"
            ],
            "title": "Deep residual learning for image recognition",
            "venue": "In CVPR,",
            "year": 2016
        },
        {
            "authors": [
                "David Isele",
                "Mohammad Rostami",
                "Eric Eaton"
            ],
            "title": "Using task features for zero-shot knowledge transfer in lifelong learning",
            "venue": "In Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence,",
            "year": 2016
        },
        {
            "authors": [
                "James Kirkpatrick",
                "Razvan Pascanu",
                "Neil C. Rabinowitz",
                "Joel Veness",
                "Guillaume Desjardins",
                "Andrei A. Rusu",
                "Kieran Milan",
                "John Quan",
                "Tiago Ramalho",
                "Agnieszka Grabska-Barwinska",
                "Demis Hassabis",
                "Claudia Clopath",
                "Dharshan Kumaran",
                "Raia Hadsell"
            ],
            "title": "Overcoming catastrophic forgetting in neural networks",
            "venue": "Proceedings of the National Academy of Sciences of the United States of America (PNAS),",
            "year": 2016
        },
        {
            "authors": [
                "Alex Krizhevsky",
                "Geoffrey Hinton"
            ],
            "title": "Learning multiple layers of features from tiny images",
            "venue": "https://www.cs.toronto.edu/ kriz/cifar.html,",
            "year": 2009
        },
        {
            "authors": [
                "Christoph H Lampert",
                "Hannes Nickisch",
                "Stefan Harmeling"
            ],
            "title": "Learning to detect unseen object classes by between-class attribute transfer",
            "venue": "In Computer Vision and Pattern Recognition,",
            "year": 2009
        },
        {
            "authors": [
                "Christoph H Lampert",
                "Hannes Nickisch",
                "Stefan Harmeling"
            ],
            "title": "Attribute-based classification for zero-shot visual object categorization",
            "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,",
            "year": 2014
        },
        {
            "authors": [
                "Yann LeCun"
            ],
            "title": "The mnist database of handwritten digits",
            "venue": "http://yann.lecun.com/exdb/mnist/,",
            "year": 1998
        },
        {
            "authors": [
                "David Lopez-Paz",
                "Marc\u2019Aurelio Ranzato"
            ],
            "title": "Gradient episodic memory for continuum learning",
            "venue": "In NIPS,",
            "year": 2017
        },
        {
            "authors": [
                "Cuong V Nguyen",
                "Yingzhen Li",
                "Thang D Bui",
                "Richard E Turner"
            ],
            "title": "Variational continual learning",
            "year": 2018
        },
        {
            "authors": [
                "S-V. Rebuffi",
                "A. Kolesnikov",
                "C.H. Lampert"
            ],
            "title": "iCaRL: Incremental classifier and representation learning",
            "year": 2017
        },
        {
            "authors": [
                "Mark B Ring"
            ],
            "title": "Child: A first step towards continual learning",
            "venue": "Machine Learning,",
            "year": 1997
        },
        {
            "authors": [
                "Clemens Rosenbaum",
                "Tim Klinger",
                "Matthew Riemer"
            ],
            "title": "Routing networks: Adaptive selection of non-linear functions for multi-task learning",
            "venue": "In International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "T. Schaul",
                "D. Horgan",
                "K. Gregor",
                "D. Silver"
            ],
            "title": "Universal value function approximators",
            "year": 2015
        },
        {
            "authors": [
                "Jonathan Schwarz",
                "Jelena Luketina",
                "Wojciech M. Czarnecki",
                "Agnieszka Grabska-Barwinska",
                "Yee Whye Teh",
                "Razvan Pascanu",
                "Raia Hadsell"
            ],
            "title": "Progress and compress: A scalable framework for continual learning",
            "venue": "In International Conference in Machine Learning,",
            "year": 2018
        },
        {
            "authors": [
                "Hanul Shin",
                "Jung Kwon Lee",
                "Jaehong Kim",
                "Jiwon Kim"
            ],
            "title": "Continual learning with deep generative replay",
            "venue": "In NIPS,",
            "year": 2017
        },
        {
            "authors": [
                "R.S. Sutton",
                "J. Modayil",
                "M. Delp",
                "T. Degris",
                "P.M. Pilarski",
                "A. White",
                "D. Precup"
            ],
            "title": "Horde: A scalable real-time architecture for learning knowledge from unsupervised sensorimotor interaction",
            "venue": "The 10th International Conference on Autonomous Agents and Multiagent Systems,",
            "year": 2011
        },
        {
            "authors": [
                "Sebastian Thrun"
            ],
            "title": "Lifelong learning algorithms",
            "venue": "In Learning to learn,",
            "year": 1998
        },
        {
            "authors": [
                "C. Wah",
                "S. Branson",
                "P. Welinder",
                "P. Perona",
                "S. Belongie"
            ],
            "title": "The caltech-ucsd birds-200-2011 dataset",
            "venue": "Technical Report CNS-TR-2011-001, California Institute of Technology,",
            "year": 2011
        },
        {
            "authors": [
                "Yongqin Xian",
                "Christoph H Lampert",
                "Bernt Schiele",
                "Zeynep Akata"
            ],
            "title": "Zero-shot learning-a comprehensive evaluation of the good, the bad and the ugly",
            "venue": "IEEE transactions on pattern analysis and machine intelligence,",
            "year": 2018
        },
        {
            "authors": [
                "Ju Xu",
                "Zhanxing Zhu"
            ],
            "title": "Reinforced continual learning",
            "venue": "In arXiv preprint arXiv:1805.12369v1,",
            "year": 2018
        },
        {
            "authors": [
                "F. Zenke",
                "B. Poole",
                "S. Ganguli"
            ],
            "title": "Continual learning through synaptic intelligence",
            "venue": "In ICML,",
            "year": 2017
        },
        {
            "authors": [
                "Ji Zhang",
                "Yannis Kalantidis",
                "Marcus Rohrbach",
                "Manohar Paluri",
                "Ahmed Elgammal",
                "Mohamed Elhoseiny"
            ],
            "title": "Large-scale visual relationship understanding",
            "venue": "arXiv preprint arXiv:1804.10660,",
            "year": 2018
        }
    ],
    "sections": [
        {
            "heading": "1 INTRODUCTION",
            "text": "Intelligent systems, whether they are natural or artificial, must be able to quickly adapt to changes in the environment and to quickly learn new skills by leveraging past experiences. While current learning algorithms can achieve excellent performance on a variety of tasks, they strongly rely on copious amounts of supervision in the form of labeled data.\nThe lifelong learning (LLL) setting attempts at addressing this shortcoming, bringing machine learning closer to a more realistic human learning by acquiring new skills quickly with a small amount of training data, given the experience accumulated in the past. In this setting, the learner is presented with a stream of tasks whose relatedness is not known a priori. The learner has then the potential to learn more quickly a new task, if it can remember how to combine and re-use knowledge acquired while learning related tasks of the past. Of course, for this learning setting to be useful, the model needs to be constrained in terms of amount of compute and memory required. Usually this means that the learner should not be allowed to merely store all examples seen in the past (in which case this reduces the lifelong learning problem to a multitask problem) nor should the learner be engaged in computations that would not be feasible in real-time, as the goal is to quickly learn from a stream of data.\nUnfortunately, the established training and evaluation protocol as well as current algorithms for lifelong learning do not satisfy all the above desiderata, namely learning from a stream of data using limited number of samples, limited memory and limited compute. In the most popular training paradigm, the learner does several passes over the data (Kirkpatrick et al., 2016; Aljundi et al., 2018; Rusu et al., 2016; Schwarz et al., 2018), while ideally the model should need only a handful of samples and these should be provided one-by-one in a single pass (Lopez-Paz & Ranzato, 2017). Moreover, when the learner has several hyper-parameters to tune, the current practice is to go over the sequence of tasks several times, each time with a different hyper-parameter value, again ignoring the requirement of learning from a stream of data and, strictly speaking, violating the assumption of\n1The code is available at https://github.com/facebookresearch/agem.\nar X\niv :1\n81 2.\n00 42\n0v 2\n[ cs\n.L G\n] 9\nJ an\n2 01\n9\nthe LLL scenario. While some algorithms may work well in a single-pass setting, they unfortunately require a lot of computation (Lopez-Paz & Ranzato, 2017) or their memory scales with the number of tasks (Rusu et al., 2016), which greatly impedes their actual deployment in practical applications.\nIn this work, we propose an evaluation methodology and an algorithm that better match our desiderata, namely learning efficiently \u2013 in terms of training samples, time and memory \u2013 from a stream of tasks. First, we propose a new learning paradigm, whereby the learner performs cross validation on a set of tasks which is disjoint from the set of tasks actually used for evaluation (Sec. 2). In this setting, the learner will have to learn and will be tested on an entirely new sequence of tasks and it will perform just a single pass over this data stream. Second, we build upon GEM (Lopez-Paz & Ranzato, 2017), an algorithm which leverages a small episodic memory to perform well in a single pass setting, and propose a small change to the loss function which makes GEM orders of magnitude faster at training time while maintaining similar performance; we dub this variant of GEM, A-GEM (Sec. 4). Third, we explore the use of compositional task descriptors in order to improve the fewshot learning performance within LLL showing that with this additional information the learner can pick up new skills more quickly (Sec. 5). Fourth, we introduce a new metric to measure the speed of learning, which is useful to quantify the ability of a learning algorithm to learn a new task (Sec. 3). And finally, using our new learning paradigm and metric, we demonstrate A-GEM on a variety of benchmarks and against several representative baselines (Sec. 6). Our experiments show that AGEM has a better trade-off between average accuracy and computational/memory cost. Moreover, all algorithms improve their ability to quickly learn a new task when provided with compositional task descriptors, and they do so better and better as they progress through the learning experience."
        },
        {
            "heading": "2 LEARNING PROTOCOL",
            "text": "Currently, most works on lifelong learning (Kirkpatrick et al., 2016; Rusu et al., 2016; Shin et al., 2017; Nguyen et al., 2018) adopt a learning protocol which is directly borrowed from supervised learning. There are T tasks, and each task consists of a training, validation and test sets. During training the learner does as many passes over the data of each task as desired. Moreover, hyperparameters are tuned on the validation sets by sweeping over the whole sequence of tasks as many times as required by the cross-validation grid search. Finally, metrics of interest are reported on the test set of each task using the model selected by the previous cross-validation procedure.\nSince the current protocol violates our stricter definition of LLL for which the learner can only make a single pass over the data, as we want to emphasize the importance of learning quickly from data, we now introduce a new learning protocol.\nWe consider two streams of tasks, described by the following ordered sequences of datasetsDCV = {D1, \u00b7 \u00b7 \u00b7 ,DTCV } and DEV = {DTCV +1, \u00b7 \u00b7 \u00b7 ,DT }, where Dk = {(xki , tki , yki ) nk i=1} is the dataset of the k-th task, TCV < T (in all our experiments TCV = 3 while T = 20), and we assume that all datasets are drawn from the same distribution over tasks. To avoid cluttering of the notation, we let the context specify whether Dk refers to the training or test set of the k-th dataset. DCV is the stream of datasets which will be used during cross-validation; DCV allows the learner to replay all samples multiple times for the purposes of model hyper-parameter selection. Instead, DEV is the actual dataset used for final training and evaluation on the test set; the learner will observe training examples from DEV once and only once, and all metrics will be reported on the test sets of DEV . Since the regularization-based approaches for lifelong learning (Kirkpatrick et al., 2016; Zenke et al., 2017) are rather sensitive to the choice of the regularization hyper-parameter, we introduced the set DCV , as it seems reasonable in practical applications to have similar tasks that can be used for tuning the system. However, the actual training and testing are then performed on DEV using a single pass over the data. See Algorithm 1 for a summary of the training and evaluation protocol.\nEach example in any of these dataset consists of a triplet defined by an input (xk \u2208 X ), task descriptor (tk \u2208 T , see Sec. 5 for examples) and a target vector (yk \u2208 yk), where yk is the set of labels specific to task k and yk \u2282 Y . While observing the data, the goal is to learn a predictor f\u03b8 : X \u00d7 T \u2192 Y , parameterized by \u03b8 \u2208 RP (a neural network in our case), that can map any test pair (x, t) to a target y.\nAlgorithm 1 Learning and Evaluation Protocols\n1: for h in hyper-parameter list do . Cross-validation loop, executing multiple passes over DCV 2: for k = 1 to TCV do . Learn over data stream DCV using h 3: for i = 1 to nk do . Single pass over Dk 4: Update f\u03b8 using (xki , t k i , y k i ) and hyper-parameter h 5: Update metrics on test set of DCV 6: end for 7: end for 8: end for 9: Select best hyper-parameter setting, h\u2217, based on average accuracy of test set of DCV , see Eq. 1. 10: Reset f\u03b8 . 11: Reset all metrics. 12: for k = TCV + 1 to T do . Actual learning over datastream DEV 13: for i = 1 to nk do . Single pass over Dk 14: Update f\u03b8 using (xki , t k i , y k i ) and hyper-parameter h \u2217 15: Update metrics on test set of DEV 16: end for 17: end for 18: Report metrics on test set of DEV ."
        },
        {
            "heading": "3 METRICS",
            "text": "Below we describe the metrics used to evaluate the LLL methods studied in this work. In addition to Average Accuracy (A) and Forgetting Measure (F ) (Chaudhry et al., 2018), we define a new measure, the Learning Curve Area (LCA), that captures how quickly a model learns.\nThe training dataset of each task, Dk, consists of a total Bk mini-batches. After each presentation of a mini-batch of task k, we evaluate the performance of the learner on all the tasks using the corresponding test sets. Let ak,i,j \u2208 [0, 1] be the accuracy evaluated on the test set of task j, after the model has been trained with the i-th mini-batch of task k. Assuming the first learning task in the continuum is indexed by 1 (it will be TCV + 1 for DEV ) and the last one by T (it will be TCV for DCV ), we define the following metrics:\nAverage Accuracy (A \u2208 [0, 1]) Average accuracy after the model has been trained continually with all the mini-batches up till task k is defined as:\nAk = 1\nk k\u2211 j=1 ak,Bk,j (1)\nIn particular, AT is the average accuracy on all the tasks after the last task has been learned; this is the most commonly used metric used in LLL.\nForgetting Measure (F \u2208 [\u22121, 1]) (Chaudhry et al., 2018) Average forgetting after the model has been trained continually with all the mini-batches up till task k is defined as:\nFk = 1\nk \u2212 1 k\u22121\u2211 j=1 fkj (2)\nwhere fkj is the forgetting on task \u2018j\u2019 after the model is trained with all the mini-batches up till task k and computed as:\nfkj = max l\u2208{1,\u00b7\u00b7\u00b7 ,k\u22121} al,Bl,j \u2212 ak,Bk,j (3)\nMeasuring forgetting after all tasks have been learned is important for a two-fold reason. It quantifies the accuracy drop on past tasks, and it gives an indirect notion of how quickly a model may learn a new task, since a forgetful model will have little knowledge left to transfer, particularly so if the new task relates more closely to one of the very first tasks encountered during the learning experience.\nLearning Curve Area (LCA \u2208 [0, 1]) Let us first define an average b-shot performance (where b is the mini-batch number) after the model has been trained for all the T tasks as:\nZb = 1\nT T\u2211 k=1 ak,b,k (4)\nLCA at \u03b2 is the area of the convergence curve Zb as a function of b \u2208 [0, \u03b2]:\nLCA\u03b2 = 1\n\u03b2 + 1 \u222b \u03b2 0 Zbdb = 1 \u03b2 + 1 \u03b2\u2211 b=0 Zb (5)\nLCA has an intuitive interpretation. LCA0 is the average 0-shot performance, the same as forward transfer in Lopez-Paz & Ranzato (2017). LCA\u03b2 is the area under the Zb curve, which is high if the 0-shot performance is good and if the learner learns quickly. In particular, there could be two models with the same Z\u03b2 or AT , but very different LCA\u03b2 because one learns much faster than the other while they both eventually obtain the same final accuracy. This metric aims at discriminating between these two cases, and it makes sense for relatively small values of \u03b2 since we are interested in models that learn from few examples."
        },
        {
            "heading": "4 AVERAGED GRADIENT EPISODIC MEMORY (A-GEM)",
            "text": "So far we discussed a better training and evaluation protocol for LLL and a new metric to measure the speed of learning. Next, we review GEM (Lopez-Paz & Ranzato, 2017), which is an algorithm that has been shown to work well in the single epoch setting. Unfortunately, GEM is very intensive in terms of computational and memory cost, which motivates our efficient variant, dubbed A-GEM. In Sec. 5, we will describe how compositional task descriptors can be leveraged to further speed up learning in the few shot regime.\nGEM avoids catastrophic forgetting by storing an episodic memory Mk for each task k. While minimizing the loss on the current task t, GEM treats the losses on the episodic memories of tasks k < t, given by `(f\u03b8,Mk) = 1|Mk| \u2211 (xi,k,yi)\u2208Mk `(f\u03b8(xi, k), yi), as inequality constraints, avoiding their increase but allowing their decrease. This effectively permits GEM to do positive backward transfer which other LLL methods do not support. Formally, at task t, GEM solves for the following objective:\nminimize\u03b8 `(f\u03b8,Dt) s.t. `(f\u03b8,Mk) \u2264 `(f t\u22121\u03b8 ,Mk) \u2200k < t (6)\nWhere f t\u22121\u03b8 is the network trained till task t\u2212 1. To inspect the increase in loss, GEM computes the angle between the loss gradient vectors of previous tasks gk, and the proposed gradient update on the current task g. Whenever the angle is greater than 90\u00b0 with any of the gk\u2019s, it projects the proposed gradient to the closest in L2 norm gradient g\u0303 that keeps the angle within the bounds. Formally, the optimization problem GEM solves is given by:\nminimizeg\u0303 1\n2 ||g \u2212 g\u0303||22 s.t. \u3008g\u0303, gk\u3009 \u2265 0 \u2200k < t (7)\nEq.7 is a quadratic program (QP) in P -variables (the number of parameters in the network), which for neural networks could be in millions. In order to solve this efficiently, GEM works in the dual space which results in a much smaller QP with only t\u2212 1 variables:\nminimizev 1\n2 v>GG>v + g>G>v s.t. v \u2265 0 (8)\nwhere G = \u2212(g1, \u00b7 \u00b7 \u00b7 , gt\u22121) \u2208 R(t\u22121)\u00d7P is computed at each gradient step of training. Once the solution v\u2217 to Eq. 8 is found, the projected gradient update can be computed as g\u0303 = G>v\u2217 + g.\nWhile GEM has proven very effective in a single epoch setting (Lopez-Paz & Ranzato, 2017), the performance gains come at a big computational burden at training time. At each training step, GEM computes the matrix G using all samples from the episodic memory, and it also needs to solve the QP of Eq. 8. Unfortunately, this inner loop optimization becomes prohibitive when the size ofM and the number of tasks is large, see Tab. 7 in Appendix for an empirical analysis. To alleviate\nthe computational burden of GEM, next we propose a much more efficient version of GEM, called Averaged GEM (A-GEM).\nWhereas GEM ensures that at every training step the loss of each individual previous tasks, approximated by the samples in episodic memory, does not increase, A-GEM tries to ensure that at every training step the average episodic memory loss over the previous tasks does not increase. Formally, while learning task t, the objective of A-GEM is:\nminimize\u03b8 `(f\u03b8,Dt) s.t. `(f\u03b8,M) \u2264 `(f t\u22121\u03b8 ,M) whereM = \u222ak<tMk (9)\nThe corresponding optimization problem reduces to:\nminimizeg\u0303 1\n2 ||g \u2212 g\u0303||22 s.t. g\u0303>gref \u2265 0 (10)\nwhere gref is a gradient computed using a batch randomly sampled from the episodic memory, (xref , yref ) \u223c M, of all the past tasks. In other words, A-GEM replaces the t \u2212 1 constraints of GEM with a single constraint, where gref is the average of the gradients from the previous tasks computed from a random subset of the episodic memory.\nThe constrained optimization problem of Eq. 10 can now be solved very quickly; when the gradient g violates the constraint, it is projected via:\ng\u0303 = g \u2212 g >gref\ng>refgref gref (11)\nThe formal proof of the update rule of A-GEM (Eq. 11) is given in Appendix C. This makes A-GEM not only memory efficient, as it does not need to store the matrix G, but also orders of magnitude faster than GEM because 1) it is not required to compute the matrix G but just the gradient of a random subset of memory examples, 2) it does not need to solve any QP but just an inner product, and 3) it will incur in less violations particularly when the number of tasks is large (see Tab. 7 and Fig. 6 in Appendix for empirical evidence). All together these factors make A-GEM faster while not hampering its good performance in the single pass setting.\nIntuitively, the difference between GEM and A-GEM loss functions is that GEM has better guarantess in terms of worst-case forgetting of each individual task since (at least on the memory examples) it prohibits an increase of any task-specific loss, while A-GEM has better guaratees in terms of average accuracy since GEM may prevent a gradient step because of a task constraint violation although the overall average loss may actually decrease, see Appendix Sec. D.1 and D.2 for further analysis and empirical evidence. The pseudo-code of A-GEM is given in Appendix Alg. 2."
        },
        {
            "heading": "5 JOINT EMBEDDING MODEL USING COMPOSITIONAL TASK DESCRIPTORS",
            "text": "In this section, we discuss how we can improve forward transfer for all the LLL methods including A-GEM. In order to speed up learning of a new task, we consider the use of compositional task descriptors where components are shared across tasks and thus allow transfer. Examples of compositional task descriptors are, for instance, a natural language description of the task under consideration or a matrix specifying the attribute values of the objects to be recognized in the task. In our experiments, we use the latter since it is provided with popular benchmark datasets (Wah et al., 2011; Lampert et al., 2009). For instance, if the model has already learned and remembers about two independent properties (e.g., color of feathers and shape of beak), it can quickly recognize a new class provided a descriptor specifying the values of its attributes (yellow feathers and red beak), although this is an entirely unseen combination.\nBorrowing ideas from literature in few-shot learning (Lampert et al., 2014; Zhang et al., 2018; Elhoseiny et al., 2017; Xian et al., 2018), we learn a joint embedding space between image features and the attribute embeddings. Formally, let xk \u2208 X be the input (e.g., an image), tk be the task descriptor in the form of a matrix of size Ck \u00d7 A, where Ck is the number of classes in the kth task and A is the total number of attributes for each class in the dataset. The joint embedding model consists of a feature extraction module, \u03c6\u03b8 : xk \u2192 \u03c6\u03b8(xk), where \u03c6\u03b8(xk) \u2208 RD, and a task embedding module, \u03c8\u03c9 : tk \u2192 \u03c8\u03c9(tk), where\u03c8\u03c9(tk) \u2208 RCk\u00d7D. In this work, \u03c6\u03b8(.) is implemented as a standard multi-layer feed-forward network (see Sec. 6 for the exact parameterization), whereas\n\u03c8\u03c9(.) is implemented as a parameter matrix of dimensions A\u00d7D. This matrix can be interpreted as an attribute look-up table as each attribute is associated with a D dimensional vector, from which a class embedding vector is constructed via a linear combination of the attributes present in the class; the task descriptor embedding is then the concatenation of the embedding vectors of the classes present in the task (see Appendix Fig. 9 for the pictorial description of the joint embedding model). During training, the parameters \u03b8 and \u03c9 are learned by minimizing the cross-entropy loss:\n`k(\u03b8, \u03c9) = 1\nN N\u2211 i=1 \u2212 log(p(yki |xki , tk; \u03b8, \u03c9)) (12)\nwhere (xki , t k, yki ) is the i-th example of task k. If y k i = c, then the distribution p(.) is given by:\np(c|xki , tk; \u03b8, \u03c9) = exp([\u03c6\u03b8(x\nk i )\u03c8\u03c9(t k)>]c)\u2211 j exp([\u03c6\u03b8(x k i )\u03c8\u03c9(t k)>]j) (13)\nwhere [a]i denotes the i-th element of the vector a. Note that the architecture and loss functions are general, and apply not only to A-GEM but also to any other LLL model (e.g., regularization based approaches). See Sec. 6 for the actual choice of parameterization of these functions."
        },
        {
            "heading": "6 EXPERIMENTS",
            "text": "We consider four dataset streams, see Tab.1 in Appendix Sec. A for a summary of the statistics. Permuted MNIST (Kirkpatrick et al., 2016) is a variant of MNIST (LeCun, 1998) dataset of handwritten digits where each task has a certain random permutation of the input pixels which is applied to all the images of that task. Split CIFAR (Zenke et al., 2017) consists of splitting the original CIFAR-100 dataset (Krizhevsky & Hinton, 2009) into 20 disjoint subsets, where each subset is constructed by randomly sampling 5 classes without replacement from a total of 100 classes. Similarly to Split CIFAR, Split CUB is an incremental version of the fine-grained image classification dataset CUB (Wah et al., 2011) of 200 bird categories split into 20 disjoint subsets of classes. Split AWA, on the other hand, is the incremental version of the AWA dataset (Lampert et al., 2009) of 50 animal categories, where each task is constructed by sampling 5 classes with replacement from the total 50 classes, constructing 20 tasks. In this setting, classes may overlap among multiple tasks, but within each task they compete against different set of classes. Note that to make sure each training example is only seen once, the training data of a each class is split into disjoint sets depending on the frequency of its occurrence in different tasks. For Split AWA, the classifier weights of each class are randomly initialized within each head without any transfer from the previous occurrence of the class in past tasks. Finally, while on Permuted MNIST and Split CIFAR we provide integer task descriptors, on Split CUB and Split AWA we stack together the attributes of the classes (specifying for instance the type of beak, the color of feathers, etc.) belonging to the current task to form a descriptor.\nIn terms of architectures, we use a fully-connected network with two hidden layers of 256 ReLU units each for Permuted MNIST, a reduced ResNet18 for Split CIFAR like in Lopez-Paz & Ranzato (2017), and a standard ResNet18 (He et al., 2016) for Split CUB and Split AWA. For a given dataset stream, all models use the same architecture, and all models are optimized via stochastic gradient descent with mini-batch size equal to 10. We refer to the joint-embedding model version of these models by appending the suffix \u2018-JE\u2019 to the method name.\nAs described in Sec. 2 and outlined in Alg. 1, in order to cross validate we use the first 3 tasks, and then report metrics on the remaining 17 tasks after doing a single training pass over each task in sequence.\nLastly, we compared A-GEM against several baselines and state-of-the-art LLL approaches which we describe next. VAN is a single supervised learning model, trained continually without any regularization, with the parameters of a new task initialized from the parameters of the previous task. ICARL (Rebuffi et al., 2017) is a class-incremental learner that uses nearest-exemplar-based classifier and avoids catastrophic forgetting by regularizing over the feature representation of previous tasks using a knowledge distillation loss. EWC (Kirkpatrick et al., 2016), PI (Zenke et al., 2017), RWALK (Chaudhry et al., 2018) and MAS (Aljundi et al., 2018) are regularization-based approaches aiming at avoiding catastrophic forgetting by limiting learning of parameters critical to the performance of past tasks. Progressive Networks (PROG-NN) (Rusu et al., 2016) is a modular approach\nwhereby a new \u201ccolumn\u201d with lateral connections to previous hidden layers is added once a new task arrives. GEM (Lopez-Paz & Ranzato, 2017) described in Sec. 4 is another natural baseline of comparison since A-GEM builds upon it. The amount of episodic memory per task used in ICARL, GEM and A-GEM is set to 250, 65, 50, and 100, and the batch size for the computation of gref (when the episodic memory is sufficiently filled) in A-GEM is set to 256, 1300, 128 and 128 for MNIST, CIFAR, CUB and AWA, respectively. While populating episodic memory, the samples are chosen uniformly at random for each task. Whereas the network weights are randomly initialized for MNIST, CIFAR and AWA, on the other hand, for CUB, due to the small dataset size, a pre-trained ImageNet model is used. Finally, we consider a multi-task baseline, MULTI-TASK, trained on a single pass over shuffled data from all tasks, and thus violating the LLL assumption. It can be seen as an upper bound performance for average accuracy."
        },
        {
            "heading": "6.1 RESULTS",
            "text": "Fig. 1 and 2 show the overall results on all the datasets we considered (for brevity we show only representative methods, see detailed results in Appendix Tab. 4, 5, 6 and 7). First, we observe that A-GEM achieves the best average accuracy on all datasets, except Permuted MNIST, where PROGNN works better. The reason is because on this dataset each task has a large number of training\nexamples, which enables PROG-NN to learn its task specific parameters and to leverage its lateral connections. However, notice how PROG-NN has the worst memory cost by the end of training - as its number of parameters grows super-linearly with the number of tasks. In particular, in large scale setups (Split CUB and AWA), PROG-NN runs out of memory during training due to its large size. Also, PROG-NN does not learn well on datasets where tasks have fewer training examples. Second, A-GEM and GEM perform comparably in terms of average accuracy, but A-GEM has much lower time (about 100 times faster) and memory cost (about 10 times lower), comparable to regularizationbased approaches like EWC. Third, EWC and similar methods perform only slightly better than VAN on this single pass LLL setting. The analysis in Appendix Sec. F demonstrates that EWC requires several epochs and over-parameterized architectures in order to work well. Fourth, PROG-NN has no forgetting by construction and A-GEM and GEM have the lowest forgetting among methods that use a fixed capacity architecture. Next, all methods perform similarly in terms of LCA, with PROGNN being the worst because of its ever growing number of parameters and A-GEM slightly better than all the other approaches. And finally, the use of task descriptors improves average accuracy across the board as shown in Fig.2, with A-GEM a bit better than all the other methods we tried. All joint-embedding models using task descriptors have better LCA performance, although this is the same across all methods including A-GEM. Overall, we conclude that A-GEM offers the best trade-off between average accuracy performance and efficiency in terms of sample, memory and computational cost.\nFig. 3 shows a more fine-grained analysis and comparison with more methods on Permuted MNIST and Split CIFAR. The average accuracy plots show how A-GEM and GEM greatly outperform other approaches, with the exception of PROG-NN on MNIST as discussed above. On different datasets,\ndifferent methods are best in terms of LCA, although A-GEM is always top-performing. Fig. 4 shows in more detail the gain brought by task descriptors which greatly speed up learning in the few-shot regime. On these datasets, A-GEM performs the best or on par to the best.\nFinally, in Fig. 5, we report the 0-shot performance of LLL methods on Split CUB and Split AWA datasets over time, showing a clear advantage of using compositional task descriptors with joint embedding models, which is more significant for A-GEM. Interestingly, the zero-shot learning performance of joint embedding models improves over time, indicating that these models get better at forward transfer or, in other words, become more efficient over time."
        },
        {
            "heading": "7 RELATED WORK",
            "text": "Continual (Ring, 1997) or Lifelong Learning (LLL) (Thrun, 1998) have been the subject of extensive study over the past two decades. One approach to LLL uses modular compositional models (Fernando et al., 2017; Aljundi et al., 2017; Rosenbaum et al., 2018; Chang et al., 2018; Xu & Zhu, 2018; Ferran Alet, 2018), which limit interference among tasks by using different subset of modules for each task. Unfortunately, these methods require searching over the space of architectures which is not sample efficient with current methods. Another approach is to regularize parameters important to solve past tasks (Kirkpatrick et al., 2016; Zenke et al., 2017; Chaudhry et al., 2018), which has been proven effective for over-parameterized models in the multiple epoch setting (see Appendix Sec. F), while we focus on learning from few examples using memory efficient models. Methods based on episodic memory (Rebuffi et al., 2017; Lopez-Paz & Ranzato, 2017) require a little bit more memory at training time but can work much better in the single pass setting we considered (Lopez-Paz & Ranzato, 2017).\nThe use of task descriptors for LLL has already been advocated by Isele et al. (2016) but using a sparse coding framework which is not obviously applicable to deep nets in a computationally efficient way, and also by Lopez-Paz & Ranzato (2017) although they did not explore the use of compositional descriptors. More generally, tasks descriptors have been used in Reinforcement Learning with similar motivations by several others (Sutton et al., 2011; Schaul et al., 2015; Baroni et al., 2017), and it is also a key ingredient in all the zero/few-shot learning algorithms (Lampert et al., 2014; Xian et al., 2018; Elhoseiny et al., 2017; Wah et al., 2011; Lampert et al., 2009)."
        },
        {
            "heading": "8 CONCLUSION",
            "text": "We studied the problem of efficient Lifelong Learning (LLL) in the case where the learner can only do a single pass over the input data stream. We found that our approach, A-GEM, has the best tradeoff between average accuracy by the end of the learning experience and computational/memory cost. Compared to the original GEM algorithm, A-GEM is about 100 times faster and has 10 times less memory requirements; compared to regularization based approaches, it achieves significantly\nhigher average accuracy. We also demonstrated that by using compositional task descriptors all methods can improve their few-shot performance, with A-GEM often being the best.\nOur detailed experiments reported in Appendix E also show that there is still a substantial performance gap between LLL methods, including A-GEM, trained in a sequential learning setting and the same network trained in a non-sequential multi-task setting, despite seeing the same data samples. Moreover, while task descriptors do help in the few-shot learning regime, the LCA performance gap between different methods is very small; suggesting a poor ability of current methods to transfer knowledge even when forgetting has been eliminated. Addressing these two fundamental issues will be the focus of our future research."
        },
        {
            "heading": "A DATASET STATISTICS",
            "text": ""
        },
        {
            "heading": "B A-GEM ALGORITHM",
            "text": "Algorithm 2 Training and evaluation of A-GEM on sequential data D = {D1, \u00b7 \u00b7 \u00b7 ,DT }\n1: procedure TRAIN(f\u03b8,Dtrain,Dtest) 2: M\u2190 {} 3: A\u2190 0 \u2208 RT\u00d7T 4: for t = {1, \u00b7 \u00b7 \u00b7 , T} do 5: for (x, y) \u2208 Dtraint do 6: (xref , yref ) \u223cM 7: gref \u2190 \u2207\u03b8`(f\u03b8(xref , t), yref ) 8: g \u2190 \u2207\u03b8`(f\u03b8(x, t), y) 9: if g>gref \u2265 0 then\n10: g\u0303 \u2190 g 11: else 12: g\u0303 \u2190 g \u2212 g\n>gref g> ref gref gref\n13: end if 14: \u03b8 \u2190 \u03b8 \u2212 \u03b1g\u0303 15: end for 16: M\u2190 UPDATEEPSMEM(M,Dtraint , T ) 17: At,: \u2190 EVAL(f\u03b8,Dtest) 18: end for 19: return f\u03b8, A 20: end procedure\n1: procedure EVAL(f\u03b8,Dtest) 2: a\u2190 0 \u2208 RT 3: for t = {1, \u00b7 \u00b7 \u00b7 , T} do 4: at \u2190 0 5: for (x, y) \u2208 Dtestt do 6: at \u2190 at + ACCURACY(f\u03b8(x, t), y) 7: end for 8: at \u2190 atlen(Dtestt ) 9: end for\n10: return a 11: end procedure\n1: procedure UPDATEEPSMEM(M,Dt, T ) 2: s\u2190 |M| T 3: for i = {1, \u00b7 \u00b7 \u00b7 , s} do 4: (x, y) \u223c Dt 5: M\u2190 (x, y) 6: end for 7: returnM 8: end procedure"
        },
        {
            "heading": "C A-GEM UPDATE RULE",
            "text": "Here we provide the proof of the update rule of A-GEM (Eq. 11), g\u0303 = g \u2212 g >gref\ng>refgref gref , stated in\nSec. 4 of the main paper.\nProof. The optimization objective of A-GEM as described in the Eq. 10 of the main paper, is:\nminimizeg\u0303 1\n2 ||g \u2212 g\u0303||22\ns.t. g\u0303>gref \u2265 0 (14) Replacing g\u0303 with z and rewriting Eq. 14 yields:\nminimizez 1\n2 z>z \u2212 g>z\ns.t. \u2212 z>gref \u2264 0 (15) Note that we discard the term g>g from the objective and change the sign of the inequality constraint. The Lagrangian of the constrained optimization problem defined above can be written as:\nL(z, \u03b1) = 1 2 z>z \u2212 g>z \u2212 \u03b1z>gref (16)\nNow, we pose the dual of Eq. 16 as: \u03b8D(\u03b1) = min\nz L(z, \u03b1) (17)\nLets find the value z\u2217 that minimizes the L(z, \u03b1) by setting the derivatives of L(z, \u03b1) w.r.t. to z to zero:\n\u2207zL(z, \u03b1) = 0 z\u2217 = g + \u03b1gref (18)\nThe simplified dual after putting the value of z\u2217 in Eq. 17 can be written as:\n\u03b8D(\u03b1) = 1\n2 (g>g + 2\u03b1g>gref + \u03b1 2g>refgref )\u2212 g>g \u2212 2\u03b1g>gref \u2212 \u03b12g>refgref\n= \u22121 2 g>g \u2212 \u03b1g>gref \u2212 1 2 \u03b12g>refgref\nThe solution \u03b1\u2217 = max\u03b1;\u03b1>0 \u03b8D(\u03b1) to the dual is given by: \u2207\u03b1\u03b8D(\u03b1) = 0\n\u03b1\u2217 = \u2212 g >gref\ng>refgref\nBy putting \u03b1\u2217 in Eq. 18, we recover the A-GEM update rule:\nz\u2217 = g \u2212 g >gref\ng>refgref gref = g\u0303"
        },
        {
            "heading": "D ANALYSIS OF GEM AND A-GEM",
            "text": "In this section, we empirically analyze the differences between A-GEM and GEM, and report experiments with another computationally efficient but worse performing version of GEM.\nD.1 FREQUENCY OF CONSTRAINT VIOLATIONS\nFig. 6 shows the frequency of constraint violations (see Eq. 8 and 10) on Permuted MNIST and Split CIFAR datasets. Note that, the number of gradient updates (training steps) per task on MNIST and CIFAR are 5500 and 250, respectively. As the number of tasks increase, GEM violates the optimization constraints at almost each training step, whereas A-GEM plateaus to a much lower value. Therefore, the computational efficiency of A-GEM not only stems from the fact that it avoids solving a QP at each training step (which is much more expensive than a simple inner product) but also from the fewer number of constraint violations. From the figure, we can also infer that as the number of tasks grows the gap between GEM and A-GEM would grow further. Thus, the computational and memory overhead of GEM over A-GEM, see also Tab. 7, gets worse as the number of tasks increases.\nD.2 AVERAGE ACCURACY AND WORST-CASE FORGETTING\nIn Tab. 2, we empirically demonstrate the different properties induced by the objective functions of GEM and A-GEM. GEM enjoys lower worst-case task forgetting while A-GEM enjoys better overall average accuracy. This is particularly true on the training examples stored in memory, as on the test set the result is confounded by the generalization error.\nD.3 STOCHASTIC GEM (S-GEM)\nIn this section we report experiments with another variant of GEM, dubbed Stochastic GEM (SGEM). The main idea in S-GEM is to randomly sample one constraint, at each training step, from the possible t\u2212 1 constraints of GEM. If that constraint is violated, the gradient is projected only taking into account that constraint. Formally, the optimization objective of S-GEM is given by:\nminimizeg\u0303 1\n2 ||g \u2212 g\u0303||22\ns.t. \u3008g\u0303, gk\u3009 \u2265 0 where k \u223c {1, \u00b7 \u00b7 \u00b7 , t\u2212 1} (19)\nIn other words, at each training step, S-GEM avoids the increase in loss of one of the previous tasks sampled randomly. In Tab. 3 we report the comparison of GEM, S-GEM and A-GEM on Permuted MNIST and Split CIFAR.\nAlthough, S-GEM is closer in spirit to GEM, as it requires randomly sampling one of the GEM constraints to satisfy, compared to A-GEM, which defines the constraint as the average gradient of the previous tasks, it perform slightly worse than GEM, as can be seen from Tab. 3."
        },
        {
            "heading": "E RESULT TABLES",
            "text": "In Tab. 4, 5, 6 and 7 we report the detailed results which were used to generate Fig.1 and 2."
        },
        {
            "heading": "F ANALYSIS OF EWC",
            "text": "In this section we provide empirical evidence to the conjecture that regularization-based approaches like EWC need over-parameterized architectures and multiple passes over the samples of each task in order to perform well. The intuition as to why models need to be over-parameterized is because it is easier to avoid cross-task interference when the model has additional capacity. In the single-pass setting and when each task does not have very many training samples, regularization-based appraches also suffer because regularization parameters cannot be estimated well from a model that has not fully converged. Moreover, for tasks that do not have much data, rgularization-based approaches do not enable any kind of positive backward transfer (Lopez-Paz & Ranzato, 2017) which further hurts performance as the predictor cannot leverage knowledge acquired later to improve its prediction on past tasks. Finally, regularization-based approaches perform much better in the multi-epoch setting simply because in this setting the baseline un-regularized model performs much worse, as it overfits much more to the data of the current task, every time unlearning what it learned before.\nWe consider Permuted MNIST and Split CIFAR datasets as described in Sec. 6 of the main paper. For MNIST, the two architecture variants that we experiment with are; 1) two-layer fully-connected network with 256 units in each layer (denoted by \u2212S suffix), and 2) two-layer fully-connected network with 2000 units in each layer (denoted by \u2212B suffix). For CIFAR, the two architecture variants are; 1) ResNet-18 with 3 times less feature maps in all the layers (denoted by \u2212S suffix), and 2) Standard ResNet-18 (denoted by \u2212B token). We run the experiments on VAN and EWC with increasing the number of epochs from 1 to 10 for Permuted MNIST and from 1 to 30 for CIFAR. For instance, when epoch is set to 10, it means that the training samples of task t are presented 10 times before showing examples from task t + 1. In Fig. 7 and 8 we plot the Average Accuracy (Eq. 1) and Forgetting (Eq. 2) on Permuted MNIST and Split CIFAR, respectively.\nWe observe that the average accuracy significantly improves with the number of epochs only when EWC is applied to the big network. In particular, in the single epoch setting, EWC peforms similarly to the baseline VAN on Split CIFAR which has fewer number of training examples per task."
        },
        {
            "heading": "G HYPER-PARAMETER SELECTION",
            "text": "Below we report the hyper-parameters grid considered for different experiments. Note, as described in the Sec. 6 of the main paper, to satisfy the requirement that a learner does not see the data of a task more than once, first TCV tasks are used to cross-validate the hyper-parameters. In all the datasets, the value of TCV is set to \u20183\u2019. The best setting for each experiment is reported in the parenthesis.\n\u2022 MULTI-TASK \u2013 learning rate: [0.3, 0.1, 0.03 (MNIST perm, Split CIFAR, Split CUB, Split AWA), 0.01, 0.003, 0.001, 0.0003, 0.0001]\n\u2022 MULTI-TASK-JE \u2013 learning rate: [0.3, 0.1, 0.03 (Split CUB, Split AWA), 0.01, 0.003, 0.001, 0.0003, 0.0001]\n\u2022 VAN \u2013 learning rate: [0.3, 0.1, 0.03 (MNIST perm, Split CUB), 0.01 (Split CIFAR), 0.003, 0.001 (Split AWA), 0.0003, 0.0001] \u2022 VAN-JE\n\u2013 learning rate: [0.3, 0.1, 0.03 (Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2022 PROG-NN \u2013 learning rate: [0.3, 0.1 (MNIST perm, ), 0.03 (Split CIFAR, Split AWA), 0.01 (Split CUB), 0.003, 0.001, 0.0003, 0.0001] \u2022 EWC\n\u2013 learning rate: [0.3, 0.1, 0.03 (MNIST perm, Split CIFAR, Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [1 (Split CUB), 10 (MNIST perm, Split CIFAR), 100 (Split AWA), 1000, 10000]\n\u2022 EWC-JE \u2013 learning rate: [0.3, 0.1, 0.03 (Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [1, 10 (Split CUB), 100 (Split AWA), 1000, 10000] \u2022 PI\n\u2013 learning rate: [0.3, 0.1 (MNIST perm), 0.03 (Split CUB), 0.01 (Split CIFAR), 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [0.001, 0.01, 0.1 (MNIST perm, Split CIFAR, Split CUB), 1 (Split AWA), 10]\n\u2022 PI-JE \u2013 learning rate: [0.3, 0.1, 0.03 (Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [0.001, 0.01, 0.1 (Split CUB), 1, 10 (Split AWA)] \u2022 MAS\n\u2013 learning rate: [0.3, 0.1 (MNIST perm), 0.03 (Split CIFAR, Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [0.01, 0.1 (MNIST perm, Split CIFAR, Split CUB), 1 (Split AWA), 10]\n\u2022 MAS-JE \u2013 learning rate: [0.3, 0.1, 0.03 (Split CUB), 0.01, 0.003, 0.001 (Split AWA), 0.0003, 0.0001]\n\u2013 regularization: [0.01, 0.1 (Split CUB, Split AWA), 1, 10] \u2022 RWALK\n\u2013 learning rate: [0.3, 0.1 (MNIST perm), 0.03 (Split CIFAR, Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [0.1, 1 (MNIST perm, Split CIFAR, Split CUB), 10 (Split AWA), 100, 1000]\n\u2022 RWALK-JE \u2013 learning rate: [0.3, 0.1, 0.03 (SPLIT CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]\n\u2013 regularization: [0.1, 1 (Split CUB), 10 (Split AWA), 100, 1000] \u2022 A-GEM\n\u2013 learning rate: [0.3, 0.1 (MNIST perm), 0.03 (Split CIFAR, Split CUB), 0.01 (Split AWA), 0.003, 0.001, 0.0003, 0.0001]\n\u2022 A-GEM-JE \u2013 learning rate: [0.3, 0.1, 0.03 (SPLIT CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001]"
        },
        {
            "heading": "H PICTORIAL DESCRIPTION OF JOINT EMBEDDING MODEL",
            "text": "In Fig. 9 we provide a pictorial description of the joint embedding model discussed in the Sec. 5 of the main paper."
        }
    ],
    "year": 2019
}