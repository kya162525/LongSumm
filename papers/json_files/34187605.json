{
    "abstractText": "The practical performance of online stochastic gradient descent algorithms is highly dependent on the chosen step size, which must be tediously hand-tuned in many applications. The same is true for more advanced variants of stochastic gradients, such as SAGA, SVRG, or AdaGrad. Here we propose to adapt the step size by performing a gradient descent on the step size itself, viewing the whole performance of the learning trajectory as a function of step size. Importantly, this adaptation can be computed online at little cost, without having to iterate backward passes over the full data. Introduction This work aims at improving gradient ascent procedures for use in machine learning contexts, by adapting the step size of the descent as it goes along. Let l0, l1, . . . , lt, . . . be functions to be maximised over some parameter space \u0398. At each time t, we wish to compute or approximate the parameter \u03b8\u2217 t \u2208 \u0398 that maximizes the sum Lt(\u03b8) := \u2211 s\u2264t ls(\u03b8). (1) In the experiments below, as in many applications, lt(\u03b8) writes l(xt, \u03b8) for some data x0, x1, . . . , xt, . . . A common strategy, especially with large data size or dimensionality [Bot10], is the online stochastic gradient ascent (SG) \u03b8t+1 = \u03b8t + \u03b7 \u2202\u03b8lt(\u03b8t) (2) with step size \u03b7, where \u2202\u03b8lt stands for the Euclidean gradient of lt with respect to \u03b8. Such an approach has become a mainstay of both the optimisation and machine learning communities [Bot10]. Various conditions for convergence exist, starting with the celebrated article of Robbins and Monro [RM51], or later [KC78]. Other types of results are proved in convex settings, Several variants have since been introduced, in part to improve the convergence of the algorithm, which is much slower in stochastic than than in 1 deterministic settings. For instance, algorithms such as SAGA, Stochastic Variance Reduced Gradient (SVRG) or Stochastic Average Gradient (SAG) [DBLJ14, JZ13, SLRB13], perform iterations using a comparison between the latest gradient and an average of past gradients. This reduces the variance of the resulting estimates and allows for nice convergence theorems [DBLJ14, SLRB13], provided a reasonable step size \u03b7 is used. Influence of the step size. The ascent requires a parameter, the step size \u03b7, usually called \u201clearning rate\u201d in the machine learning community. Empirical evidence highligting the sensitivity of the ascent to its actual numerical value exists aplenty; see for instance the graphs in Section 3.2.1. Slow and tedious hand-tuning is therefore mandatory in most applications. Moreover, admittable values of \u03b7 depend on the parameterisation retained\u2014except for descents described in terms of Riemannian metrics [Ama98], which provide some degree of parameterisation-invariance. Automated procedures for setting reasonable value of \u03b7 are therefore of much value. For instance, AdaGrad [DHS11] divides the derivative \u2202\u03b8lt by a root mean square average of the magnitude of its recent values, so that the steps are of size approximately 1; but this still requires a \u201cmaster step size\u201d \u03b7. Shaul, Zhang and LeCun in [SZL13] study a simple separable quadratic loss model and compute the value of \u03b7 which minimises the expected loss after each parameter update. This value can be expressed in terms of computable quantities depending on the trajectory of the descent. These quantities still make sense for non-quadratic models, making this idea amenable to practical use. More recently, Maclaurin, Douglas and Duvenaud [MDA15] propose to directly conduct a gradient ascent on the hyperparameters (such as the learning rate \u03b7) of any algorithm. The gradients with respect to the hyperparameters are computed exactly by \u201cchaining derivatives backwards through the entire training procedure\u201d [MDA15]. Consequently, this approach is extremely impractical in an online setting, as it optimizes the learning rate by performing several passes, each of which goes backwards from time t to time 0. Finding the best step size. The ideal value of the step size \u03b7 would be the one that maximizes the cumulated objective function (1). Write \u03b8t(\u03b7) for the parameter value obtained after t iterations of the gradient step (2) using a given value \u03b7, and consider the sum",
    "authors": [
        {
            "affiliations": [],
            "name": "Pierre-Yves Mass\u00e9"
        },
        {
            "affiliations": [],
            "name": "Yann Ollivier"
        }
    ],
    "id": "SP:768a481a3b3e9c4f593cd6bfe21fcec68940f639",
    "references": [
        {
            "authors": [
                "Shun-ichi Amari"
            ],
            "title": "Natural gradient works efficiently in learning",
            "venue": "Neural Comput.,",
            "year": 1998
        },
        {
            "authors": [
                "L\u00e9on Bottou"
            ],
            "title": "Large-scale machine learning with stochastic gradient descent",
            "venue": "In Proceedings of COMPSTAT\u20192010,",
            "year": 2010
        },
        {
            "authors": [
                "John Duchi",
                "Elad Hazan",
                "Yoram Singer"
            ],
            "title": "Adaptive subgradient methods for online learning and stochastic optimization",
            "venue": "The Journal of Machine Learning Research,",
            "year": 2011
        },
        {
            "authors": [
                "Rie Johnson",
                "Tong Zhang"
            ],
            "title": "Accelerating Stochastic Gradient Descent using Predictive Variance Reduction",
            "venue": "Advances in Neural Information Processing Systems",
            "year": 2013
        },
        {
            "authors": [
                "Harold J. Kushner",
                "Dean S. Clark"
            ],
            "title": "Stochastic Approximation Methods for Constrained and Unconstrained Systems, volume 26 of Applied Mathematical Sciences",
            "year": 1978
        },
        {
            "authors": [
                "Douglas Maclaurin",
                "David Duvenaud",
                "Ryan Adams"
            ],
            "title": "Gradient-based hypermarameter optimization through reversible learning",
            "venue": "Proceedings of The 32nd International Conference on Machine Learning,",
            "year": 2015
        },
        {
            "authors": [
                "Herbert Robbins",
                "Sutton Monro"
            ],
            "title": "A stochastic approximation method",
            "venue": "The Annals of Mathematical Statistics,",
            "year": 1951
        },
        {
            "authors": [
                "Mark Schmidt",
                "Nicolas Le Roux",
                "Francis Bach"
            ],
            "title": "Minimizing finite sums with the stochastic average gradient",
            "venue": "Technical Report 00860051,",
            "year": 2013
        },
        {
            "authors": [
                "Tom Schaul",
                "Sixin Zhang",
                "Yann LeCun"
            ],
            "title": "No More Pesky Learning Rates",
            "venue": "Proceedings of The 30th International Conference on Machine Learning,",
            "year": 2013
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :1\n51 1.\n02 54\n0v 1\n[ m\nat h.\nO C\n] 8\nN ov\n2 01\nIntroduction\nThis work aims at improving gradient ascent procedures for use in machine learning contexts, by adapting the step size of the descent as it goes along.\nLet \u21130, \u21131, . . . , \u2113t, . . . be functions to be maximised over some parameter space \u0398. At each time t, we wish to compute or approximate the parameter \u03b8\u2217t \u2208 \u0398 that maximizes the sum\nLt(\u03b8) := \u2211\ns\u2264t \u2113s(\u03b8). (1)\nIn the experiments below, as in many applications, \u2113t(\u03b8) writes \u2113(xt, \u03b8) for some data x0, x1, . . . , xt, . . .\nA common strategy, especially with large data size or dimensionality [Bot10], is the online stochastic gradient ascent (SG)\n\u03b8t+1 = \u03b8t + \u03b7 \u2202\u03b8\u2113t(\u03b8t) (2)\nwith step size \u03b7, where \u2202\u03b8\u2113t stands for the Euclidean gradient of \u2113t with respect to \u03b8.\nSuch an approach has become a mainstay of both the optimisation and machine learning communities [Bot10]. Various conditions for convergence exist, starting with the celebrated article of Robbins and Monro [RM51], or later [KC78]. Other types of results are proved in convex settings,\nSeveral variants have since been introduced, in part to improve the convergence of the algorithm, which is much slower in stochastic than than in\ndeterministic settings. For instance, algorithms such as SAGA, Stochastic Variance Reduced Gradient (SVRG) or Stochastic Average Gradient (SAG) [DBLJ14, JZ13, SLRB13], perform iterations using a comparison between the latest gradient and an average of past gradients. This reduces the variance of the resulting estimates and allows for nice convergence theorems [DBLJ14, SLRB13], provided a reasonable step size \u03b7 is used.\nInfluence of the step size. The ascent requires a parameter, the step size \u03b7, usually called \u201clearning rate\u201d in the machine learning community. Empirical evidence highligting the sensitivity of the ascent to its actual numerical value exists aplenty; see for instance the graphs in Section 3.2.1. Slow and tedious hand-tuning is therefore mandatory in most applications. Moreover, admittable values of \u03b7 depend on the parameterisation retained\u2014except for descents described in terms of Riemannian metrics [Ama98], which provide some degree of parameterisation-invariance.\nAutomated procedures for setting reasonable value of \u03b7 are therefore of much value. For instance, AdaGrad [DHS11] divides the derivative \u2202\u03b8\u2113t by a root mean square average of the magnitude of its recent values, so that the steps are of size approximately 1; but this still requires a \u201cmaster step size\u201d \u03b7.\nShaul, Zhang and LeCun in [SZL13] study a simple separable quadratic loss model and compute the value of \u03b7 which minimises the expected loss after each parameter update. This value can be expressed in terms of computable quantities depending on the trajectory of the descent. These quantities still make sense for non-quadratic models, making this idea amenable to practical use.\nMore recently, Maclaurin, Douglas and Duvenaud [MDA15] propose to directly conduct a gradient ascent on the hyperparameters (such as the learning rate \u03b7) of any algorithm. The gradients with respect to the hyperparameters are computed exactly by \u201cchaining derivatives backwards through the entire training procedure\u201d [MDA15]. Consequently, this approach is extremely impractical in an online setting, as it optimizes the learning rate by performing several passes, each of which goes backwards from time t to time 0.\nFinding the best step size. The ideal value of the step size \u03b7 would be the one that maximizes the cumulated objective function (1). Write \u03b8t(\u03b7) for the parameter value obtained after t iterations of the gradient step (2) using a given value \u03b7, and consider the sum\n\u2211 s\u2264t \u2113s(\u03b8s(\u03b7)). (3)\nOur goal is to find an online way to approximate the value of \u03b7 that provides the best value of this sum. This can be viewed as an ascent on the space of\nstochastic ascent algorithms. We suggest to update \u03b7 through a stochastic gradient ascent on this sum:\n\u03b7 \u2190 \u03b7 + \u03b1 \u2202 \u2202\u03b7 \u2113t(\u03b8t(\u03b7)) (4)\nand then to use, at each time, the resulting value of \u03b7 for the next gradient step (2).\nThe ascent (4) on \u03b7 depends, in turn, on a step size \u03b1. Hopefully, the dependance on \u03b1 of the whole procedure is somewhat lower than that of the original stochastic gradient scheme on its step size \u03b7.\nThis approach immediately extends to other stochastic gradient algorithms; in what follows we apply it both to the standard SG ascent and to the SVRG algorithm.\nThe main point in this approach is to find efficient ways to compute or approximate the derivatives \u2202\n\u2202\u03b7 \u2113t(\u03b8t(\u03b7)). Indeed, the value \u03b8t(\u03b7) after t steps\ndepends on the whole trajectory of the algorithm, and so does its derivative with respect to \u03b7.\nAfter reviewing the setting for gradient ascents in Section 1, in Section 2.1 we provide an exact but impractical way of computing the derivatives \u2202\n\u2202\u03b7 \u2113t(\u03b8t(\u03b7)). Sections 2.2\u20132.3 contain the main contribution: SG/SG\nand SG/AG, practical algorithms to adjust \u03b7 based on two approximations with respect to these exact derivatives.\nSection 2.4 extends this to other base algorithms such as SVRG. In Section 4 one of the approximations is justified by showing that it computes a derivative, not with respect to a fixed value of \u03b7 as in (4), but with respect to the sequences of values of \u03b7 effectively used along the way. This also suggests improved algorithms.\nSection 3 provides experimental comparisons of gradient ascents using traditional algorithms with various values of \u03b7, and the same algorithms where \u03b7 is self-adjusted according to our scheme. The comparisons are done on three sets of synthetic data: a one-dimensional Gaussian model, a one-dimensional Bernoulli model and a 50-dimensional linear regression model: these simple models already exemplify the strong dependence of the traditional algorithms on the value of \u03b7.\nTerminology. We say that an algorithm is of type \u201cLLR\u201d for \u201cLearning the Learning Rate\u201d when it updates its step size hyperparameter \u03b7 as it unfolds. We refer to LLR algorithms by a compound abbreviation: \u201cSVRG/SG\u201d, for instance, for an algorithm which updates its parameter \u03b8 through SVRG and its hyperparameter \u03b7 through an SG algorithm on \u03b7."
        },
        {
            "heading": "1 The Stochastic Gradient algorithm",
            "text": "To fix ideas, we define the Stochastic Gradient (SG) algorithm as follows. In all that follows, \u0398 = Rn for some n.1 The functions \u2113t are assumed to be smooth. In all our algorithms, the index t starts at 0.\nAlgorithm 1 (Stochastic Gradient). We maintain \u03b8t \u2208 \u0398 (current parameter), initialised at some arbitrary \u03b80 \u2208 \u0398. We fix \u03b7 \u2208 R. At each time t, we fix a rate f(t) \u2208 R. The update equation reads:\n\u03b8t+1 = \u03b8t + \u03b7\nf(t) \u2202\u03b8\u2113t(\u03b8t). (5)\nThe chosen rate f(t) usually satisfies the well-known Robbins\u2013Monro conditions [RM51]:\n\u2211 t\u22650 f(t)\u22121 =\u221e,\n\u2211 t\u22650 f(t)\u22122 <\u221e. (6)\nThe divergence of the sum of the rates allows the ascent to go anywhere in parameter space, while the convergence of the sum of the squares ensures that variance remains finite. Though custom had it that small such rates should be chosen, such as f(t) = 1/t, recently the trend bucked towards the use of large ones, to allow for quick exploration of the parameter space. Throughout the article and experiments we use one such rate:\nf(t) = \u221a t+ 2 log(t+ 3). (7)"
        },
        {
            "heading": "2 Learning the learning rate on a stochastic gra-",
            "text": "dient algorithm"
        },
        {
            "heading": "2.1 The loss as a function of step size",
            "text": "To formalise what we said in the introduction, let us define, for each \u03b7 \u2208 R, the sequence\n(\u03b80, \u03b81, \u03b82, . . .) (8)\nobtained by iterating (5) from some initial value \u03b80. Since they depend on \u03b7, we introduce, for each t > 0, the operator\nTt : \u03b7 \u2208 R 7\u2192 Tt(\u03b7) \u2208 \u0398, (9)\nwhich maps any \u03b7 \u2208 R to the parameter \u03b8t obtained after t iterations of (5). T0 maps every \u03b7 to \u03b80. For each t \u2265 0, the map Tt is a regular function of\n1\u0398 may also be any Riemannian manifold, a natural setting when dealing with gradi-\nents. Most of the text is written in this spirit.\n\u03b7. As explained in the introduction, we want to optimise \u03b7 according to the function:\nLt(\u03b7) := \u2211\ns\u2264t \u2113s(Ts(\u03b7)), (10)\nby conducting an online stochastic gradient ascent on it. We therefore need to compute the derivative in (4):\n\u2202\n\u2202\u03b7 \u2113t(Tt(\u03b7)). (11)\nTo act more decisively on the order of magnitude of \u03b7, we perform an ascent on its logarithm, so that we actually need to compute2:\n\u2202\n\u2202 log \u03b7 \u2113t(Tt(\u03b7)). (12)\nNow, the derivative of the loss at time t with respect to \u03b7 can be computed as the product of the derivative of \u2113t with respect to \u03b8 (the usual input of SG) and the derivative of \u03b8t with respect to \u03b7:\n\u2202\n\u2202 log \u03b7 \u2113t(Tt(\u03b7)) = \u2202\u03b8\u2113t(Tt(\u03b7)) \u00b7 At(\u03b7) (13)\nwhere\nAt(\u03b7) := \u2202Tt(\u03b7)\n\u2202 log \u03b7 . (14)\nComputation of the quantity At and its approximation ht to be introduced later, are the main focus of this text.\nLemma 1. The derivative At(\u03b7) may be computed through the following recursion equation. A0(\u03b7) = 0 and, for t \u2265 0,\nAt+1(\u03b7) = At(\u03b7) + \u03b7\nf(t) \u2202\u03b8\u2113t(Tt(\u03b7)) +\n\u03b7\nf(t) \u22022\u03b8 \u2113t(Tt(\u03b7)) \u00b7At(\u03b7). (15)\nThe proof lies in Section C.1. This update of A involves the Hessian of the loss function with respect to \u03b8, evaluated in the direction of At. Often this quantity is unavailable or too costly. Therefore we will use a finite difference approximation instead:\n\u22022\u03b8 \u2113t(Tt(\u03b7)) \u00b7At(\u03b7) \u2248 \u2202\u03b8\u2113t (Tt(\u03b7) +At(\u03b7))\u2212 \u2202\u03b8\u2113t(Tt(\u03b7)). (16)\nThis design ensures that the resulting update on At(\u03b7) uses the gradient of \u2113t only once:\nAt+1(\u03b7) \u2248 At(\u03b7) + \u03b7\nf(t) \u2202\u03b8\u2113t (Tt(\u03b7) +At(\u03b7)) . (17)\nAn alternative approach would be to compute the Hessian in the direction At by numerical differentiation.\n2 This is an abuse of notation as Tt is not a function of log \u03b7 but of \u03b7. Formally, we would need to replace Tt with Tt \u25e6 exp, which we refrain from doing to avoid burdensome notation."
        },
        {
            "heading": "2.2 LLR on SG: preliminary version with simplified expressions (SG/SG)",
            "text": "Even with the approximation above, computing the quantities At would have a quadratic cost in t: each time we update \u03b7 thanks to (4), we would need to compute anew all the As(\u03b7), s \u2264 t, as well as the whole trajectory \u03b8t = Tt(\u03b7), at each iteration t. We therefore replace the At(\u03b7)\u2019s by online approximations, the quantities ht, which implement the same evolution equation (17) as At, disregarding the fact that \u03b7 may have changed in the meantime. These quantities will be interpreted more properly in Section 4 as derivatives taken along the effective trajectory of the ascent. This yields the SG/SG algorithm.\nAlgorithm 2 (SG/SG). We maintain \u03b8t \u2208 \u0398 (current parameter), \u03b7t \u2208 R (current step size) and ht \u2208 T\u03b8t\u0398 (approximation of the derivative of \u03b8t with respect to log(\u03b7)).\nThe first two are initialised arbitrarily, and h0 is set to 0. The update equations read:\n\n     \n     \nlog \u03b7t+1 = log \u03b7t + 1\n\u00b5t \u2202\u03b8\u2113t(\u03b8t) \u00b7 ht\nht+1 = ht + \u03b7t+1 f(t) \u2202\u03b8\u2113t (\u03b8t + ht) \u03b8t+1 = \u03b8t + \u03b7t+1 f(t) \u2202\u03b8\u2113t(\u03b8t) ,\n(18)\nwhere \u00b5t is some learning rate on log \u03b7, such as \u00b5t = \u221a t+ 2 log(t+ 3)."
        },
        {
            "heading": "2.3 LLR on SG: efficient version (SG/AG)",
            "text": "To obtain better performances, we actually use an adagrad-inspired scheme to update the logarithm of the step size.\nAlgorithm 3 (SG/AG). We maintain \u03b8t \u2208 \u0398 (current parameter), \u03b7t \u2208 R (current step size), ht \u2208 T\u03b8t\u0398 (approximation of the derivative of \u03b8t with respect to log(\u03b7)), nt \u2208 R (average of the squared norms of \u2202\u2113t \u25e6 Tt/\u2202 log \u03b7), and dt \u2208 R (renormalising factor for the computation of nt).\n\u03b8 et \u03b7 are initially set to \u03b80 and \u03b70, the other variables are set to 0. At each time t, we compute \u00b5t \u2208 R (a rate used in several updates), and\n\u03bbt \u2208 R (the approximate derivative of \u2113t \u25e6 \u03b8t with respect to log(\u03b7) at \u03b7t).\nThe update equations read:\n\n                    \n                    \n\u00b5t = \u221a t+ 2 log(t+ 3) \u03bbt = l(\u03b8t) \u00b7 ht\ndt+1 =\n(\n1\u2212 1 \u00b5t\n)\ndt + 1\n\u00b5t\nn2t+1 =\n((\n1\u2212 1 \u00b5t\n)\nn2t + 1\n\u00b5t \u03bb2t\n)\nd\u22121t+1\nlog \u03b7t+1 = log \u03b7t + 1\n\u00b5t \u03bbt nt+1\nht+1 = ht + \u03b7t+1 f(t) \u2202\u03b8\u2113t (\u03b8t + ht) \u03b8t+1 = \u03b8t + \u03b7t+1 f(t) \u2202\u03b8\u2113t(\u03b8t).\n(19)"
        },
        {
            "heading": "2.4 LLR on other Stochastic Gradient algorithms",
            "text": "The LLR procedure may be applied to any stochastic gradient algorithm of the form\n\u03b8t+1 = F (\u03b8t, \u03b7t) (20)\nwhere \u03b8t may store all the information maintained by the algorithm, not necessarily just a parameter value. Appendix B presents the algorithm in this case. Appendix A presents SVRG/AG, which is the particular case of this procedure applied to SVRG with an AdaGrad scheme for the update of \u03b7t."
        },
        {
            "heading": "3 Experiments on SG and SVRG",
            "text": "We now present the experiments conducted to test our procedure. We first describe the experimental set up, then discuss the results."
        },
        {
            "heading": "3.1 Presentation of the experiments",
            "text": "We conducted ascents on synthetic data generated by three different probabilistic models: a one-dimensional Gaussian model, a Bernoulli model and a 50-dimensional linear regression model. Each model has two components: a generative distribution, and a set of distributions used to approximate the former.\nOne Dimensional Gaussian Model. The mean and value of the Gaussian generative distribution were set to 5 and 2 respectively. Let us note\np\u03b8 the density of a standard Gaussian random variable. The function to maximise we used is:\n\u2113t(\u03b8) = log p\u03b8(xt) = \u2212 1\n2 (xt \u2212 \u03b8)2. (21)\nBernoulli model. The parameter in the standard parameterisation for the Bernoulli model was set to p = 0.3, but we worked with a logit parameterisation \u03b8 = log(p/(1 \u2212 p)) for both the generative distribution and the discriminative function. The latter is then:\n\u2113t(\u03b8) = \u03b8 \u00b7 xt \u2212 log ( 1 + e\u03b8 ) . (22)\nFifty-dimensional Linear Regression model. In the last model, we compute a fixed random matrix M . We then draw samples Z from a standard 50-dimensional Gaussian distribution. We then useM to make random linear combinations X = MZ of the coordinates of the Z vectors. Then we observe X and try to recover first coordinate of the sample Z. The solution \u03b8\u2217 is the first row of the inverse of M . Note Y the first coordinate of Z so that the regression pair is (X,Y ). We want to maximise:\n\u2113t(\u03b8) = \u2212 1\n2 (yt \u2212 \u03b8 \u00b7 xt)2 , (23)\nFor each model, we drew 2500 samples from the data (7500 for the 50-\ndimensional model), then conducted ascents on those with on the one hand the SG and SVRG algorithms, and on the other hand their LLR counterparts, SG/SG and SVRG/SG, respectively."
        },
        {
            "heading": "3.2 Description and analysis of the results",
            "text": "For each model, we present four different types of results. We start with the trajectories of the ascents for several initial values of \u03b7 (in the 50-dimensional case, we plot the first entry of \u03b8T \u00b7 M). Then we present the cumulated regrets. Next we show the evolution of the logarithm of \u03b7t along the ascents for the LLR algorithms. Finally, we compare this to trajectories of the nonadaptive algorithms with good initial values of \u03b7. Each time, we present three figures, one for each model.\nEach figure of Figures 1 to 3 is made of four graphs: the upper ones are those of SG and SVRG, the lower ones are those of SG/SG and SVRG/SG. Figures 1 to 3 present the trajectories of the ascents for several orders of magnitude of \u03b70, while Figures 4 to 6 present the cumulated regrets for the same \u03b70\u2019s. The trajectory of the running maximum likelihood (ML) is displayed in red in each plot."
        },
        {
            "heading": "3.2.1 Trajectories of \u03b8",
            "text": "Each figure for the ascent looks the same: there are several well distinguishable trajectories in the graphs of the standard algorithms, the upper ones, while trajectories are much closer to each other in those of the LLR algorithms, the lower ones.\nIndeed, for many values of \u03b7, the standard algorithms will perform poorly. For instance, low values of \u03b7 will result in dramatically low convergence towards the ML, as may be seen in some trajectories of the SG graphs. The SVRG algorithm performs noticeably better, but may start to oscillate, as in Figures 2 and 3.\nThese inconveniences are significantly improved by the use of LLR procedures. Indeed, in each model, almost every trajectory gets close to that of the ML in the SG/AG graphs. In the SVRG/AG graphs, the oscillations are overwhelmingly damped. Improvements for SG, though significant, are not as decisive in the linear regression model as in the other two, probably due to its greater complexity."
        },
        {
            "heading": "3.2.2 Cumulated regrets",
            "text": "Each curve of Figures 4 to 6 represents the difference between the cumulated regret of the algorithm used and that of the ML, for the \u03b70 chosen. The curves of SG and SVRG all go upwards, which means that the difference increases with time, whereas those of SG/AG and SVRG/SG tend to stagnate strikingly quickly. Actually, the trajectories for the linear regression model do not stagnate, but they are still significantly better for the LLR algorithms than for the original ones. The stagnation means that the values of the parameter found by these algorithms are very quickly as good as the Maximum Likelihood for the prediction task. Arguably, the fluctuations of the ascents around the later are therefore not a defect of the model: the cumulated regret graphs show that they are irrelevant for the minimisation at hand."
        },
        {
            "heading": "3.2.3 Evolution of the step size of the LLR algorithms during the ascents",
            "text": "Figures 7 to 9 show the evolution of the value of the logarithm of \u03b7t in the LLR procedures for the three models, in regard of the trajectories of the corresponding ascents. For the Gaussian and Bernoulli models, in Figures 7\nand 8, log(\u03b7t) tends to stagnate quite quickly. This may seem a desirable behaviour : the algorithms have reached good values for \u03b7t, and the ascent may accordingly proceed with those. However, this analysis may seem somewhat unsatisfactory due to the 1/f(t) dampening term in the parameter update, which remains unaltered by our procedure. For the linear regression model, in Figure 9, the convergence takes longer in the SG/SG case, and even in the SVRG/SG one, which may be explained again by the complexity of the model."
        },
        {
            "heading": "3.2.4 LLR versus hand-crafted learning rates",
            "text": "Figures 10 to 12 show the trajectories of the ascents for LLR algorithms with poor initial values of the step size, compared to the trajectories of the original algorithms with hand-crafted optimal values of \u03b7. The trajectories of the original algorithms appear in red. They possess only two graphs each, where all the trajectories are pretty much undistinguishable from another. This shows that the LLR algorithms show acceptable behaviour even with poor initial values of \u03b7, proving the procedure is able to rescue very badly initialised algorithms. However, one caveat is that the LLR procedure encounters difficulties dealing with too large values of \u03b70, and is much more efficient at dealing with small values of \u03b70. We have no satisfying explana-\ntion of this phenomenon yet. We thus suggest, in practice, to underestimate rather than overestimate the initial value \u03b70."
        },
        {
            "heading": "3.3 \u03b7t in a quadratic model",
            "text": "In a quadratic deterministic one-dimensional model, where we want to maximise:\nf(\u03b8) = \u2212\u03b1x 2\n2 , (24)\nSG is numerically stable if, and only if, \u2223\n\u2223 \u2223 \u2223 1\u2212 \u03b1\u03b7 f(t)\n\u2223 \u2223 \u2223 \u2223 < 1, (25)\nthat is \u03b7\n2f(t) < \u03b1\u22121. (26)\nEach graph of Figure 13 has two curves, one for the original algorithm, the other for its LLR version. The curve of the LLR version goes down quickly, then much more slowly, while the other curve goes down slowly all the time. This shows that, for \u03b1 = 108, the ratio above converges quickly towards\n\u03b1\u22121 for SG/AG and SVRG/AG, showing the ascent on \u03b7 is indeed efficient. Then, the algorithm has converged, and \u03b7t stays nearly constant, so much so that the LLR curve behaves like the other one. However, the convergence of \u03b7t happens too slowly: \u03b8t takes very large values before \u03b7t reaches this value, and even though it eventually converges to 0, such behaviour is unacceptable in practise."
        },
        {
            "heading": "4 A pathwise interpretation of the derivatives",
            "text": "Until now, we have tried to optimise the step size for a stochastic gradient ascent. This may be interpreted as conducting a gradient ascent on the subspace of the ascent algorithms which gathers the stochastic gradient algorithms, parametrised by \u03b7 \u2208 R. However, we had to replace the At(\u03b7)\u2019s by the ht\u2019s because computing the former gave our algorithm a quadratic complexity in time. Indeed, adhesion to Equation 1 entails using A0(\u03b71) to compute A1(\u03b71), for instance. Likewise, A0(\u03b72) and A1(\u03b72) would be necessary to compute A2(\u03b72), and this scheme would repeat itself for every iteration.\nWe now introduce a formalism which shows the approximations we use are actually derivatives taken alongside the effective trajectory of the ascent.\nIt will also allow us to devise a new algorithm. It will, however, not account for the approximation of the Hessian.\nTo this avail, let us parameterise stochastic gradient algorithms by a sequence of step sizes\n\u03b7 = (\u03b70, \u03b71, . . .) (27)\nsuch that at iteration t, the update equation for \u03b8t becomes:\n\u03b8t+1 = \u03b8t + \u03b7t+1 f(t) \u2202\u03b8\u2113t(\u03b8t). (28)"
        },
        {
            "heading": "4.1 The loss as a function of step size: extension of the formalism",
            "text": "Consider the space S of infinite real sequences\n\u03b7 = (\u03b70, \u03b71, \u03b72, . . .) (29)\nWe expand the Tt operators defined in Section 2 to similar ones defined on S, with the same notation. Namely, define T0(\u03b7) = \u03b80 and, for t > 0,\nTt : \u03b7 \u2208 S 7\u2192 Tt(\u03b7) \u2208 R (30)\nwhere \u03b8t has been obtained thanks to t iterations of (28). Tt is a regular function of \u03b7, as the computations only involve\n\u03b70, \u03b71, . . . , \u03b7t, (31)\nand so take place in finite-dimensional spaces. This will apply in all the computations below. As before, we work on a space we call log(S), the image of S by the mapping\n\u03b7 = (\u03b7t)t\u22650 \u2208 S 7\u2192 log(\u03b7) = (log \u03b7t)t\u22650, (32)\nbut we do not change notation for the functions \u03b7 7\u2192 Tt(\u03b7), as in Section 2."
        },
        {
            "heading": "4.2 The update of the step size in the SG/SG algorithm as a gradient ascent",
            "text": "We now prove that in SG/SG, when the Hessian is used without approximations, the step size \u03b7t indeed follows a gradient ascent scheme.\nProposition 1. Let (\u03b8t)t\u22650 , \u03b7 = (\u03b7t)t\u22650 (33)\nbe the sequences of parameters and step-sizes obtained with the SG/SG algorithm, where the Hessian is not approximated: this is Algorithm 2 where the update on ht is replaced with\nht+1 = ht + \u03b7\n\u00b5t \u2202\u03b8\u2113t(\u03b8t) +\n\u03b7\n\u00b5t \u22022\u03b8 \u2113t(\u03b8t) \u00b7 ht. (34)\nDefine e in the tangent plane of log(S) at log(\u03b7) by\net = 1, t \u2265 0. (35)\nThen, for all t \u2265 0,\nlog \u03b7t+1 = log \u03b7t + 1\n\u00b5t\n\u2202\n\u2202e \u2113t(Tt(\u03b7)). (36)\nThe proof lies in Appendix C.2.1."
        },
        {
            "heading": "4.3 A new algorithm, using a notion of \u201cmemory\u201d borrowed from [SZL13]",
            "text": "We would now like to compute the change in \u03b7 implied by a small modification of all previous coordinates \u03b7s for s less than the current time t, but to\ncompute the modification differently according to whether the coordinate s is \u201coutdated\u201d or not. To do it, we use the quantity \u03c4t defined in Section 4.2 of [SZL13] as the \u201cnumber of samples in recent memory\u201d. We want to discard the old \u03b7\u2019s and keep the recent ones. Therefore, at each time t, we\n\u221210\n\u22129\n\u22128\n\u22127\n\u22126\n\u22125\n\u22124\n\u22123\n\u22122\n\u22121\n0 500 1000 1500 2000 2500\nlo g 1 0\n(\n\u03b7 t\n2 \u221a t+\n2 lo g (t + 3 )\n)\nnumber of iterations\nConvergence towards the inverse of the eigenvalue for SG/AG\nSG, \u03b7=10\u22121 SG/AG, \u03b70=10 \u22121\n\u221211 \u221210 \u22129 \u22128 \u22127 \u22126 \u22125 \u22124 \u22123 \u22122 \u22121\n0 500 1000 1500 2000 2500\nlo g 1 0\n(\n\u03b7 t\n2 \u221a t+\n2 lo g (t + 3 )\n)\nnumber of iterations\nConvergence towards the inverse of the eigenvalue for SVRG/AG\nSVRG, \u03b7=10\u22121 SVRG/AG, \u03b70=10 \u22121\nFigure 13: Evolution of log10 (\n\u03b7t 2 \u221a t+2 log(t+3)\n)\nfor a quadratic deterministic\none-dimensional model for SG, SVRG and their LLR versions\ncompute \u03b3t = exp(\u22121/\u03c4t). (37)\nChoose \u03b7 \u2208 log(S), and consider the vector in the tangent plane to log(S) at \u03b7:\nejt =\n\n  \n  \nt \u220f\nk=j\n\u03b3j, j \u2264 t\n0, j \u2265 t+ 1.\n(38)\nTo run an algorithm using the et\u2019s instead of e as before, all we need to compute again is the formula for the update of the derivative below:\nHt := \u2202\n\u2202et Tt(\u03b7). (39)\nHt may indeed be computed, thanks to the following result.\nProposition 2. The update equation of Ht is:\nHt+1 = \u03b3t+1Ht + \u03b3t+1 \u03b7t+1 f(t) \u2202\u03b8\u2113t(Tt(\u03b7 t)) + \u03b3t+1 \u03b7t+1 f(t) \u22022T \u2113t(Tt(\u03b7)) \u00b7 Ht. (40)\nThe proof lies in Section C.2.2."
        },
        {
            "heading": "Acknowledgements",
            "text": "The first author would like to thank Gaetan Marceau-Caron for his advice on programming, and Je\u0301re\u0301my Bensadon for crucial help with LATEX."
        },
        {
            "heading": "A LLR applied to the Stochastic Variance Reduced",
            "text": "Gradient\nThe Stochastic Variance Reduced Gradient (SVRG) was introduced by Johnson and Zhang in [JZ13]. We define here a version intended for online use.\nAlgorithm 4 (SVRG online). We maintain \u03b8t, \u03b8 b \u2208 \u0398 (current parameter and base parameter) and sbt \u2208 T\u2243\u03b8t\u0398 (sum of the gradients of the \u2113s computed at \u03b8s up to time t).\n\u03b8 is set to \u03b80 and \u03b8 b along sb to 0. The update equations read: \n  \n  \nsbt+1 = s b t + \u2202\u03b8\u2113t(\u03b8 b)\n\u03b8t+1 = \u03b8t + \u03b7\n(\n\u2202\u03b8\u2113t(\u03b8t)\u2212 \u2202\u03b8\u2113t(\u03b8b) + sbt+1 t+ 1\n)\n. (41)\nWe now present the LLR version, obtained by updating the \u03b7 of SVRG thanks to an SG ascent. We call this algorithm \u201cSVRG/SG\u201d.\nAlgorithm 5 (SVRG/AG). We maintain \u03b8t, \u03b8 b \u2208 \u0398 (current parameter and base parameter), \u03b7t \u2208 R (current step size), sbt \u2208 T\u2243\u03b8t\u0398 (sum of the gradients of the \u2113s computed at \u03b8s up to time t), ht \u2208 T\u03b8t\u0398 (approximation of the derivative of Tt with respect to log(\u03b7) at \u03b7t) and the real numbers nt (average of the squared norms of the \u03bbs defined below) and dt (renormalising factor for the computation of nt).\n\u03b8 is set to \u03b80, the other variables are set to 0. At each time t, we compute \u00b5t \u2208 R (a rate used in several updates), and\n\u03bbt \u2208 R (the approximate derivative of \u2113t \u25e6 \u03b8t with respect to log(\u03b7) at \u03b7t). The update equations read:\n\n                          \n                          \n\u00b5t = \u221a t+ 2 log(t+ 3) \u03bbt = \u2202\u03b8\u2113t(\u03b8t) \u00b7 ht\ndt+1 =\n(\n1\u2212 1 \u00b5t\n)\ndt + 1\n\u00b5t\nn2t+1 =\n((\n1\u2212 1 \u00b5t\n)\nn2t + 1\n\u00b5t \u03bb2t\n)\nd\u22121t+1\n\u03b7t+1 = \u03b7t exp\n(\n1\n\u00b5t \u03bbt nt+1\n)\nsbt+1 = s b t + \u2202\u03b8\u2113t(\u03b8 b)\nht+1 = ht + \u03b7t+1\n(\n\u2202\u03b8\u2113t(\u03b8t + ht)\u2212 \u2202\u03b8\u2113t(\u03b8b) + sbt+1 t+ 1\n)\n\u03b8t+1 = \u03b8t + \u03b7t+1\n(\n\u2202\u03b8\u2113t(\u03b8t)\u2212 \u2202\u03b8\u2113t(\u03b8b) + sbt+1 t+ 1\n)\n.\n(42)"
        },
        {
            "heading": "B LLR applied to a general stochastic gradient al-",
            "text": "gorithm\nLet \u0398 and H be two spaces. \u0398 is the space of parameters, H is that of hyperparameters. In this section, a parameter potentially means a tuple of parameters in the sense of other sections. For instance, in SVRG/SG online, we would call a parameter the couple\n( \u03b8t, \u03b8 b ) . (43)\nLikewise, in the same algorithm, we would call a hyperparameter the couple\n(\u03b7t, ht) . (44)\nLet F : \u0398\u00d7H \u2192 \u0398\n(\u03b8, \u03b7) 7\u2192 F (\u03b8, \u03b7). (45)\nbe differentiable with respect to both variables. We consider the algorithm:\n\u03b8t+1 = F (\u03b8t, \u03b7t). (46)\nLet us present its LLR version. We call it GEN/SG, GEN standing for \u201cgeneral\u201d.\nAlgorithm 6 (GEN/SG). We maintain \u03b8t \u2208 \u0398 (current parameter), \u03b7t \u2208 H (current hyperparameter), ht \u2208 T\u03b8t\u0398 (approximation of the derivative of Tt in the direction of e \u2208 T\u03b7tH).\n\u03b8 and \u03b7 are set to user-defined values. The update equations read:\n\n   \n   \n\u03b7t+1 = \u03b7t + \u03b1\u2202\u03b8\u2113t(\u03b8t) \u00b7 ht ht+1 = \u2202\u03b8F (\u03b8t, \u03b7t) \u00b7 ht + \u2202\u03b7F (\u03b8t, \u03b7t) \u00b7 \u2202\n\u2202e \u03b7t\n\u03b8t+1 = F (\u03b8t, \u03b7t+1) .\n(47)"
        },
        {
            "heading": "C Computations",
            "text": "C.1 Computations for Section 2: proof of Fact 1\nProof. \u03b80 is fixed, so A0(\u03b7) = 0. Let t \u2265 0. We differentiate (5) with respect to log(\u03b7), to obtain:\n\u2202\n\u2202log \u03b7 Tt+1(\u03b7) =\n\u2202\n\u2202log \u03b7 Tt(\u03b7) +\n\u03b7\nf(t) \u2202\u03b8\u2113t(\u03b8t) +\n\u03b7\nf(t) \u22022\u03b8 \u2113t(\u03b8t(\u03b7)) \u00b7\n\u2202\n\u2202log \u03b7 Tt(\u03b7),\n(48) which concludes the proof.\nC.2 Computations for Section 4\nC.2.1 Computations for Section 4.2: proof of Proposition 1\nTo prove Proposition 1, we use the following three lemmas. The first two are technical, and are used in the proof of the third one, which provides an update formula for the derivative appearing in the statement of the proposition. We may have proceeded without these, as in the proof of Fact 1, but they allow the approach to be more generic.\nLemma 2. Let\nFt : \u0398\u00d7 R \u2192 \u0398 (\u03b8, \u03b7) 7\u2192 Ft(\u03b8, \u03b7) = \u03b8 + \u03b7f(t)\u2202\u03b8\u2113t(\u03b8).\n(49)\nThen, \u2202\n\u2202\u03b8 Ft(\u03b8, \u03b7) = Id+\n\u03b7\nf(t) \u22022\u03b8 \u2113t(\u03b8) (50)\nand \u2202\n\u2202\u03b7 Ft(\u03b8, \u03b7) =\n1\nf(t) \u2202\u03b8\u2113t(\u03b8). (51)"
        },
        {
            "heading": "Id is the identity on the tangent plane to \u0398 in \u03b8.",
            "text": "Lemma 3. Let\nVt : S \u2192 \u0398\u00d7 R \u03b7 7\u2192 Vt(\u03b7) = (\u03b8t(\u03b7), \u03b7t+1).\n(52)\nConsider log(\u03b7) \u2208 log(S), and any vector e tangent to log(S) at this point. Then the directional derivative of\nFt \u25e6 Vt : S \u2192 \u0398 \u03b7 7\u2192 Ft(Vt(\u03b7)) = Tt(\u03b7) + \u03b7t+1f(t) \u2202\u03b8\u2113t(Tt(\u03b7))\n(53)\nat the point log(\u03b7) and in the direction e is\n\u2202\n\u2202e Ft \u25e6 Vt(\u03b7) =\n\u2202\n\u2202e Tt(\u03b7) +\n\u2202\n\u2202e \u03b7t+1\n1\nf(t) \u2202\u03b8\u2113t(Tt(\u03b7)) + \u03b7t+1 f(t) \u22022\u03b8 \u2113t(Tt(\u03b7)) \u00b7 \u2202 \u2202e Tt(\u03b7).\n(54)\nWe may then prove the following lemma.\nLemma 4. Define\nHt = \u2202\n\u2202e Tt(\u03b7). (55)\nThen for all t \u2265 0,\nHt+1 = Ht + \u03b7t+1 f(t) \u2202\u03b8\u2113t(Tt(\u03b7)) + \u03b7t+1 f(t) \u22022\u03b8 \u2113t(Tt(\u03b7)) \u00b7 Ht. (56)\nProof. The update equation of Tt(\u03b7), (28), is such that:\nTt+1(\u03b7) = Tt(\u03b7) + \u03b7t+1 f(t) \u2202\u03b8\u2113t(Tt(\u03b7)) = Ft \u25e6 Vt(\u03b7). (57)\nFrom the above and Lemma 3,\n\u2202\n\u2202e Tt+1(\u03b7) =\n\u2202\n\u2202e Tt(\u03b7)+\n\u2202\n\u2202e \u03b7t+1\n1\nf(t) \u2202\u03b8\u2113t(Tt(\u03b7))+ \u03b7t+1 f(t) \u22022\u03b8 \u2113t(Tt(\u03b7)) \u00b7 \u2202 \u2202e Tt(\u03b7).\n(58) Now,\n\u2202\n\u2202e \u03b7t+1 = \u03b7t+1, (59)\nwhich concludes the proof.\nFinally, we prove Proposition 1.\nProof of Proposition 1. It is sufficient to prove that, for all t \u2265 0,\n\u2202\n\u2202e \u2113t(Tt(\u03b7)) = \u2202\u03b8\u2113t(\u03b8t) \u00b7 ht, (60)\nthat is, \u2202\u03b8\u2113t(Tt(\u03b7)) \u00b7 Ht = \u2202\u03b8\u2113t(\u03b8t) \u00b7 ht. (61)\nTherefore, it is sufficient to prove that, for all t \u2265 0, Tt(\u03b7) = \u03b8t and Ht = ht. T0(\u03b7) = \u03b80 by construction and, since \u03b80 does not depend on \u03b7, H0 = 0 = h0. Assuming the results hold up to iteration t, it is straighforward that Tt+1(\u03b7) = \u03b8t+1, since for all s \u2264 t, Ts(\u03b7) = \u03b8s. Therefore, thanks to Lemma 4, Ht and ht have the same update, so that Ht+1 = ht+1, which concludes the proof.\nC.2.2 Computations for Section 4.3: proof of Proposition 2\nProof. Thanks to (58) in Lemma 3,\n\u2202\n\u2202et+1 Tt+1(\u03b7) =\n\u2202\n\u2202et+1 Tt(\u03b7) +\n\u2202\n\u2202et+1 \u03b7t+1\n1\nf(t) \u2202\u03b8\u2113t(Tt(\u03b7))\n+ \u03b7t+1 f(t) \u22022\u03b8\u2113t(Tt(\u03b7)) \u00b7 \u2202 \u2202et+1 Tt(\u03b7),\n(62)\nthat is:\nHt+1 = \u2202\n\u2202et+1 Tt(\u03b7)+\n\u2202\n\u2202et+1 \u03b7t+1\n1\nf(t) \u2202\u03b8\u2113t(Tt(\u03b7))+ \u03b7t+1 f(t) \u22022\u03b8\u2113t(Tt(\u03b7))\u00b7 \u2202 \u2202et+1 Tt(\u03b7).\n(63) We first prove:\n\u2202\n\u2202et+1 Tt(\u03b7) = \u03b3t+1\n\u2202\n\u2202et Tt(\u03b7). (64)\nDefine (fj)j\u22650 the canonical basis of the tangent plane to log(S) at \u03b7. Then,\net+1 = \u03b3t+1(et + ft+1). (65)\nTherefore, \u2202\n\u2202et+1 Tt(\u03b7) =\n\u2202\n\u2202et+1 Tt(\u03b7)\n= \u03b3t+1 \u2202\n\u2202et Tt(\u03b7\nt) + \u2202\n\u2202ft+1 Tt(\u03b7\nt)\n= \u03b3t+1 \u2202\n\u2202et Tt(\u03b7\nt)\n(66)\nbecause the last term is 0. Therefore,\n\u2202\n\u2202et+1 Tt(\u03b7) = \u03b3t+1Ht. (67)\nThen, thanks to (58), \u2202\n\u2202et+1 \u03b7t+1 = \u03b3t+1\u03b7t+1, (68)\nwhich is true since\n\u2202\n\u2202et+1 \u03b7t+1 = \u03b3t+1\n\u2202\n\u2202ft+1 \u03b7t+1 = \u03b3t+1\u03b7t+1, (69)\nand concludes the proof."
        }
    ],
    "title": "Speed learning on the fly",
    "year": 2015
}