{
    "abstractText": "Java platform and third-party libraries provide various security features to facilitate secure coding. However, misusing these features can cost tremendous time and effort of developers or cause security vulnerabilities in software. Prior research was focused on the misuse of cryptography and SSL APIs, but did not explore the key fundamental research question: what are the biggest challenges and vulnerabilities in secure coding practices? In this paper, we conducted a comprehensive empirical study on StackOverflow posts to understand developers\u2019 concerns on Java secure coding, their programming obstacles, and potential vulnerabilities in their code. We observed that developers have shifted their effort to the usage of authentication and authorization features provided by Spring security\u2014a third-party framework designed to secure enterprise applications. Multiple programming challenges are related to APIs or libraries, including the complicated cross-language data handling of cryptography APIs, and the complex Java-based or XML-based approaches to configure Spring security. More interestingly, we identified security vulnerabilities in the suggested code of accepted answers. The vulnerabilities included using insecure hash functions such as MD5, breaking SSL/TLS security through bypassing certificate validation, and insecurely disabling the default protection against Cross Site Request Forgery (CSRF) attacks. Our findings reveal the insufficiency of secure coding assistance and education, and the gap between security theory and coding practices.",
    "authors": [
        {
            "affiliations": [],
            "name": "Na Meng"
        },
        {
            "affiliations": [],
            "name": "Stefan Nagy"
        },
        {
            "affiliations": [],
            "name": "Daphne Yao"
        },
        {
            "affiliations": [],
            "name": "Wenjie Zhuang"
        },
        {
            "affiliations": [],
            "name": "Gustavo Arango Argoty"
        },
        {
            "affiliations": [],
            "name": "Gustavo Arango"
        }
    ],
    "id": "SP:6fbf0dce656a2d15fe844c01227dbe7b2a43f09d",
    "references": [
        {
            "authors": [
                "n. d"
            ],
            "title": "Configure Spring Security without XML in Spring 4. https://stackoverflow. com/questions/20961600/configure-spring-security-without-xml-in-spring-4",
            "venue": "([n. d.])",
            "year": 2096
        },
        {
            "authors": [
                "n. d"
            ],
            "title": "InvalidKeySpecException : algid parse error, not a sequence. https://stackoverflow.com/questions/31941413/ invalidkeyspecexception-algid-parse-error-not-a-sequence",
            "venue": "([n. d.])",
            "year": 1941
        },
        {
            "authors": [
                "n. d"
            ],
            "title": "Allowing Java to use an untrusted certificate for SS- L/HTTPS connection. https://stackoverflow.com/questions/1201048/ allowing-java-to-use-an-untrusted-certificate-for-ssl-https-connection",
            "venue": "([n. d.])",
            "year": 2010
        },
        {
            "authors": [
                "n. d"
            ],
            "title": "Spring Security using JBoss <security-domain>",
            "venue": "https://stackoverflow. com/questions/28172056/spring-security-using-jboss-security-domain. ([n. d.])",
            "year": 2056
        },
        {
            "authors": [
                "n. d"
            ],
            "title": "SSL Socket Connection working even though client is not sending certificate? https://stackoverflow.com/questions/26761966/ ssl-socket-connection-working-even-though-client-is-not-sending-certificate",
            "venue": "([n. d.])",
            "year": 1966
        },
        {
            "authors": [
                "Alexia Chatzikonstantinou",
                "Christoforos Ntantogian",
                "Georgios Karopoulos",
                "Christos Xenakis"
            ],
            "title": "Evaluation of Cryptography Usage in Android Applications. In Proceedings of the 9th EAI International Conference on Bio-inspired Information and Communications Technologies (Formerly BIONETICS) (BICT\u201915)",
            "venue": "ICST (Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering),",
            "year": 2016
        },
        {
            "authors": [
                "AnupamDatta",
                "Ante Derek",
                "John C. Mitchell",
                "Arnab Roy"
            ],
            "title": "Protocol Composition Logic (PCL)",
            "venue": "Electronic Notes in Theoretical Computer Science",
            "year": 2007
        },
        {
            "authors": [
                "Manuel Egele",
                "David Brumley",
                "Yanick Fratantonio",
                "Christopher Kruegel"
            ],
            "title": "An Empirical Study of Cryptographic Misuse in Android Applications",
            "venue": "In Proceedings of the 2013 ACM SIGSAC Conference on Computer  Communications Security (CCS \u201913)",
            "year": 2013
        },
        {
            "authors": [
                "Levent Erk\u00f6k",
                "John Matthews"
            ],
            "title": "Pragmatic Equivalence and Safety Checking in Cryptol",
            "venue": "In Proceedings of the 3rd Workshop on Programming Languages Meets Program Verification (PLPV \u201909)",
            "year": 2008
        },
        {
            "authors": [
                "Sascha Fahl",
                "Marian Harbach",
                "Thomas Muders",
                "Lars Baumg\u00e4rtner",
                "Bernd Freisleben",
                "Matthew Smith"
            ],
            "title": "Why Eve and Mallory Love Android: An Analysis of Android SSL (in)Security",
            "venue": "In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS \u201912)",
            "year": 2012
        },
        {
            "authors": [
                "Felix Fischer",
                "Konstantin B\u00c2\u013aottinger",
                "Huang Xiao",
                "Christian Stransky",
                "Yasemin Acar",
                "Michael Backes",
                "Sascha Fahl"
            ],
            "title": "Stack Overflow Considered Harmful? The Impact of Copy&Paste on Android Application Security",
            "venue": "In 38th IEEE Symposium on Security and Privacy (S&P",
            "year": 2017
        },
        {
            "authors": [
                "Cory Gackenheimer"
            ],
            "title": "Implementing Security and Cryptography",
            "venue": "In Node. js Recipes",
            "year": 2013
        },
        {
            "authors": [
                "Martin Georgiev",
                "Subodh Iyengar",
                "Suman Jana",
                "Rishita Anubhai",
                "Dan Boneh",
                "Vitaly Shmatikov"
            ],
            "title": "The Most Dangerous Code in the World: Validating SSL Certificates in Non-browser Software",
            "venue": "In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS \u201912)",
            "year": 2012
        },
        {
            "authors": [
                "Li Gong",
                "Gary Ellison"
            ],
            "title": "Inside Java(TM) 2 Platform Security: Architecture, API Design, and Implementation (2nd ed.)",
            "year": 2003
        },
        {
            "authors": [
                "B. He",
                "V. Rastogi",
                "Y. Cao",
                "Y. Chen",
                "V.N. Venkatakrishnan",
                "R. Yang",
                "Z. Zhang"
            ],
            "title": "Vetting SSL Usage in Applications with SSLINT",
            "venue": "IEEE Symposium on Security and Privacy",
            "year": 2015
        },
        {
            "authors": [
                "David Lazar",
                "Haogang Chen",
                "Xi Wang",
                "Nickolai Zeldovich"
            ],
            "title": "Why Does Cryptographic Software Fail?: A Case Study and Open Problems",
            "venue": "In Proceedings of 5th Asia-Pacific Workshop on Systems (APSys \u201914)",
            "year": 2014
        },
        {
            "authors": [
                "Yong Li",
                "Yuanyuan Zhang",
                "Juanru Li",
                "Dawu Gu"
            ],
            "title": "iCryptoTracer: Dynamic Analysis onMisuse of Cryptography Functions in iOSApplications",
            "year": 2014
        },
        {
            "authors": [
                "Fred Long"
            ],
            "title": "Software Vulnerabilities in Java",
            "venue": "Technical Report CMU/SEI-2005- TN-044",
            "year": 2005
        },
        {
            "authors": [
                "Adrian Mettler",
                "David Wagner",
                "Tyler Close"
            ],
            "title": "Joe-E: A Security-Oriented Subset of Java",
            "venue": "In Network and Distributed Systems Symposium. Internet Society",
            "year": 2010
        },
        {
            "authors": [
                "J.C. Mitchell",
                "M. Mitchell",
                "U. Stern"
            ],
            "title": "Automated Analysis of Cryptographic Protocols Using Mur/Spl Phi",
            "venue": "In Proceedings of the 1997 IEEE Symposium on Security and Privacy (SP \u201997). IEEE Computer Society,",
            "year": 1997
        },
        {
            "authors": [
                "Bodo M\u00f6ller",
                "Thai Duong",
                "Krzysztof Kotowicz"
            ],
            "title": "This POODLE bites: exploiting the SSL 3.0 fallback",
            "year": 2014
        },
        {
            "authors": [
                "Sarah Nadi",
                "Stefan Kr\u00fcger",
                "Mira Mezini",
                "Eric Bodden"
            ],
            "title": "Jumping Through Hoops: Why Do Java Developers Struggle with Cryptography APIs",
            "venue": "In Proceedings of the 38th International Conference on Software Engineering (ICSE \u201916)",
            "year": 2016
        },
        {
            "authors": [
                "Lucky Onwuzurike",
                "Emiliano De Cristofaro"
            ],
            "title": "Danger is My Middle Name: Experimenting with SSL Vulnerabilities in Android Apps",
            "venue": "In Proceedings of the 8th ACM Conference on Security & Privacy in Wireless and Mobile Networks (WiSec \u201915)",
            "year": 2015
        },
        {
            "authors": [
                "Shao Shuai",
                "Dong Guowei",
                "Guo Tao",
                "Yang Tianchang",
                "Shi Chenjie"
            ],
            "title": "Modelling Analysis and Auto-detection of Cryptographic Misuse in Android Applications",
            "venue": "In Proceedings of the 2014 IEEE 12th International Conference on Dependable, Autonomic and Secure Computing (DASC \u201914)",
            "year": 2014
        },
        {
            "authors": [
                "E. Smith",
                "D.L. Dill"
            ],
            "title": "Automatic Formal Verification of Block Cipher Implementations",
            "year": 2008
        },
        {
            "authors": [
                "J Steven"
            ],
            "title": "Password storage cheat sheet",
            "year": 2017
        },
        {
            "authors": [
                "Marc Stevens",
                "Elie Bursztein",
                "Pierre Karpman",
                "Ange Albertini",
                "Yarik Markov"
            ],
            "title": "The first collision for full SHA-1",
            "venue": "IACR Cryptology ePrint Archive",
            "year": 2017
        },
        {
            "authors": [
                "Xiaoyun Wang",
                "Dengguo Feng",
                "Xuejia Lai",
                "Hongbo Yu"
            ],
            "title": "Collisions for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD",
            "venue": "IACR Cryptology ePrint Archive",
            "year": 2004
        },
        {
            "authors": [
                "Xin-Li Yang",
                "David Lo",
                "Xin Xia",
                "Zhi-Yuan Wan",
                "Jian-Ling Sun"
            ],
            "title": "What Security Questions Do Developers Ask? A Large-Scale Study of Stack Overflow Posts",
            "venue": "Journal of Computer Science and Technology 31,",
            "year": 2016
        },
        {
            "authors": [
                "William Zeller",
                "Edward W Felten"
            ],
            "title": "n. d.",
            "venue": "Cross-Site Request Forgeries: Exploitation and prevention,",
            "year": 2008
        }
    ],
    "sections": [
        {
            "text": "We observed that developers have shifted their effort to the usage of authentication and authorization features provided by Spring security\u2014a third-party framework designed to secure enterprise applications. Multiple programming challenges are related to APIs or libraries, including the complicated cross-language data handling of cryptography APIs, and the complex Java-based or XML-based approaches to configure Spring security. More interestingly, we identified security vulnerabilities in the suggested code of accepted answers. The vulnerabilities included using insecure hash functions such as MD5, breaking SSL/TLS security through bypassing certificate validation, and insecurely disabling the default protection against Cross Site Request Forgery (CSRF) attacks. Our findings reveal the insufficiency of secure coding assistance and education, and the gap between security theory and coding practices.\nCCS CONCEPTS \u2022 General and reference\u2192 Empirical studies;\nKEYWORDS CSRF, SSL/TLS certificate validation, cryptographic hash functions, authentication, authorization\nACM Reference format: Na Meng, Stefan Nagy, Daphne Yao, Wenjie Zhuang, Gustavo Arango Argoty. 2017. Secure Coding Practices in Java: Challenges and Vulnerabilities. In Proceedings of ACM Conference, Washington, DC, USA, July 2017 (Conference\u201917), 13 pages. https://doi.org/10.475/123_4\nPermission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses, contact the owner/author(s). Conference\u201917, July 2017, Washington, DC, USA \u00a9 2017 Copyright held by the owner/author(s). ACM ISBN 123-4567-24-567/08/06. https://doi.org/10.475/123_4"
        },
        {
            "heading": "1 INTRODUCTION",
            "text": "Java platform and third-party libraries or frameworks (e.g., BouncyCastle [7] and Spring Security [53]) provide various features to facilitate secure coding. However, misusing these libraries and frameworks not only costs excessive debugging effort of developers, but also leads to security vulnerabilities in software [13, 63, 95, 96]. For example, Veracode identified software errors in the handling of user credentials, including hard-coded password and plaintext passwords in configuration files [63]. These errors can enable attackers to bypass access controls.\nPrior researchmainly focused on themisuse of cryptography and SSL APIs that causes security vulnerabilities [78, 80, 83, 86]. Specifically, Lazar et al. manually examined 269 published cryptographic vulnerabilities in the CVE database, and observed 83% of them were caused by cryptography API misuse [86]. Fahl et al. [80] and Georgiev et al. [83] separately implemented the man-in-the-middle attack, and detected vulnerable Android applications and software libraries that misused SSL APIs. Nadi et al. further investigated the obstacles developers face while using the Java cryptography APIs, the tasks for which they use the APIs, and the kind of tool support they desire [92]. Despite these studies, some key questions on secure coding practices remain unanswered. They include (1) whether programmers are equipped with sufficient security knowledge and automatic coding support, and (2) whether the coding practices benefitted from security research over the years.\nFor this paper, we conducted a comprehensive in-depth investigation on the common concerns, programming challenges, and security vulnerabilities in developers\u2019 secure coding practices by manually inspecting 497 StackOverflow posts related to Java security. We chose StackOverflow [62] because (1) developers usually share and discuss programming issues and solutions on this online platform, and (2) StackOverflow plays an important role in educating developers and impacting their daily coding practices. The main challenge of performing this empirical study is interpreting each security-relevant programming issue or solution within both the program context and security context. To comprehend each post within the program context, we manually checked all mentioned information about the source code, configuration files, and/or execution environments. Then we decided the root cause and solution of the problem. To comprehend each post within the security context, we also identified the security requirement that developers tried to implement and investigated the involved security libraries. Then we determined whether the implementation fulfilled the requirement. Such manual analysis requires so much comprehension and expertise in both software engineering (SE) and security that it is difficult to automate the process.\nWith our thorough manual analysis on the 497 posts, we investigated the following three research questions (RQs):\nar X\niv :1\n70 9.\n09 97\n0v 1\n[ cs\n.C R\n] 2\n8 Se\np 20\n17\nRQ1 What are the common concerns on Java secure coding? Although there are various security libraries and frameworks [2, 32, 34, 56, 84, 93], several questions are still unanswered, such as (1) which are the popular security features being frequently asked about, and (2) what are the hard-to-implement security defenses in practice? RQ2 What are the common programming challenges? We aim to identify the common obstacles that prevented developers from implementing secure code easily and correctly. This information will help guide SE researchers and tool builders to better develop tools, and to help close the gap between the intended library usage and developers\u2019 actual usage. RQ3 What are the common security vulnerabilities? We aim to identify security vulnerabilities in StackOverflow posts, because the bad practices recommended on the platform can become popular and cause profound negative impact. This effort will help raise the security consciousness of secure software practitioners.\nIn our study, we made three major observations.\n\u2022 There weremultiple security vulnerabilities in the recommended code of some accepted answers. For instance, the usage of MD5 and SHA-1 algorithms were repetitively suggested, although these algorithms are notoriously insecure and should not be used anymore. Additionally, developers were advised to trust all incoming SSL/TLS certificates from servers as a workaround to certificate verification errors. Such practice completely disables the security checks of SSL. Although this bad practice was initially reported by researchers in 2012 [80, 83], developers have still asked for and accepted the practice till now. Furthermore, when implementing authentication with Spring security and getting errors, developers were suggested with a workaround solution to blindly disable the default security protection against Cross Site Request Forgery (CSRF) attacks. \u2022 There were various programming challenges related to security libraries. For instance, developers were stuck with cryptography API usage due to clueless error messages, complex cross-language data handling, and delicate implicit API usage constraints. However, when using Spring security, developers struggled a lot with the two alternative ways of configuring security: Java-based or XML-based. \u2022 Software developers have shifted their security implementation effort to Spring security since 2012. 261 of the 497 examined posts (53%) were about Spring security. However, we have not seen any research that checks or analyzes the security vulnerabilities related to the framework.\nThe significance of this work is that we provided empirical evidence for a significant number of alarming secure coding issues, which have not been previously reported. These issues are due to a variety of reasons, including the rapidly increasing need for enterprise security applications, the lack of security training in the software development workforce, and poorly designed security libraries. We hope our findings can motivate the community to research solutions for helping developers overcome these obstacles in the long term."
        },
        {
            "heading": "2 BACKGROUND",
            "text": "The examined StackOverflow posts were mainly about three perspectives of Java security: Java platform security, Java EE security, and other third-party frameworks. This section introduces the key terminologies used throughout the paper."
        },
        {
            "heading": "2.1 Java Platform Security",
            "text": "The platform defines APIs spanning major security areas, including cryptography, access control, and secure communication [41].\nThe Java Cryptography Architecture (JCA) contains APIs for hashes, keys and certificates, digital signatures, and encryption [34]. Nine cryptographic engines are defined to provide either cryptographic operations (encryption, digital signatures, hashes), generators or converters of cryptographic material (keys and algorithm parameters), or objects (keystores or certificates) that encapsulate the cryptographic data.\nThe access control architecture protects the access to sensitive resources (e.g., local files) or sensitive application code (e.g., methods in a class). All access control decisions are mediated by a security manager. By default, the securitymanager uses the AccessController class for access control operations and decisions.\nSecure communication ensures that the data which travels across a network is sent to the appropriate party, without being modified during the transmission. Cryptography forms the basis for secure communication. The Java platform provides API support for standard secure communication protocols like SSL/TLS. HTTPS, or \u201cHTTP secure\u201d, is an application-specific implementation that is a combination of HTTP and SSL/TLS."
        },
        {
            "heading": "2.2 Java EE Security",
            "text": "Java EE is an standard specification for enterprise Java extensions [44]. Various application servers are built to implement this specification, such as JBoss or WildFly [71], Glassfish [18], WebSphere [69], andWebLogic [3]. A Java EE application consists of components deployed into various containers. The Java EE security specification defines that containers secure components by supporting features like authentication and authorization.\nIn particular, authentication defines how communicating entities, such as a client and a server, prove to each other that they are who they say they are. An authenticated user is issued a credential, which includes user information like usernames/passwords or tokens. Authorization ensures that users have permissions to perform operations or access data. When accessing certain resource, a user is authorized if the server can map this user to a security role permitted for the resource.\nSecurity for Java EE applications can be implemented in the following two ways:\n\u2022 Declarative Security expresses an application component\u2019s security requirements using either deployment descriptors or annotations. A deployment descriptor is an XML file external to the application. This XML file expresses an application\u2019s security structure, including security roles, access control, and authentication requirements. Annotations are used to specify security information in a class file. They can be either used by or overridden by deployment descriptors.\n\u2022 Programmatic Security is embedded in an application and is used to make security decisions, when declarative security alone is not sufficient to express the security model."
        },
        {
            "heading": "2.3 Other Third-Party Frameworks",
            "text": "Several frameworks were built to provide authentication, authorization, and other security features for enterprise applications, such as Spring Security [53]. Different from the Java EE security APIs, these frameworks are container independent, meaning that they do not require containers to implement security. For example, Spring security is installed as a single Filter in the filter chain inside a container to handle requests. There can be multiple security filters inside Spring security. Developers can configure security in an XML-based way, a Java-based way, or a hybrid of the two. Similar to Java EE security, the XML-based way implements security requirements with deployment descriptors and source code, while the Java-based way expresses security with annotations and code."
        },
        {
            "heading": "3 METHODOLOGY",
            "text": "We leveraged Scrapy\u2014an open source python library [50] to crawl posts from the StackOverflow website. Figure 1 presents the format of a typical StackOverflow post. Each post mainly contains two regions: the question and answers.\n1\u25cbQuestion region contains the question description and some metadata. The metadata includes a vote for the question (e.g., 3)\u2014 indicatingwhether the question is well-defined orwell-representative, and a favorite count (e.g., 1)\u2014showing how many people liking the question.\n2\u25cb Answer region contains all answer(s) provided. When one or more answers are provided, the asker decides which answer to accept, and marks it with (\u2713).\nWe obtained 22,195 posts containing keywords \u201cjava\u201d and \u201csecurity\u201d. After extracting the question, the answers, and relevant metadata for each post, we refined the data in three ways.\n1) Filtering less useful posts. We automatically refined posts by removing duplicated posts, posts without accepted answers, and posts whose questions received negative votes perhaps because the questions were ill-formed or confusing.\n2) Removing posts without code snippets.We only focused on posts containing code snippets to better understand the questions within the program context. Since our crawled data did not include any metadata to describe the existence of code snippets, we developed an intuitive filter to search for keywords \u201cpublic\u201d and \u201cclass\u201d in each post. Based on our observation, a post usually contains these two keywords when it includes a code snippet.\n3) Discarding irrelevant posts.After applying the above two filters, we manually examined the remaining posts, and decided whether they were relevant to Java secure coding or simply contained the checked keywords accidentally.\nWith the above three filters, we finally included 497 posts in our data set. The question asking time of these posts were during 2008-2016. We did not include the posts in 2017, because at the time we conducted experiments, there was only data for the first several months of 2017. When manually filtering retrieved posts, we also characterized relevant posts based on their security concerns, programming challenges, and security vulnerabilities. Based on the characterization, we classified posts and investigated the following three research questions (RQs):\nRQ1: What are the common security concerns of developers? We aimed to investigate: (1) what are the popular security features that developers frequently asked about, and (2) how do developers\u2019 security concerns shift over the years? Besides, we also classified posts into three categories based on the number of positive votes and favorite counts their questions received:\n\u2022 Neutral: A question does not receive a positive vote or favorite count. \u2022 Positive: A question receives at least one positive vote but zero favorite count.\n\u2022 Favorite: A question receives at least one favorite vote. The post shown in Figure 1 is classified as \u201cFavorite\u201d in this way, because its favorite count is one. By combining this category with the identified security concerns, we explore developers\u2019 sentiment towards questions related to different concerns. It is possible that although some security features are frequently asked, people do not like the questions, probably because the questions are so complicated and project-specific that most developers cannot learn or benefit from them.\nRQ2: What are the common programming challenges? For each identified security concern, we further characterized each post with the problem (buggy source code, wrongly implemented configuration files, improperly configured execution environment), the root cause and accepted solution of the problem. Then we clustered posts if they had similar characterizations. For the post in Figure 1, we identified the problem as asking for a workaround in SSL verification, because apparently the developer did not realize that the SSL verification should not be bypassed. The recommended solution was to first create a keystore that contains the certificates of all trusted SSL servers, and then use the keystore to create a TrustManagerFactory instance and establish connections.\nRQ3: What are the common security vulnerabilities? For each post, we also inspected unaccepted answers and the conversational comments between the question asker and other developers, in order to learn about the security context. Based on the\nrecommended security coding practice and the investigated security context, we decided whether the accepted solution was security vulnerable. The post shown in Figure 1 contains a secure accepted answer, although the question asker originally asked for a vulnerable implementation as an easy fix."
        },
        {
            "heading": "4 MAJOR FINDINGS",
            "text": "We present our investigation results for the research questions separately in Section 4.1-4.3."
        },
        {
            "heading": "4.1 Common Concerns in Security Coding",
            "text": "Figure 2 presents our classification hierarchy among the 497 posts. At the highest level of the hierarchy, we created two categories: implementation questions vs. understanding questions. The majority\u2014472 questions\u2014were about implementing security functionalities or solving program errors. Only 25 questions were asked to understand why certain features were designed in certain ways (e.g., how does Java string being immutable increase security [22]). Since our focus is on secure coding practice, our further classification expands on the 472 implementation-relevant posts.\nAt the second level of the classification hierarchy, we clustered posts based on the major security platforms or frameworks involved in each post. For instance, Java platform security posts were relevant to the security features of the Java platform and related software libraries extending the features (e.g., BouncyCastle [7]). Java EE security posts were related to the security mechanisms of Java EE platform, and Spring security posts were about the Spring security framework [53]. The Other category at this level includes posts relevant to other libraries or platforms, such as Shiro [4] and Android [73]. Unexpectedly, Spring security posts (261) counted for 55% of the implementation questions. However, no research exists to explore the misuse of Spring security APIs. Although there are many application servers developed to implement the Java EE specifications, developers have many fewer questions concerning Java EE security than Spring security.\nAt the third level of the classification hierarchy, we further classified posts separately belonging to the two categories: Java platform security and Spring security, because both categories contained many posts. Among the Java platform security posts, in addition to cryptography and secure communication, we identified a third major concern\u2014access control. Among the Spring security posts, we found the majority (219) related to authentication, with the minority discussing authorization and configuration.\nFinding 1: 55%, 30%, and 12% of the implementationrelevant posts focused on Spring security, Java platform security, and Java EE security, indicating that developers need more help to secure Java enterprise applications.\nBased on the second- and third-level classifications, we identified seven major security concerns: cryptography, access control, secure communication, Java EE security, authentication, authorization, and configuration. The first three concerns correspond to Java platform security, while the last three correspond to Spring security. To reveal developers\u2019 security concern trends over the years, we clustered posts based on the year when each question was asked.\nFigure 3 presents the post distribution among 2008-2016. The total number of posts increased over the years, indicating that more developers were involved with secure coding and faced problems. Specifically, there was only 1 post created in 2008, but 107 posts were created in 2016. During 2009-2011, most posts were about Java platform security. However, since 2012, the major security concern has shifted to securing Java enterprise applications (including both Java EE security and Spring security). Specifically, Spring security has taken up over 50% of the posts published every year since 2013.\nFor each security concern, we also clustered posts based on developers\u2019 attitudes towards the questions. As mentioned in Section 3, we defined three types of sentiment: neutral, positive, and favorite. Figure 4 shows the post distribution among different developers\u2019 attitudes. In this figure, configuration posts received the highest percentage of neutral opinions (50%). One possible reason is that these posts mainly focused on the problems caused by wrong versions of software libraries and version conflicts between dependent\nNeutral Posi-ve Favorite\n0% 20% 40% 60% 80% 100%\nConfigura-on\nAuthoriza-on\nAuthen-ca-on\nJava EE security\nSecure communica-on\nAccess control\nCryptography\nFigure 4: The post distribution among developers\u2019 sentiment towards the security features: neutral, positive, and favorite\nlibraries. Since such problems are usually specific to programmers\u2019 software development environments, they are not representative or relevant to many developers\u2019 security interests. In comparison, secure communication posts received the lowest percentage of neutral opinions (16%), but the highest percentage of favorite (61%), indicating that the questions were more representative, focusing more on security implementation instead of environment settings.\nFinding 2: Developers\u2019 major security concern has shifted from Java platform security to enterprise application security over the years, especially to Spring security. Compared with others, secure communication posts received the highest percentage (61%) of favorite votes, indicating that the questions are important and representative."
        },
        {
            "heading": "4.2 Common Programming Challenges",
            "text": "To understand the common challenges developers faced, we further examined the posts of the most popular five major categories: authentication (219), cryptography (64), Java EE security (58), access control (43), and secure communication (31). We identified posts with similar questions and related answers, and further investigated why developers asked these common questions. This section presents our key findings for each category.\n4.2.1 Authentication. Most posts were on (1) integrating Spring security with different application servers (e.g., JBoss) [58] or frameworks (e.g., Spring MVC) [54], (2) configuring security in an XMLbased [55] or Java-based way [27], or (3) converting XML-based configurations to Java-based ones [10]. Specifically, we observed three challenges.\nChallenge 1: The way to integrate Spring security with different types of applications varies a lot. Although Spring security can be leveraged to secure various applications, the usage varies with the application settings [57]. What is even worse, some Spring securityrelevant implementations may exhibit different dynamic behaviors in different applications. For instance, by following a standard tutorial example [68], a developer defined two custom authentication filters\u2014apiAuthenticationFilter and webAuthenticationFilter\u2014to\nsecure two different sets of URLs of his/her Spring Boot web application as shown below. Listing 1: An exemplar implementation working unexpectedly in Spring Boot applications\n1 @EnableWebSecurity 2 p u b l i c c l a s s S e c u r i t yC on f i g u r a t i o n { 3 @Conf igura t ion @Order ( 1 ) 4 p u b l i c s t a t i c c l a s s Ap iCon f i gu r a t i onAdap t e r 5 ex t ends WebSecur i t yCon f i gu re rAdap t e r { 6 @Bean 7 p u b l i c G e n e r i c F i l t e r B e a n 8 a p i A u t h e n t i c a t i o n F i l t e r ( ) { . . . } 9 @Override 10 p r o t e c t e d vo id c on f i g u r e ( H t t p S e c u r i t y h t t p ) 11 throws Excep t i on { 12 h t t p . antMatcher ( \" / a p i / \u2217 \u2217 \" ) 13 . a d d F i l t e r A f t e r ( a p i A u t h e n t i c a t i o n F i l t e r ( ) . . . ) 14 . sess ionManagement ( ) . . . ; } } 15 @Conf igura t ion @Order ( 2 ) 16 p u b l i c s t a t i c c l a s s WebSecu r i t yCon f i gu r a t i on 17 ex t ends WebSecur i t yCon f i gu re rAdap t e r { 18 @Bean 19 p u b l i c G e n e r i c F i l t e r B e a n 20 we bAu t h e n t i c a t i o n F i l t e r ( ) { . . . } 21 @Override 22 p r o t e c t e d vo id c on f i g u r e ( H t t p S e c u r i t y h t t p ) 23 throws Excep t i on { 24 h t t p . antMatcher ( \" / \" ) 25 . a d d F i l t e r A f t e r ( w e bAu t h e n t i c a t i o n F i l t e r ( ) . . . ) 26 . a u t h o r i z e R e qu e s t s ( ) . . . ; } } }\nIn Listing 1, lines 3-14 correspond to ApiConfigurationAdapter, a security configuration class that specifies apiAuthenticationFilter to authenticate URLs matching the pattern \u201c/api/**\u201d. Lines 15-26 correspond to WebSecurityConfiguration, which configures webAuthenticationFilter to authenticate the other URLs. Ideally, only one filter is invoked given one URL. However, both filters were invoked in reality. The root cause is that each filter is a bean (annotated with @Bean on lines 6 and 18). Spring Boot detects the filters and adds them to a regular filter chain, while Spring security also adds them to its own filter chain. Consequently, both filters are registered twice and can be invoked twice. To solve the problem, developers need to enforce each bean to be registered only once by adding specialized code.\nChallenge 2: The two ways of security configurations (Java-based and XML-based) are hard to implement correctly. Take the Javabased configuration for example. There are lots of annotations and APIs of classes, methods, and fields available to specify different configuration options. Particularly, HttpSecurity has 10 methods, each of which can be invoked on an HttpSecurity instance and then produces another HttpSecurity object. If developers are not careful about the invocation order between these methods, they can get errors [25]. As shown in Listing 1, the method antMatcher(\"/api/**\u2019\u2019) must be invoked before addFilterAfter(...) (lines 12-13), so that the filter is only applied to URLs matching the pattern \u201c/api/**\u201d. Unfortunately, such implicit constraints are not documented in the API specifications [28].\nChallenge 3: Converting from XML-based to Java-based configurations is tedious and error-prone. The semantic conflicts between annotations, deployment descriptors, and code implementations\nare always hard to locate and resolve. Such problems become more serious when developers configure security in a hybrid way of Java-based and XML-based. Since Spring security 3.2, developers are supported to configure Spring-security in a pure Java-based approach, and there is documentation describing how to migrate from XML-based to Java-based configurations [56]. However, manually applying every migration rule to convert every configuration file is tedious and error-prone.\nFinding 3: Spring security authentication posts were mainly about configuring security for different applications or in different ways (Java-based or XML-based), and converting between these ways. The challenges were due to incomplete documentation and missing tool support for error checking, solution recommendation, and configuration generation.\n4.2.2 Cryptography. Many posts were about key generation and usage. For instance, some posts discussed how to create a key from scratch [38], or how to generate or retrieve a key from a random number [26], a byte array [12], a string [15], a certificate [17], BigIntegers [6], a keystore [5], or a file [67]. Some other posts focused on how to compare keys [9], print key information [66], or initialize a cipher for encryption and decryption [39]. Specifically, we observed three common challenges of correctly using the cryptography APIs.\nChallenge 1: The error messages did not provide sufficient useful hints about fixes. We found five posts concentrated on the same problem: \u201cget InvalidKeyException: Illegal key size\u201d, while the solutions were almost identical: (1) download the \u201cJava Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files\u201d, \u201clocal_policy.jar\u201d, and \u201cUS_export_policy.jar\u201d; and (2) place the policy files in proper folders [1]. Developers got the same exception because of missing either of the two steps. Providing a checklist of these necessary steps in the error message could help developers quickly resolve the problem. However, the existing error messages did not provide any constructive suggestion.\nChallenge 2: It is difficult to implement security with multiple programming languages. Three posts were about encrypting data with one language (e.g. PHP or Python) and decrypting data with another language (e.g., Java). Such cross-language data encryption & decryption is challenging, because the format of the generated data by one language requires special handling of another language. Listing 2 is an example to generate an RSA key pair and encrypt data in PHP, and to decrypt data in Java [16].\nListing 2: Encryption in PHP and decryption in Java 1 // *****keypair.php ***** 2 i f ( f i l e _ e x i s t s ( ' p r i v a t e . key ' ) ) { 3 echo f i l e _ g e t _ c o n t e n t s ( ' p r i v a t e . key ' ) ; } 4 e l s e { 5 i n c l u d e ( ' Crypt / RSA . php ' ) ; 6 $ r s a = new Crypt_RSA ( ) ; 7 $ r e s = $rsa \u2212>c r ea t eKey ( ) ; 8 $p r i v a t eKey = $ r e s [ ' p r i v a t ek ey ' ] ; 9 $pub l i cKey = $ r e s [ ' pub l i ckey ' ] ; 10 f i l e _ p u t _ c o n t e n t s ( ' pu b l i c . key ' , $ pub l i cKey ) ; 11 f i l e _ p u t _ c o n t e n t s ( ' p r i v a t e . key ' , $ p r i v a t eKey ) ; } 12 // *****encrypt.php *****\n13 i n c l u d e ( ' Crypt / RSA . php ' ) ; 14 $ r s a = new Crypt_RSA ( ) ; 15 $rsa \u2212>se tEncryp t ionMode ( CRYPT_RSA_ENCRYPTION_OAEP ) ; 16 $rsa \u2212>loadKey ( f i l e _ g e t _ c o n t e n t s ( ' pu b l i c . key ' ) ) ; 17 // *****MainClass.java ***** 18 BASE64Decoder decoder =new BASE64Decoder ( ) ; 19 S t r i n g b64P r i v a t eKey = ge tCon t en t s ( 20 \" h t t p : / / l o c a l h o s t / a p i / k eypa i r . php \" ) . t r im ( ) ; 21 by te [ ] decodedKey=decoder . d e codeBu f f e r ( b 64P r i v a t eKey ) ; 22 Bu f f e r e dReade r br=new Bu f f e r edReade r ( 23 new S t r i n gRe ad e r ( new S t r i n g ( decodedKey ) ) ) ; 24 PEMReader pr=new PEMReader ( br ) ; 25 KeyPa i r kp =( KeyPa i r ) pr . r e a dOb j e c t ( ) ; 26 pr . c l o s e ( ) ; 27 P r i v a t eKey p r i v a t eKey =kp . g e t P r i v a t e ( ) ; 28 Cipher c i p h e r =Cipher . g e t I n s t a n c e ( 29 \"RSA / None / OAEPWithSHA1AndMGF1Padding \" , \" BC \" ) ; 30 c i p h e r . i n i t ( C ipher . DECRYPT_MODE , p r i v a t eKey ) ; 31 by te [ ] p l a i n t e x t = c i p h e r . d o F i n a l ( c i p h e r ) ;\nIn this example, when a key pair is generated in PHP (lines 2-11), the public key is easy to retrieve in PHP (lines 13-16). However, retrieving the private key in Java is more complicated (lines 18-30). After reading in the private key string (lines 19-20), the Java implementation first uses Base64Decoder to decode the string into a byte array (line 21), which corresponds to an OpenSSL PEM encoded stream (line 22-23). Because OpenSSL PEM is not a standard data format, the Java code further uses a PEMReader to convert the stream to a PrivateKey instance (lines 24-27) before using the key to initialize a cipher (lines 28-30). Existing documentation seldom describes how the security data format (e.g., key) defined in one language corresponds to that of another language. Unless developers are experts in both languages, it is hard for them to figure out the security data processing across languages.\nChallenge 3: Implicit constraints on API usage cause confusion. Two posts were about getting \u201cInvalidKeySpecException: algid parse error, not a sequence\u201d, when obtaining a private key from a file [30]. The problem is that the key should be in PKCS#8 format when used to create a PKCS8EncodedKeySpec instance, as shown below:\nListing 3: Consistency between the key format and keyspec 1 / / pr ivKey shou ld be in PKCS#8 format 2 by te [ ] pr ivKey = . . . ; 3 PKCS8EncodedKeySpec keySpec= 4 new PKCS8EncodedKeySpec ( pr ivKey ) ;\nThe tricky part here is that a private key retrieved from a file always has the data type byte[] even if it is not in PKCS#8 format. If developers invoke the API PKCS8EncodedKeySpec(...) with a non-PKCS#8 formatted key, they will be stuck with the clueless exception. Three solutions were suggested to get a PKCS#8 format key: (1) to implement code to convert the byte array, (2) to use an openssl command to convert the file format, or (3) to use the PEMReader class of BouncyCastle to generate a key from the file. Such implicit constraints between an API and its input format are delicate.\nFinding 4: The cryptography posts were majorly about key generation and usage. Developers asked these questions mainly due to clueless error messages, cross-language data handling, and implicit API usage constraints.\n4.2.3 Java EE security. 33 of the 58 posts were on authentication and authorization. However, the APIs of these two security features were defined differently on different application servers (e.g., WildFly and Glassfish), and developers might use these servers in combination with diverse third-party libraries [48]. As a result, the posts seldom shared common solutions or code implementation.\nOne common challenge we identified is the usage of declarative security and programmatic security. When developers misunderstood annotations, they could use incorrect annotations that conflict with other annotations [35], deployment descriptors [72], code implementation [11], or file paths [47]. Nevertheless, existing error reporting systems only throw exceptions. Unfortunately, there is no tool support that prevents developers from configuring such conflicting settings, or assists developers with diagnosing conflicting usage of annotations and deployment descriptors.\nFinding 5: Java EE security posts were mainly about authentication and authorization. One challenge is the complex usage of declarative security and programmatic security, and any complicated interaction between the two.\n4.2.4 Access Control. The 43 posts mainly discussed how to restrict or relax the access permission(s) of a software application for certain resource(s).\nSpecifically, 21 questions asked about restricting untrusted code from accessing certain packages [40], classes [42], or class members (i.e., methods and fields) [20]. Two alternative solutions were commonly suggested for these questions: (1) to override the checkXXX() methods of SecurityManager to disallow invalid accesses, or (2) to define a custom policy file to grant limited permissions. Another nine posts were on how to allow applets to perform privileged operations [52], because applets are executed in a security sandbox by default and can only perform a set of safe operations. One commonly recommended solution was to digitally sign the applet. Although it seems that there exist common solutions to the most frequently asked questions, the access control implementation is not always intuitive. We identified two common challenges of correctly implementing access control.\nChallenge 1: The effect of access control varies with the program context. We identified two typical scenarios from multiple similar posts. First, the RMI tutorial [29] suggested that a security manager is needed only when RMI code downloads code from a remote machine. Including a SecurityManager instance in the RMI program which does not download any code can cause an AccessControlException [37]. Second, although a signed applet is allowed to perform sensitive operations, it loses its privileges when invoked from Javascript [21]. As a result, the invocation to the signed applet should be wrapped with an invocation of AccessController. doPrivileged(...).\nChallenge 2: The effect of access control varies with the execution environment. SecurityManager can disallow illegal accesses via reflection only when the program is executed in a controlled environment (i.e., on a trusted server) [8]. Nevertheless, if the program is executed in an uncontrolled environment (e.g. on an untrusted client machine) and hackers can control how to run the program or manipulate the jar file, the security mechanisms become voided.\nFinding 6: The access control posts were mainly about SecurityManager, AccessController, and the policy file. Configuring and customizing access control policies are challenging.\n4.2.5 Secure Communication. Among the 31 examined posts, 22 posts were about SSL/TLS-related issues, discussing how to create [59], install [64], find [43], or validate an SSL certificate [61], how to establish a secure connection [36], and how to use SSL together with other libraries, such as JNDI [23] and PowerMock [70].\nIn particular, six posts focused on solving the problem of unable to find a valid server certificate to establish an SSL connection with a server [43]. Instead of suggesting a way to install the required certificates, two accepted answers suggested a highly insecure workaround to disable the SSL verification process, so that any incoming certificate can pass the validation [60]. Although such workarounds can effectively remove the error, they essentially fail the requirement to secure communication with SSL. In Section 4.3, we will further explain the security vulnerability due to such workarounds. Probably developers tended to accept the vulnerable answers because they felt it challenging to implement the whole process of creating, installing, finding, and validating an SSL certificate.\nFinding 7: Security communication posts mainly discussed the process of establishing SSL/TLS connections. This process contains somany steps that developers were tempted to accept a broken solution to simply bypass the security check."
        },
        {
            "heading": "4.3 Common Problems from Security Perspectives",
            "text": "Among the five categories listed in Section 4.2, we identified security vulnerabilities in the accepted answers of three frequently discussed topics: Spring security\u2019s csrf(), SSL/TLS, and password hashing.\n4.3.1 Spring security\u2019s csrf(). Cross-site request forgery (CSRF) is a serious attack that tricks a web browser into executing an unwanted action (e.g., transfer money to another account) in a web application (e.g., a bank website) for which a user is authenticated [102]. The root cause is that attackers created forged requests that appear to be legitimate requests, and somehow mixed them with the legitimate ones. Since the application cannot distinguish between the two types of requests, it normally responds to the forged requests, performing undesired operations.\nBy default, Spring security provides CSRF protection by defining a function csrf() and implicitly enabling the function invocation. Correspondingly, developers should include the CSRF token in all\nPATCH, POST, PUT, and DELETE methods to leverage the protection [31]. However, among the 12 examined posts that were relevant to csrf(), 5 posts discussed program failures, while all the accepted answers suggested an insecure solution: disabling the CSRF protection by invoking http.csrf().disable(). In one instance, after accepting the vulnerable solution, an asker commented as \u201cAdding csrf().disable() solved the issue!!! I have no idea why it was enabled by default\u201d [45]. Unfortunately, the developer happily disabled the security protection without realizing that such workaround would expose the resulting system to CSRF security exploits.\nFinding 8: In 5 of the 12 csrf()-relevant posts, developers took the suggestion to irresponsibly disable the default CSRF protection. Developers are unaware of the security consequences of their insecure coding.\n4.3.2 SSL/TLS. We examined 11 posts discussing the usage of SSL/TLS, and observed two important security issues.\nCer$ficate Authority\n\u2460\u202fRequest for an SSL cert.\n\u2461\u202fIssue an SSL cert.\nClient Server\n\u2462\u202fIni$ate an SSL connec$on\n\u2463\u202fSend the SSL cert.\n\u2464\u202fValidate SSL cert.\nFigure 5: Simplified overview of creating an SSL connection\nProblem 1: Developers commonly trusted all SSL certificates and\nallowed all hostnames in order to quickly build a prototype in the development environment. SSL is the standard security technology for establishing an encrypted connection between a web server and a browser. Figure 5 overviews the major steps of establishing an SSL connection [49]. To activate SSL on the server, developers need to provide all identity information of the website (e.g., the host name) to a Certification Authority (CA) and request for an SSL certificate (Step 1\u25cb). After validating the website\u2019s information, CA issues a digitally signed SSL certificate (Step 2\u25cb). When a client or browser attempts to connect to the website ((Step 3\u25cb), the server sends over its certificate (Step 4\u25cb). The client then conducts several checks, including (1) whether the certificate is issued by a CA the browser trusts, and (2) whether the request hostname matches the hostname associated with the certificate (Step 5\u25cb). If all these checks are passed, the SSL connection can be established successfully.\nAlthough ideally, developers should only enable SSL after obtaining a certificate from CA, in reality, they usually implement and test the certificate verification code before obtaining the certificate. Therefore, a well-accepted recommended solution without CA-signed certificates is to create a self-signed certificate and use the certificate to drive the implementation of SSL certificate verification [59]. However, 9 of the 11 examined posts accepted an insecure solution to bypass security checks by trusting all certificates and/or allowing all hostnames, as demonstrated by Listing 4.\nListing 4: A typical implementation to disable SSL certificate validation [51]\n1 // Create a trust manager that does not validate certificate chains 2 TrustManager [ ] t r u s t A l l C e r t s = new TrustManager [ ] { 3 new X509TrustManager ( ) { 4 p u b l i c j a v a . s e c u r i t y . c e r t . X 5 0 9 C e r t i f i c a t e [ ]\ng e tA c c e p t e d I s s u e r s ( ) { r e t u r n n u l l ; } 5 p u b l i c vo id c h e c kC l i e n tT r u s t e d ( . . . ) { } 6 p u b l i c vo id ch e ckS e r v e rT ru s t e d ( . . . ) { } } } ; 7 // Install the all-trusting trust manager 8 t r y { 9 SSLContext s c = SSLContext . g e t I n s t a n c e ( \" SSL \" ) ; 10 s c . i n i t ( nu l l , t r u s t A l l C e r t s , new j a v a . s e c u r i t y . SecureRandom ( ) ) ; 11 HttpsURLConnect ion . s e tD e f a u l t S S L S o c k e t F a c t o r y ( s c . g e t S o c k e t F a c t o r y ( ) ) ; 12 } c a t ch ( Excep t i on e ) { } 13 // Access an https URL without having the certificate in the 14 // truststore 15 t r y { 16 URL u r l =new URL ( \" h t t p s : / / hostname / index . html \" ) ; 17 } c a t ch ( MalformedURLExcept ion e ) { }\nDisabling the SSL certificate validation process in a client can thoroughly invalidate the secure communication protocol, leaving clients susceptible to the man-in-the-middle (MITM) attack [83]. Namely, by secretly relaying and possibly altering the communication (e.g., through DNS poisoning) between the client and server, attackers can trick the SSL-client to instead connect to an attacker-controlled server [83]. Although the insecure coding practice was shown to induce the MITM attack in 2012 [83], there are three examined posts created after 2012 still discussing the bad practice. This indicates a significant gap between security theory and coding practices. Some developers justified their checking-bypass logic by saying \u201cBecause I needed a quick solution for debugging purposes only. I would not use this in production due to the security concerns . . . \u201d [65]. However, as pointed by another user of StackOverflow [65] and demonstrated by prior research [80, 83], a lot of these implementations find their way into production, and have yielded radically insecure systems as a result.\nProblem 2: Developers were unaware of the best usage of SSL/TLS. TLS is SSL\u2019s successor. It is so different from SSL that the two protocols do not interoperate. To maintain the backwards compatibility with SSL 3.0 and interoperate with systems supporting SSL, most SSL/TLS implementations allow for protocol version negotiation: if a client and a server cannot connect via TLS, they will fall back to using the older protocol SSL 3.0. In 2014, M\u00f6ller et al. reported the POODLE attack which exploits the SSL 3.0 fallback [91]. Specifically, there is a design vulnerability in the way SSL 3.0 handles block cipher mode padding, which can be exploited by attackers to decrypt encrypted messages. With the POODLE attack, a hacker can intentionally trigger a TLS connection failure and force usage of SSL 3.0, allowing decryption of encrypted messages.\nEver since 2014, researchers have recommended developers to disable SSL 3.0 support and configure systems to present the SSL 3.0 fallback. The US government (NIST) mandates to ceasing usage of SSL in the protection of Federal information [19]. In reality, nevertheless, none of the 11 posts mentioned the POODLE attack.\nBoth of the two examined posts created in 2016 were about SSL usage.\nFinding 9: 9 of 11 SSL/TLS-relevant posts discussed insecure code to bypass security checks. We observed two important security threats: (1) StackOverflow contains a lot of obsolete and insecure coding practices; and (2) secure programmers are unaware of the state-of-the-art security knowledge.\n4.3.3 Password Hashing. We found six posts related to hashing passwords with MD5 or SHA-1 to store the user credentials in a database. However, these hashing functions were found insecure [99, 100]. They are vulnerable to offline dictionary attacks [14]. After obtaining a password hash H from a compromised database, a hacker can use brute-force methods to enumerate a list of password guesses, until finding the password P whose hash value is H . By impersonating a valid user to login a server, the attacker can conduct malicious behaviors. Researchers recommended key-stretching algorithms (e.g., PBKDF2, bcrypt, and scrypt) as the best practice for secure password hashing, because these algorithms are specially crafted to slow down the hash computation by orders of magnitude [74, 82, 98], which substantially increases the difficulty of dictionary attacks.\nUnfortunately, only three of the six posts (50%) mentioned the best practice in the accepted answers, indicating that many posts on secure hashing suggested insecure hash functions. We found one post which asked about using MD5 hashing in Android [46]. Within the comment conversation between developers, although people recommended to avoidMD5, the asker kept justifying his/her choice of MD5. The asker even shared a completely wrong understanding of secure hashing: \u201cThe security of hash algorithms really is MD5 (strongest) > SHA-1 > SHA-256 > SHA-512 (weakest)\u201d, although the opposite is true, which is MD5 < SHA-1 < SHA-256 < SHA-512. Among these posts, some developers misunderstood security APIs and ignored the security consequences of their security API choices. Such StackOverflow posts can have profound negative impact, because they convey the wrong information and may mislead people.\nFinding 10: Three of six hashing-relevant posts accepted vulnerable solutions as correct answers, indicating that developers were unaware of the best practice of secure programming. Their wrong knowledge or practice can propagate among StackOverflow users and negatively influence people."
        },
        {
            "heading": "5 RELATEDWORK",
            "text": "This section describes related work on analyzing, detecting, and preventing security vulnerabilities due to Java library misuse."
        },
        {
            "heading": "5.1 Analyzing Security Vulnerabilities",
            "text": "Prior studies showed that the API misuse of cryptography, SSL, and Java reflection caused many security vulnerabilities [63, 86, 88, 101]. For instance, Long identified several Java features whose misuse or improper implementation can compromise security [88]. One feature he identified is the Java reflection API which enables fields that\nare not normally accessible to be accessed and thus can cause potential vulnerabilities. Lazar et al. manually examined 269 published cryptographic vulnerabilities in the CVE database, and observed 83% of them were caused by the misuse of cryptographic libraries, including low encryption strength, insufficient randomness, and inadequate checks [86]. Veracode reported that 39% of all applications used broken or risky cryptographic algorithms [63]. The study by Yang et al. [101] is most relevant to our research. They used an advanced topic model approach, Latent Dirichlet Allocation (LDA) tuned using Genetic Algorithm (GA), to cluster security-related StackOverflow questions based on the text. They identified frequently mentioned security topics like \u201cPassword\u201d and \u201cHash\u201d for categorization purposes. In comparison, we investigate the programming challenges and security vulnerabilities among the topics. Our SE and security findings have more technical depth."
        },
        {
            "heading": "5.2 Detecting Security Vulnerabilities",
            "text": "Approaches were built to detect security vulnerabilities caused by API misuse [75, 78, 80, 81, 83, 85, 87, 94]. For instance, Egele et al. implemented a static checker for six well defined Android cryptographic API usage rules, such as \u201cDo not use ECB mode for encryption\u201d, and analyzed 11,748 Android applications for any rule violation [78]. They found 88% of the applications violating at least one checked rule. Fischer et al. extracted Android security-related code snippets from StackOverflow, and manually labeled a subset of the data as \u201csecure\u201d or \u201cinsecure\u201d [81]. The labeled data allowed them to train a classifier and efficiently judge whether a code snippet is secure or not for the whole data set. Next, they searched for code clones of the snippets in 1.3 million Android apps, and found many clones of the insecure code. Fahl et al. [80] and Georgiev et al. [83] separately implemented an attack model: man-in-themiddle attack, and detected vulnerable Android applications and popular software libraries which misused SSL APIs. Both research groups observed that developers disabled certification validation for testing with self-signed and/or trusted certificates. He et al. developed SSLINT, an automatic static analysis tool, to identify the misuse of TLS/SSL APIs in client-side applications [85].\nCompared with prior research, our study has two new contributions. First, our scope is broader. We report new challenges on secure coding practices, such as complex security configurations in Spring security, poor error messages, and multilingual programs. Second, our investigation on the online forum provides a new social and community perspective about secure coding. The unique insights cannot be discovered through analyzing code."
        },
        {
            "heading": "5.3 Preventing Security Vulnerabilities",
            "text": "Various techniques were proposed to prevent developers from implementing vulnerable code and misusing APIs [76, 77, 79, 89, 90, 97]. For example, Mettler et al. designed Joe-E\u2014a security-oriented subset of Java\u2014to support secure software development by removing any encapsulation-breaking features from Java (e.g., reflection), and by enforcing the least privilege principle (i.e., by default, each Joe-E object has no privilege to access system resources, unless another entity passes it a reference to a system resource object) [89]. Keyczar is a library designed to simplify the usage of cryptography,\nand thus to prevent API misuse [77]. Below shows how Keyczar APIs are used to decrypt data:\nListing 5: Simple decryption with Keyczar APIs 1 Cryp te r c r y p t e r =new Cryp te r ( \" / r s a k ey s \" ) ; 2 S t r i n g p l a i n t e x t = c r y p t e r . d e c ryp t ( c i p h e r t e x t ) ;\nCompared with the decryption code shown in Listing 2 (lines 18-31), this implementation is much simpler and more intuitive. All details about data format conversion and cipher initialization are hidden, while a default strong block cipher is used to properly decrypt data.\nSome approaches were developed to apply formal verification techniques and analyze the security properties of cryptographic protocol specifications [76, 90] and cryptographic API implementations [79, 97]. For instance, Protocol Composition Logic (PCL) is a logic for proving security properties, like network protocols that use public and symmetric key cryptography [76]. The logic is designed around a process calculus with actions for possible protocol steps including generating new random numbers, sending and receiving messages, and performing decryption and digital signature verification actions. The proof system consists of axioms about individual protocol actions and inference rules that yield assertions about protocols composed of multiple steps."
        },
        {
            "heading": "6 OUR RECOMMENDATIONS",
            "text": "By analyzing the StackOverflow posts relevant to Java security from both software engineering and security perspectives, we observed the gap between the intended usage of APIs and the actual problematic API usage by developers, sensed developers\u2019 frustration when they spent tremendous time figuring out the correct usage of APIs (e.g., two weeks as mentioned in [54]), and observed terrible security consequences of library misuse. Below are our recommendations based on the analysis.\nFor SecurityDevelopers. Conduct security testing to checkwhether the implemented features work as expected. Do not disable security checks (e.g., SSL certificate validation) to implement a temporary workaround in the testing or development environment. Be cautious when following the StackOverflow accepted answers to implement secure code, because these solutions may be unsafe and outdated. For administrators of StackOverflow, we recommend them to carefully handle the posts that suggest vulnerable code, because these posts can play an influential negative role when educating security programmers.\nFor Library Designers. Remove or deprecate the APIs whose security protection is broken (e.g., MD5). Design clean and helpful error reporting interfaces which show not only the error, but also the possible root causes and solutions. Design simplified APIs with strong security defenses implemented by default.\nFor Tool Builders. Develop automatic tools to diagnose security errors, locate buggy code, and suggest security patches or solutions. Build vulnerability prevention techniques that compare peer applications that use the same set of APIs to infer and warn potential misuses. Explore approaches that check and enforce the semantic consistency between security-relevant annotations, code, and configurations. Build new approaches to transform between the implementations of declarative security and programmatic security."
        },
        {
            "heading": "7 THREATS TO VALIDITY",
            "text": "This study ismainly based on ourmanual inspection of Java securityrelevant posts, so the observations may be subject to human bias. To alleviate the problem, the first author of the paper carefully inspected all posts relevant to implementation questions multiple times, while the second author also examined the posts related to security vulnerabilities (mentioned in Section 4.3) multiple times.\nTo remove posts without code snippets, we defined a filter to search for keywords \u201cpublic\u201d and \u201cclass\u201d. If a post does not contain both words, the filter automatically removes the post from our data set. This filter may incorrectly remove some relevant posts that contain code. In future, we will improve our crawling technique to keep the <code> tags around code snippets in the raw data, and then rely on these tags to filter posts more precisely.\nWe conservatively mentioned posts whose accepted answers will cause security vulnerabilities, although there might be more accepted answers that suffer from known security attacks. Due to the limited available program and environment information in each post, and our limited knowledge about frameworks and potential security attacks, we decided not to mention the suspicious posts whose accepted answers might lead to security vulnerabilities."
        },
        {
            "heading": "8 CONCLUSION",
            "text": "Our work aimed at assessing the current secure coding practices, and identifying potential gaps between theory and practice and between specification and implementation. Our analysis of hundreds of posts on the popular developer forum (StackOverflow) revealed a worrisome reality in the software development industry.\n\u2022 A substantial number of developers do not appear to understand the security implications of coding options, showing a lack of cybersecurity training. This situation creates frustration in developers, who sometimes end up choosing completely insecure-but-easy fixes. Examples of such easy fixes include using obsolete cryptographic hash functions, disabling cross-site request forgery protection, trusting all certificates in HTTPS verification, or using obsolete communication protocols. These poor coding practices, if used in production code, will seriously compromise the security of software products. \u2022 We provided substantial empirical evidences showing that APIs in Spring security (designed for enterprise security applications) are overly complicated and poorly documented, and error reports from runtime systems cause confusion. In addition, multi-language support for securing data is rather weak. The multi-language situation is common in security applications, as oftentimes the data is encrypted in one programming language (e.g., Python) and decrypted in another (e.g., Java). These issues can seriously hinder developers\u2019 productivity, resulting in great frustration and confusion. \u2022 Interestingly, we found that the social dynamics among askers and responders can impact people\u2019s security choices. Some influential posts are not secure. For example, we observed that in some cases an insecure suggestion by a user with a high reputation score was selected as the accepted answer, as opposed to the correct fix by a user with a lower reputation score [24]. Sometimes insecure answers have many\npositive StackOverflow votes (as the quick fixes indeed make error messages go away) [51], which is quite misleading.\nWe described several possible solutions to improve secure coding practices in the paper. However, efforts (e.g., workforce retraining) to correct these alarming security issues may take a while to take effect. Our future work is on building automatic or semi-automatic security bug detection and fixing tools."
        }
    ],
    "title": "Secure Coding Practices in Java: Challenges and Vulnerabilities",
    "year": 2017
}