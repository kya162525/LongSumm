{
    "abstractText": "This paper introduces Adaptive Computation Time (ACT), an algorithm that allows recurrent neural networks to learn how many computational steps to take between receiving an input and emitting an output. ACT requires minimal changes to the network architecture, is deterministic and differentiable, and does not add any noise to the parameter gradients. Experimental results are provided for four synthetic problems: determining the parity of binary vectors, applying binary logic operations, adding integers, and sorting real numbers. Overall, performance is dramatically improved by the use of ACT, which successfully adapts the number of computational steps to the requirements of the problem. We also present character-level language modelling results on the Hutter prize Wikipedia dataset. In this case ACT does not yield large gains in performance; however it does provide intriguing insight into the structure of the data, with more computation allocated to harder-to-predict transitions, such as spaces between words and ends of sentences. This suggests that ACT or other adaptive computation methods could provide a generic method for inferring segment boundaries in sequence data.",
    "authors": [
        {
            "affiliations": [],
            "name": "Alex Graves"
        }
    ],
    "id": "SP:d01bf9a8e455128485de5c7db2c25eb5203e99ec",
    "references": [
        {
            "authors": [
                "G. An"
            ],
            "title": "The effects of adding noise during backpropagation training on a generalization performance",
            "venue": "Neural Computation, 8(3):643\u2013674",
            "year": 1996
        },
        {
            "authors": [
                "D. Bahdanau",
                "K. Cho",
                "Y. Bengio"
            ],
            "title": "Neural machine translation by jointly learning to align and translate",
            "venue": "abs/1409.0473",
            "year": 2014
        },
        {
            "authors": [
                "E. Bengio",
                "P.-L. Bacon",
                "J. Pineau",
                "D. Precup"
            ],
            "title": "Conditional computation in neural networks for faster models",
            "venue": "arXiv preprint arXiv:1511.06297",
            "year": 2015
        },
        {
            "authors": [
                "D.C. Ciresan",
                "U. Meier",
                "J. Schmidhuber"
            ],
            "title": "Multi-column deep neural networks for image classification",
            "venue": "arXiv:1202.2745v1 [cs.CV]",
            "year": 2012
        },
        {
            "authors": [
                "G. Dahl",
                "D. Yu",
                "L. Deng",
                "A. Acero"
            ],
            "title": "Context-dependent pre-trained deep neural networks for large-vocabulary speech recognition",
            "venue": "Audio, Speech, and Language Processing, IEEE Transactions on,",
            "year": 2012
        },
        {
            "authors": [
                "L. Denoyer",
                "P. Gallinari"
            ],
            "title": "Deep sequential neural network",
            "venue": "arXiv preprint arXiv:1410.0510",
            "year": 2014
        },
        {
            "authors": [
                "S. Eslami",
                "N. Heess",
                "T. Weber",
                "Y. Tassa",
                "K. Kavukcuoglu",
                "G.E. Hinton"
            ],
            "title": "Attend",
            "venue": "infer, repeat: Fast scene understanding with generative models. arXiv preprint arXiv:1603.08575",
            "year": 2016
        },
        {
            "authors": [
                "A. Graves"
            ],
            "title": "Generating sequences with recurrent neural networks",
            "venue": "arXiv preprint arXiv:1308.0850",
            "year": 2013
        },
        {
            "authors": [
                "A. Graves",
                "A. Mohamed",
                "G. Hinton"
            ],
            "title": "Speech recognition with deep recurrent neural networks",
            "venue": "Acoustics, Speech and Signal Processing (ICASSP), 2013 IEEE International Conference on, pages 6645\u20136649. IEEE",
            "year": 2013
        },
        {
            "authors": [
                "A. Graves",
                "G. Wayne",
                "I. Danihelka"
            ],
            "title": "Neural turing machines",
            "venue": "arXiv preprint arXiv:1410.5401",
            "year": 2014
        },
        {
            "authors": [
                "E. Grefenstette",
                "K.M. Hermann",
                "M. Suleyman",
                "P. Blunsom"
            ],
            "title": "Learning to transduce with unbounded memory",
            "venue": "Advances in Neural Information Processing Systems, pages 1819\u20131827",
            "year": 2015
        },
        {
            "authors": [
                "K. Gregor",
                "I. Danihelka",
                "A. Graves",
                "D. Wierstra"
            ],
            "title": "Draw: A recurrent neural network for image generation",
            "venue": "arXiv preprint arXiv:1502.04623",
            "year": 2015
        },
        {
            "authors": [
                "S. Hochreiter",
                "Y. Bengio",
                "P. Frasconi"
            ],
            "title": "and J",
            "venue": "Schmidhuber. Gradient flow in recurrent nets: the difficulty of learning long-term dependencies",
            "year": 2001
        },
        {
            "authors": [
                "S. Hochreiter",
                "J. Schmidhuber"
            ],
            "title": "Long short-term memory",
            "venue": "Neural computation, 9(8):1735\u2013 1780",
            "year": 1997
        },
        {
            "authors": [
                "M. Hutter"
            ],
            "title": "Universal artificial intelligence",
            "venue": "Springer",
            "year": 2005
        },
        {
            "authors": [
                "M.A. Just",
                "P.A. Carpenter",
                "J.D. Woolley"
            ],
            "title": "Paradigms and processes in reading comprehension",
            "venue": "Journal of experimental psychology: General, 111(2):228",
            "year": 1982
        },
        {
            "authors": [
                "N. Kalchbrenner",
                "I. Danihelka",
                "A. Graves"
            ],
            "title": "Grid long short-term memory",
            "venue": "arXiv preprint arXiv:1507.01526",
            "year": 2015
        },
        {
            "authors": [
                "D. Kingma",
                "J. Ba"
            ],
            "title": "Adam: A method for stochastic optimization",
            "venue": "arXiv preprint arXiv:1412.6980",
            "year": 2014
        },
        {
            "authors": [
                "A. Krizhevsky",
                "I. Sutskever",
                "G.E. Hinton"
            ],
            "title": "Imagenet classification with deep convolutional neural networks",
            "venue": "Advances in neural information processing systems, pages 1097\u20131105",
            "year": 2012
        },
        {
            "authors": [
                "Q.V. Le",
                "T. Mikolov"
            ],
            "title": "Distributed representations of sentences and documents",
            "venue": "arXiv preprint arXiv:1405.4053",
            "year": 2014
        },
        {
            "authors": [
                "M. Li",
                "P. Vit\u00e1nyi"
            ],
            "title": "An introduction to Kolmogorov complexity and its applications",
            "venue": "Springer Science & Business Media",
            "year": 2013
        },
        {
            "authors": [
                "T. Mikolov",
                "I. Sutskever",
                "K. Chen",
                "G.S. Corrado",
                "J. Dean"
            ],
            "title": "Distributed representations of words and phrases and their compositionality",
            "venue": "Advances in neural information processing systems, pages 3111\u20133119",
            "year": 2013
        },
        {
            "authors": [
                "B.A. Olshausen"
            ],
            "title": "Emergence of simple-cell receptive field properties by learning a sparse code for natural images",
            "year": 1996
        },
        {
            "authors": [
                "B. Recht",
                "C. Re",
                "S. Wright",
                "F. Niu"
            ],
            "title": "Hogwild: A lock-free approach to parallelizing stochastic gradient descent",
            "venue": "Advances in Neural Information Processing Systems, pages 693\u2013701",
            "year": 2011
        },
        {
            "authors": [
                "S. Reed",
                "N. de Freitas"
            ],
            "title": "Neural programmer-interpreters",
            "venue": "Technical Report arXiv:1511.06279,",
            "year": 2015
        },
        {
            "authors": [
                "J. Schmidhuber"
            ],
            "title": "Self-delimiting neural networks",
            "venue": "arXiv preprint arXiv:1210.0118",
            "year": 2012
        },
        {
            "authors": [
                "J. Schmidhuber",
                "S. Hochreiter"
            ],
            "title": "Guessing can outperform many long time lag algorithms",
            "venue": "Technical report",
            "year": 1996
        },
        {
            "authors": [
                "N. Srivastava",
                "G. Hinton",
                "A. Krizhevsky",
                "I. Sutskever",
                "R. Salakhutdinov"
            ],
            "title": "Dropout: A simple way to prevent neural networks from overfitting",
            "venue": "The Journal of Machine Learning Research, 15(1):1929\u20131958",
            "year": 2014
        },
        {
            "authors": [
                "R.K. Srivastava",
                "K. Greff",
                "J. Schmidhuber"
            ],
            "title": "Training very deep networks",
            "venue": "Advances in Neural Information Processing Systems, pages 2368\u20132376",
            "year": 2015
        },
        {
            "authors": [
                "R.K. Srivastava",
                "B.R. Steunebrink",
                "J. Schmidhuber"
            ],
            "title": "First experiments with powerplay",
            "venue": "Neural Networks, 41:130\u2013136",
            "year": 2013
        },
        {
            "authors": [
                "S. Sukhbaatar",
                "J. Weston",
                "R. Fergus"
            ],
            "title": "et al",
            "venue": "End-to-end memory networks. In Advances in Neural Information Processing Systems, pages 2431\u20132439",
            "year": 2015
        },
        {
            "authors": [
                "I. Sutskever",
                "O. Vinyals",
                "Q.V. Le"
            ],
            "title": "Sequence to sequence learning with neural networks",
            "venue": "arXiv preprint arXiv:1409.3215",
            "year": 2014
        },
        {
            "authors": [
                "O. Vinyals",
                "S. Bengio",
                "M. Kudlur"
            ],
            "title": "Order matters: Sequence to sequence for sets",
            "venue": "arXiv preprint arXiv:1511.06391",
            "year": 2015
        },
        {
            "authors": [
                "O. Vinyals",
                "M. Fortunato",
                "N. Jaitly"
            ],
            "title": "Pointer networks",
            "venue": "Advances in Neural Information Processing Systems, pages 2674\u20132682",
            "year": 2015
        },
        {
            "authors": [
                "A.J. Wiles"
            ],
            "title": "Modular elliptic curves and fermats last theorem",
            "venue": "ANNALS OF MATH, 141:141",
            "year": 1995
        },
        {
            "authors": [
                "R.J. Williams",
                "D. Zipser"
            ],
            "title": "Gradient-based learning algorithms for recurrent networks and their computational complexity",
            "venue": "Back-propagation: Theory, architectures and applications, pages 433\u2013486",
            "year": 1995
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "The amount of time required to pose a problem and the amount of thought required to solve it are notoriously unrelated. Pierre de Fermat was able to write in a margin the conjecture (if not the proof) of a theorem that took three and a half centuries and reams of mathematics to solve [35]. More mundanely, we expect the effort required to find a satisfactory route between two cities, or the number of queries needed to check a particular fact, to vary greatly, and unpredictably, from case to case. Most machine learning algorithms, however, are unable to dynamically adapt the amount of computation they employ to the complexity of the task they perform.\nFor artificial neural networks, where the neurons are typically arranged in densely connected layers, an obvious measure of computation time is the number of layer-to-layer transformations the network performs. In feedforward networks this is controlled by the network depth, or number of layers stacked on top of each other. For recurrent networks, the number of transformations also depends on the length of the input sequence \u2014 which can be padded or otherwise extended to allow for extra computation. The evidence that increased depth leads to more performant networks is by now inarguable [5, 4, 19, 9], and recent results show that increased sequence length can be similarly beneficial [31, 33, 25]. However it remains necessary for the experimenter to decide a priori on the amount of computation allocated to a particular input vector or sequence. One solution is to simply\nar X\niv :1\n60 3.\n08 98\n3v 6\n[ cs\n.N E\n] 2\n1 Fe\nmake every network very deep and design its architecture in such a way as to mitigate the vanishing gradient problem [13] associated with long chains of iteration [29, 17]. However in the interests of both computational efficiency and ease of learning it seems preferable to dynamically vary the number of steps for which the network \u2018ponders\u2019 each input before emitting an output. In this case the effective depth of the network at each step along the sequence becomes a dynamic function of the inputs received so far.\nThe approach pursued here is to augment the network output with a sigmoidal halting unit whose activation determines the probability that computation should continue. The resulting halting distribution is used to define a mean-field vector for both the network output and the internal network state propagated along the sequence. A stochastic alternative would be to halt or continue according to binary samples drawn from the halting distribution\u2014a technique that has recently been applied to scene understanding with recurrent networks [7]. However the mean-field approach has the advantage of using a smooth function of the outputs and states, with no need for stochastic gradient estimates. We expect this to be particularly beneficial when long sequences of halting decisions must be made, since each decision is likely to affect all subsequent ones, and sampling noise will rapidly accumulate (as observed for policy gradient methods [36]).\nA related architecture known as Self-Delimiting Neural Networks [26, 30] employs a halting neuron to end a particular update within a large, partially activated network; in this case however a simple activation threshold is used to make the decision, and no gradient with respect to halting time is propagated. More broadly, learning when to halt can be seen as a form of conditional computing, where parts of the network are selectively enabled and disabled according to a learned policy [3, 6].\nWe would like the network to be parsimonious in its use of computation, ideally limiting itself to the minimum number of steps necessary to solve the problem. Finding this limit in its most general form would be equivalent to determining the Kolmogorov complexity of the data (and hence solving the halting problem) [21]. We therefore take the more pragmatic approach of adding a time cost to the loss function to encourage faster solutions. The network then has to learn to trade off accuracy against speed, just as a person must when making decisions under time pressure. One weakness is that the numerical weight assigned to the time cost has to be hand-chosen, and the behaviour of the network is quite sensitive to its value.\nThe rest of the paper is structured as follows: the Adaptive Computation Time algorithm is presented in Section 2, experimental results on four synthetic problems and one real-world dataset are reported in Section 3, and concluding remarks are given in Section 4."
        },
        {
            "heading": "2 Adaptive Computation Time",
            "text": "Consider a recurrent neural network R composed of a matrix of input weights Wx, a parametric state transition model S, a set of output weights Wy and an output bias by. When applied to an input sequence x = (x1, . . . , xT ), R computes the state sequence s = (s1, . . . , sT ) and the output sequence y = (y1, . . . , yT ) by iterating the following equations from t = 1 to T :\nst = S(st\u22121,Wxxt) (1) yt = Wyst + by (2)\nThe state is a fixed-size vector of real numbers containing the complete dynamic information of the network. For a standard recurrent network this is simply the vector of hidden unit activations. For a Long Short-Term Memory network (LSTM) [14], the state also contains the activations of the memory cells. For a memory augmented network such as a Neural Turing Machine (NTM) [10], the state contains both the complete state of the controller network and the complete state of the memory. In general some portions of the state (for example the NTM memory contents) will not be visible to the output units; in this case we consider the corresponding columns of Wy to be fixed to 0.\nAdaptive Computation Time (ACT) modifies the conventional setup by allowing R to perform a variable number of state transitions and compute a variable number of outputs at each input step. Let N(t) be the total number of updates performed at step t. Then define the intermediate state sequence (s1t , . . . , s N(t) t ) and intermediate output sequence (y 1 t , . . . , y N(t) t ) at step t as follows\nsnt = { S(st\u22121, x1t ) if n = 1 S(sn\u22121t , xnt ) otherwise\n(3)\nynt = Wys n t + by (4)\nwhere xnt = xt + \u03b4n,1 is the input at time t augmented with a binary flag that indicates whether the input step has just been incremented, allowing the network to distinguish between repeated inputs and repeated computations for the same input. Note that the same state function is used for all state transitions (intermediate or otherwise), and similarly the output weights and bias are shared for all outputs. It would also be possible to use different state and output parameters for each intermediate step; however doing so would cloud the distinction between increasing the number of parameters and increasing the number of computational steps. We leave this for future work.\nTo determine how many updates R performs at each input step an extra sigmoidal halting unit h is added to the network output, with associated weight matrix Wh and bias bh:\nhnt = \u03c3 (Whs n t + bh) (5)\nAs with the output weights, some columns of Wh may be fixed to zero to give selective access to the network state. The activation of the halting unit is then used to determine the halting probability pnt of the intermediate steps:\npnt =\n{ R(t) if n = N(t)\nhnt otherwise (6)\nwhere\nN(t) = min{n\u2032 : n\u2032\u2211\nn=1\nhnt >= 1\u2212 } (7)\nthe remainder R(t) is defined as follows\nR(t) = 1\u2212 N(t)\u22121\u2211 n=1 hnt (8)\nand is a small constant (0.01 for the experiments in this paper), whose purpose is to allow computation to halt after a single update if h1t >= 1 \u2212 , as otherwise a minimum of two updates would be required for every input step. It follows directly from the definition that \u2211N(t) n=1 p n t = 1 and 0 \u2264 pnt \u2264 1 \u2200n, so this is a valid probability distribution. A similar distribution was recently used to define differentiable push and pop operations for neural stacks and queues [11].\nAt this point we could proceed stochastically by sampling n\u0302 from pnt and setting st = s n\u0302 t , y t = yn\u0302t . However we will eschew sampling techniques and the associated problems of noisy gradients, instead using pnt to determine mean-field updates for the states and outputs:\nst = N(t)\u2211 n=1 pnt s n t yt = N(t)\u2211 n=1 pnt y n t (9)\nThe implicit assumption is that the states and outputs are approximately linear, in the sense that a linear interpolation between a pair of state or output vectors will also interpolate between the\nproperties the vectors embody. There are several reasons to believe that such an assumption is reasonable. Firstly, it has been observed that the high-dimensional representations present in neural networks naturally tend to behave in a linear way [32, 20], even remaining consistent under arithmetic operations such as addition and subtraction [22]. Secondly, neural networks have been successfully trained under a wide range of adversarial regularisation constraints, including sparse internal states [23], stochastically masked units [28] and randomly perturbed weights [1]. This leads us to believe that the relatively benign constraint of approximately linear representations will not be too damaging. Thirdly, as training converges, the tendency for both mean-field and stochastic latent variables is to concentrate all the probability mass on a single value. In this case that yields a standard RNN with each input duplicated a variable, but deterministic, number of times, rendering the linearity assumption irrelevant.\nA diagram of the unrolled computation graph of a standard RNN is illustrated in Figure 1, while Figure 2 provides the equivalent diagram for an RNN trained with ACT."
        },
        {
            "heading": "2.1 Limiting Computation Time",
            "text": "If no constraints are placed on the number of updates R can take at each step it will naturally tend to \u2018ponder\u2019 each input for as long as possible (so as to avoid making predictions and incurring errors). We therefore require a way of limiting the amount of computation the network performs. Given a length T input sequence x, define the ponder sequence (\u03c11, . . . , \u03c1T ) of R as\n\u03c1t = N(t) +R(t) (10)\nand the ponder cost P(x) as\nP(x) = T\u2211\nt=1\n\u03c1t (11)\nSince R(t) \u2208 (0, 1), P(x) is an upper bound on the (non-differentiable) property we ultimately want to reduce, namely the total computation \u2211T t=1N(t) during the sequence\n1. We can encourage the network to minimise P(x) by modifying the sequence loss function L(x,y) used for training: L\u0302(x,y) = L(x,y) + \u03c4P(x) (12)\nwhere \u03c4 is a time penalty parameter that weights the relative cost of computation versus error. As we will see in the experiments section the behaviour of the network is quite sensitive to the value of \u03c4 , and it is not obvious how to choose a good value. If computation time and prediction error can be meaningfully equated (for example if the relative financial cost of both were known) a more principled technique for selecting \u03c4 should be possible.\nTo prevent very long sequences at the beginning of training (while the network is learning how to use the halting unit) the bias term bh can be initialised to a positive value. In addition, a hard limit M on the maximum allowed value of N(t) can be imposed to avoid excessive space and time costs. In this case Equation (7) is modified to\nN(t) = min{M,min{n\u2032 : n\u2032\u2211\nn=1\nhnt >= 1\u2212 }} (13)"
        },
        {
            "heading": "2.2 Error Gradients",
            "text": "The ponder costs \u03c1t are discontinuous with respect to the halting probabilities at the points where N(t) increments or decrements (that is, when the summed probability mass up to some n either decreases below or increases above 1 \u2212 ). However they are continuous away from those points, as N(t) remains constant and R(t) is a linear function of the probabilities. In practice we simply ignore the discontinuities by treating N(t) as constant and minimising R(t) everywhere.\nGiven this approximation, the gradient of the ponder cost with respect to the halting activations is straightforward:\n\u2202P(x) \u2202hnt =\n{ 0 if n = N(t)\n\u22121 otherwise (14)\n1For a stochastic ACT network, a more natural halting distribution than the one described in Equations (6) to (8)\nwould be to simply treat hnt as the probability of halting at step n, in which case p n t = h n t \u220fn\u22121 n\u2032=1(1\u2212h n\u2032 t ). One could\nthen set \u03c1t = \u2211N(t) n=1 np n t \u2014 i.e. the expected ponder time under the stochastic distribution. However experiments show that networks trained to minimise expected rather than total halting time learn to \u2018cheat\u2019 in the following ingenious way: they set h1t to a value just below the halting threshold, then keep h n t = 0 until some N(t) when they set h N(t) t high enough to ensure they halt. In this case p N(t) t p1t , so the states and outputs at n = N(t) have much lower weight in the mean field updates (Equation (9)) than those at n = 1; however by making the magnitudes of the states and output vectors much larger at N(t) than n = 1 the network can still ensure that the update is dominated by the final vectors, despite having paid a low ponder penalty.\nand hence \u2202L\u0302(x,y) \u2202hnt = \u2202L(x,y) \u2202hnt \u2212\n{ 0 if n = N(t)\n\u03c4 otherwise (15)\nThe halting activations only influence L via their effect on the halting probabilities, therefore\n\u2202L(x,y) \u2202hnt = N(t)\u2211 n\u2032=1 \u2202L(x,y) \u2202pn \u2032 t \u2202pn \u2032 t \u2202hnt (16)\nFurthermore, since the halting probabilities only influence L via their effect on the states and outputs, it follows from Equation (9) that\n\u2202L(x,y) \u2202pnt = \u2202L(x,y) \u2202yt ynt + \u2202L(x,y) \u2202st snt (17)\nwhile, from Equations (6) and (8)\n\u2202pn \u2032\nt\n\u2202hnt =  \u03b4n,n\u2032 if n \u2032 < N(t) and n < N(t)\n\u22121 if n\u2032 = N(t) and n < N(t) 0 if n = N(t)\n(18)\nCombining Equations (15), (17) and (18) gives, for n < N(t)\n\u2202L\u0302(x,y) \u2202hnt = \u2202L(x,y) \u2202yt\n( ynt \u2212 y N(t) t ) + \u2202L(x,y) \u2202st ( snt \u2212 s N(t) t ) \u2212 \u03c4 (19)\nwhile for n = N(t)\n\u2202L\u0302(x,y) \u2202h\nN(t) t\n= 0 (20)\nThereafter the network can be differentiated as usual (e.g. with backpropagation through time [36]) and trained with gradient descent."
        },
        {
            "heading": "3 Experiments",
            "text": "We tested recurrent neural networks (RNNs) with and without ACT on four synthetic tasks and one real-world language processing task. LSTM was used as the network architecture for all experiments except one, where a simple RNN was used. However we stress that ACT is equally applicable to any recurrent architecture.\nAll the tasks were supervised learning problems with discrete targets and cross-entropy loss. The data for the synthetic tasks was generated online and cross-validation was therefore not needed. Similarly, the character prediction dataset was sufficiently large that the network did not overfit. The performance metric for the synthetic tasks was the sequence error rate: the fraction of examples where any mistakes were made in the complete output sequence. This metric is useful as it is trivial to evaluate without decoding. For character prediction the metric was the average log-loss of the output predictions, in units of bits per character.\nMost of the training parameters were fixed for all experiments: Adam [18] was used for optimisation with a learning rate of 10\u22124, the Hogwild! algorithm [24] was used for asynchronous training with 16 threads; the initial halting unit bias bh mentioned in Equation (5) was 1; the term from Equation (7) was 0.01. The synthetic tasks were all trained for 1M iterations, where an iteration\nis defined as a weight update on a single thread (hence the total number of weight updates is approximately 16 times the number of iterations). The character prediction task was trained for 10K iterations. Early stopping was not used for any of the experiments.\nA logarithmic grid search over time penalties was performed for each experiment, with 20 randomly initialised networks trained for each value of \u03c4 . For the synthetic problems the range of the grid search was from i\u00d7 10\u2212j with integer i in the range 1\u201310 and the exponent j in the range 1\u20134. For the language modelling task, which took many days to complete, the range of j was limited to 1\u20133 to reduce training time (lower values of \u03c4 , which naturally induce more pondering, tend to give greater data efficiency but slower wall clock training time).\nUnless otherwise stated the maximum computation time M (Equation (13)) was set to 100. In all experiments the networks converged on learned values of N(t) that were far less than M , which functions mainly as safeguard against excessively long ponder times early in training."
        },
        {
            "heading": "3.1 Parity",
            "text": "Determining the parity of a sequence of binary numbers is a trivial task for a recurrent neural network [27], which simply needs to implement an internal switch that changes sign every time a one is received. For shallow feedforward networks receiving the entire sequence in one vector, however, the number of distinct input patterns, and hence difficulty of the task, grows exponentially with the number of bits. We gauged the ability of ACT to infer an inherently sequential algorithm from statically presented data by presenting large binary vectors to the network and asking it to determine the parity. By varying the number of binary bits for which parity must be calculated we were also able to assess ACT\u2019s ability to adapt the amount of computation to the difficulty of the vector.\nThe input vectors had 64 elements, of which a random number from 1 to 64 were randomly set to 1 or \u22121 and the rest were set to 0. The corresponding target was 1 if there was an odd number of ones and 0 if there was an even number of ones. Each training sequence consisted of a single input and target vector, an example of which is shown in Figure 3. The network architecture was a simple RNN with a single hidden layer containing 128 tanh units and a single sigmoidal output unit, trained with binary cross-entropy loss on minibatches of size 128. Note that without ACT the recurrent connection in the hidden layer was never used since the data had no sequential component, and the network reduced to a feedforward network with a single hidden layer.\nFigure 4 demonstrates that the network was unable to reliably solve the problem without ACT, with a mean of almost 40% error compared to 50% for random guessing. For penalties of 0.03 and below the mean error was below 5%. Figure 5 reveals that the solutions were both more rapid and more accurate with lower time penalties. It also highlights the relationship between the time penalty, the classification error rate and the average ponder time per input. The variance in ponder time for low \u03c4 networks is very high, indicating that many correct solutions with widely varying runtime can be discovered. We speculate that progressively higher \u03c4 values lead the network to compute\nthe parities of successively larger chunks of the input vector at each ponder step, then iteratively combine these calculations to obtain the parity of the complete vector.\nFigure 6 shows that for the networks without ACT and those with overly high time penalties, the error rate increases sharply with the difficulty of the task (where difficulty is defined as the number of bits whose parity must be determined), while the amount of ponder remains roughly constant. For the more successful networks, with intermediate \u03c4 values, ponder time appears to grow linearly with difficulty, with a slope that generally increases as \u03c4 decreases. Even for the best networks the error rate increased somewhat with difficulty. For some of the lowest \u03c4 networks there is a dramatic increase in ponder after about 32 bits, suggesting an inefficient algorithm."
        },
        {
            "heading": "3.2 Logic",
            "text": "Like parity, the logic task tests if an RNN with ACT can sequentially process a static vector. Unlike parity it also requires the network to internally transfer information across successive input timesteps, thereby testing whether ACT can propagate coherent internal states.\nEach input sequence consists of a random number from 1 to 10 of size 102 input vectors. The first two elements of each input represent a pair of binary numbers; the remainder of the vector is divided up into 10 chunks of size 10. The first B chunks, where B is a random number from\n1 to 10, contain one-hot representations of randomly chosen numbers between 1 and 10; each of these numbers correspond to an index into the subset of binary logic gates whose truth tables are listed in Table 1. The remaining 10 \u2212 B chunks were zeroed to indicate that no further binary operations were defined for that vector. The binary target bB+1 for each input is the truth value yielded by recursively applying the B binary gates in the vector to the two initial bits b1, b0. That is for 1 \u2264 b \u2264 B:\nbi+1 = Ti(bi, bi\u22121) (21)\nwhere Ti(., .) is the truth table indexed by chunk i in the input vector. For the first vector in the sequence, the two input bits b0, b1 were randomly chosen to be false (0) or true (1) and assigned to the first two elements in the vector. For subsequent vectors, only b1 was random, while b0 was implicitly equal to the target bit from the previous vector (for the purposes of calculating the current target bit), but was always set to zero in the input vector. To solve the task, the network therefore had to learn both how to calculate the sequence of binary operations represented by the chunks in each vector, and how to carry the final output of that sequence over to the next timestep. An example input-target sequence pair is shown in Figure 7.\nThe network architecture was single-layer LSTM with 128 cells. The output was a single sigmoidal unit, trained with binary cross-entropy, and the minibatch size was 16.\nFigure 8 shows that the network reaches a minimum sequence error rate of around 0.2 without ACT (compared to 0.5 for random guessing), and virtually zero error for all \u03c4 \u2264 0.01. From Figure 9 it can be seen that low \u03c4 ACT networks solve the task very quickly, requiring about 10,000 training iterations. For higher \u03c4 values ponder time reduces to 1, at which point the networks trained with ACT behave identically to those without. For lower \u03c4 values, the spread of ponder values, and hence computational cost, is quite large. Again we speculate that this is due to the network learning more or less \u2018chunked\u2019 solutions in which composite truth table are learned for multiple successive logic operations. This is somewhat supported by the clustering of the lowest \u03c4 networks around a ponder time of 5\u20136, which is approximately the mean number of logic gates applied per sequence,\nand hence the minimum number of computations the network would need if calculating single binary operations at a time.\nFigure 10 shows a surprisingly high ponder time for the least difficult inputs, with some networks taking more than 10 steps to evaluate a single logic gate. From 5 to 10 logic gates, ponder gradually increases with difficulty as expected, suggesting that a qualitatively different solution is learned for the two regimes. This is supported by the error rates for the non ACT and high \u03c4 networks, which increase abruptly after 5 gates. It may be that 5 is the upper limit on the number of successive gates the network can learn as a single composite operation, and thereafter it is forced to apply an iterative algorithm."
        },
        {
            "heading": "3.3 Addition",
            "text": "The addition task presents the network with a input sequence of 1 to 5 size 50 input vectors. Each vector represents a D digit number, where D is drawn randomly from 1 to 5, and each digit is drawn randomly from 0 to 9. The first 10D elements of the vector are a concatenation of one-hot encodings of the D digits in the number, and the remainder of the vector is set to 0. The required output is the cumulative sum of all inputs up to the current one, represented as a set of 6 simultaneous classifications for the 6 possible digits in the sum. There is no target for the first vector in the sequence, as no sums have yet been calculated. Because the previous sum must be carried over by the network, this task again requires the internal state of the network to remain coherent. Each classification is modelled by a size 11 softmax, where the first 10 classes are the digits and the 11th is a special marker used to indicate that the number is complete. An example input-target pair is shown in Figure 11.\nThe network was single-layer LSTM with 512 memory cells. The loss function was the joint cross-entropy of all 6 targets at each time-step where targets were present and the minibatch size\nwas 32. The maximum ponder M was set to 20 for this task, as it was found that some networks had very high ponder times early in training.\nThe results in Figure 12 show that the task was perfectly solved by the ACT networks for all values of \u03c4 in the grid search. Unusually, networks with higher \u03c4 solved the problem with fewer training examples. Figure 14 demonstrates that the relationship between the ponder time and the number of digits was approximately linear for most of the ACT networks, and that for the most efficient networks (with the highest \u03c4 values) the slope of the line was close to 1, which matches our expectations that an efficient long addition algorithm should need one computation step per digit.\nFigure 15 shows how the ponder time is distributed during individual addition sequences, providing further evidence of an approximately linear-time long addition algorithm."
        },
        {
            "heading": "3.4 Sort",
            "text": "The sort task requires the network to sort sequences of 2 to 15 numbers drawn from a standard normal distribution in ascending order. The experiments considered so far have been designed to favour ACT by compressing sequential information into single vectors, and thereby requiring the use of multiple computation steps to unpack them. For the sort task a more natural sequential representation was used: the random numbers were presented one at a time as inputs, and the required output was the sequence of indices into the number sequence placed in sorted order; an example is shown in Figure 16. We were particularly curious to see how the number of ponder steps scaled with the number of elements to be sorted, knowing that efficient sorting algorithms have O(N logN) computational cost.\nThe network was single-layer LSTM with 512 cells. The output layer was a size 15 softmax,\ntrained with cross-entropy to classify the indices of the sorted inputs. The minibatch size was 16. Figure 17 shows that the advantage of using ACT is less dramatic for this task than the previous three, but still substantial (from around 12% error without ACT to around 6% for the best \u03c4 value). However from Figure 18 it is clear that these gains come at a heavy computational cost, with the best networks requiring roughly 9 times as much computation as those without ACT. Not surprisingly, Figure 19 shows that the error rate grew rapidly with the sequence length for all networks. It also indicates that the better networks had a sublinear growth in computations per input step with sequence length, though whether this indicates a logarithmic time algorithm is unclear. One problem with the sort task was that the Gaussian samples were sometimes very close together, making it hard for the network to determine which was greater; enforcing a minimum separation between successive values would probably be beneficial.\nFigure 20 shows the ponder time during three sort sequences of varying length. As can be seen, there is a large spike in ponder time near (though not precisely at) the end of the input sequence, presumably when the majority of the sort comparisons take place. Note that the spike is much higher for the longer two sequences than the length 5 one, again pointing to an algorithm that is nonlinear\nin sequence length (the average ponder per timestep is nonetheless lower for longer sequences, as little pondering is done away from the spike.)."
        },
        {
            "heading": "3.5 Wikipedia Character Prediction",
            "text": "The Wikipedia task is character prediction on text drawn from the Hutter prize Wikipedia dataset [15]. Following previous RNN experiments on the same data [8], the raw unicode text was used, including XML tags and markup characters, with one byte presented per input timestep and the next byte predicted as a target. No validation set was used for early stopping, as the networks were unable to overfit the data, and all error rates are recorded on the training set. Sequences of 500 consecutive bytes were randomly chosen from the training set and presented to the network, whose internal state was reset to 0 at the start of each sequence.\nLSTM networks were used with a single layer of 1500 cells and a size 256 softmax classification layer. As can be seen from Figures 21 and 22, the error rates are fairly similar with and without ACT, and across values of \u03c4 (although the learning curves suggest that the ACT networks are somewhat more data efficient). Furthermore the amount of ponder per input is much lower than for the other problems, suggesting that the advantages of extra computation were slight for this task.\nHowever Figure 23 reveals an intriguing pattern of ponder allocation while processing a sequence. Character prediction networks trained with ACT consistently pause at spaces between words, and pause for longer at \u2018boundary\u2019 characters such as commas and full stops. We speculate that the extra computation is used to make predictions about the next \u2018chunk\u2019 in the data (word, sentence, clause), much as humans have been found to do in self-paced reading experiments [16]. This suggests that ACT could be useful for inferring implicit boundaries or transitions in sequence data. Alternative measures for inferring transitions include the next-step prediction loss and predictive entropy, both of which tend to increase during harder predictions. However, as can be seen from the figure, they\nare a less reliable indicator of boundaries, and are not likely to increase at points such as full stops and commas, as these are invariably followed by space characters. More generally, loss and entropy only indicate the difficulty of the current prediction, not the degree to which the current input is likely to impact future predictions.\nFurthermore Figure 24 reveals that, as well as being an effective detector of non-text transition markers such as the opening brackets of XML tags, ACT does not increase computation time during random or fundamentally unpredictable sequences like the two ID numbers. This is unsurprising, as doing so will not improve its predictions. In contrast, both entropy and loss are inevitably high for unpredictable data. We are therefore hopeful that computation time will provide a better way to distinguish between structure and noise (or at least data perceived by the network as structure or noise) than existing measures of predictive difficulty."
        },
        {
            "heading": "4 Conclusion",
            "text": "This paper has introduced Adaptive Computation time (ACT), a method that allows recurrent neural networks to learn how many updates to perform for each input they receive. Experiments on\nCreated using the same network as Figure 23.\nsynthetic data prove that ACT can make otherwise inaccessible problems straightforward for RNNs to learn, and that it is able to dynamically adapt the amount of computation it uses to the demands of the data. An experiment on real data suggests that the allocation of computation steps learned by ACT can yield insight into both the structure of the data and the computational demands of predicting it.\nACT promises to be particularly interesting for recurrent architectures containing soft attention modules [2, 10, 34, 12], which it could enable to dynamically adapt the number of glances or internal operations they perform at each time-step.\nOne weakness of the current algorithm is that it is quite sensitive to the time penalty parameter that controls the relative cost of computation time versus prediction error. An important direction for future work will be to find ways of automatically determining and adapting the trade-off between accuracy and speed."
        },
        {
            "heading": "Acknowledgments",
            "text": "The author wishes to thank Ivo Danihleka, Greg Wayne, Tim Harley, Malcolm Reynolds, Jacob Menick, Oriol Vinyals, Joel Leibo, Koray Kavukcuoglu and many others on the DeepMind team for valuable comments and suggestions, as well as Albert Zeyer, Martin Abadi, Dario Amodei, Eugene Brevdo and Christopher Olah for pointing out the discontinuity in the ponder cost, which was erroneously described as smooth in an earlier version of the paper."
        }
    ],
    "title": "Adaptive Computation Time for Recurrent Neural Networks",
    "year": 2017
}