{
    "abstractText": "We introduce and analyze a new algorithm for linear classification which combines Rosenblatt\u2019s perceptron algorithm with Helmbold and Warmuth\u2019s leave-one-out method. Like Vapnik\u2019s maximal-margin classifier, our algorithm takes advantage of data that are linearly separable with large margins. Compared to Vapnik\u2019s algorithm, however, ours is much simpler to implement, and much more efficient in terms of computation time. We also show that our algorithm can be efficiently used in very high dimensional spaces using kernel functions. We performed some experiments using our algorithm, and some variants of it, for classifying images of handwritten digits. The performance of our algorithm is close to, but not as good as, the performance of maximal-margin classifiers on the same problem, while saving significantly on computation time and programming effort.",
    "authors": [],
    "id": "SP:f626dcd90a902f402b631a9650b3ee328b3742b8",
    "references": [
        {
            "authors": [
                "M.A. Aizerman",
                "E.M. Braverman",
                "L.I. Rozonoer"
            ],
            "title": "Theoretical foundations of the potential function method in pattern recognition learning",
            "venue": "Automation and Remote Control,",
            "year": 1964
        },
        {
            "authors": [
                "J.K. Anlauf",
                "M. Biehl"
            ],
            "title": "The adatron: an adaptive perceptron algorithm",
            "venue": "Europhysics Letters,",
            "year": 1989
        },
        {
            "authors": [
                "H.D. Block"
            ],
            "title": "The perceptron: A model for brain functioning",
            "venue": "Reviews of Modern Physics,",
            "year": 1962
        },
        {
            "authors": [
                "B.E. Boser",
                "I.M. Guyon",
                "V.N. Vapnik"
            ],
            "title": "A training algorithm for optimal margin classifiers",
            "venue": "In Proceedings of the Fifth Annual ACM Workshop on Computational Learning Theory,",
            "year": 1992
        },
        {
            "authors": [
                "N. Cesa-Bianchi",
                "Y. Freund",
                "D. Haussler",
                "D.P. Helmbold",
                "R.E. Schapire",
                "M.K. Warmuth"
            ],
            "title": "How to use expert advice",
            "venue": "Journal of the Association for Computing Machinery,",
            "year": 1997
        },
        {
            "authors": [
                "T. Friess",
                "N. Cristianini",
                "C. Campbell"
            ],
            "title": "The kernel-adatron: A fast and simple learning procedure for support vector machines",
            "venue": "In Machine Learning: Proceedings of the Fifteenth International Conference",
            "year": 1998
        },
        {
            "authors": [
                "S.I. Gallant"
            ],
            "title": "Optimal linear discriminants",
            "venue": "In Eighth International Conference on Pattern Recognition,",
            "year": 1986
        },
        {
            "authors": [
                "D.P. Helmbold",
                "M.K. Warmuth"
            ],
            "title": "On weak learning",
            "venue": "Journal of Computer and System Sciences,",
            "year": 1995
        },
        {
            "authors": [
                "J. Kivinen",
                "M.K. Warmuth"
            ],
            "title": "Additive versus exponentiated gradient updates for linear prediction",
            "venue": "Information and Computation,",
            "year": 1997
        },
        {
            "authors": [
                "N. Klasner",
                "H.U. Simon"
            ],
            "title": "From noise-free to noise-tolerant and from on-line to batch learning",
            "venue": "In Proceedings of the Eighth Annual Conference on Computational Learning Theory,",
            "year": 1995
        },
        {
            "authors": [
                "Y. LeCun",
                "L.D. Jackel",
                "L. Bottou",
                "A. Brunot",
                "C. Cortes",
                "J.S. Denker",
                "H. Drucker",
                "I. Guyon",
                "U.A. Muller",
                "E. Sackinger",
                "P. Simard",
                "V. Vapnik"
            ],
            "title": "Comparison of learning algorithms for handwritten digit recognition",
            "venue": "In International Conference on Artificial Neural Networks,",
            "year": 1995
        },
        {
            "authors": [
                "N. Littlestone"
            ],
            "title": "From on-line to batch learning",
            "venue": "In Proceedings of the Second Annual Workshop on Computational Learning Theory,",
            "year": 1989
        },
        {
            "authors": [
                "M. Minsky",
                "S. Papert"
            ],
            "title": "Perceptrons: An Introduction to Computational Geometry",
            "year": 1969
        },
        {
            "authors": [
                "A.B.J. Novikoff"
            ],
            "title": "On convergence proofs on perceptrons",
            "venue": "In Proceedings of the Symposium on the Mathematical Theory of Automata,",
            "year": 1962
        },
        {
            "authors": [
                "F. Rosenblatt"
            ],
            "title": "The perceptron: A probabilistic model for information storage and organization in the brain",
            "venue": "Psychological Review,",
            "year": 1958
        },
        {
            "authors": [
                "F. Rosenblatt"
            ],
            "title": "Principles of Neurodynamics",
            "year": 1962
        },
        {
            "authors": [
                "J. Shawe-Taylor",
                "N. Cristianini"
            ],
            "title": "Robust bounds on generalization from the margin distribution",
            "venue": "Tech. rep. NC2-TR-1998-029,",
            "year": 1998
        },
        {
            "authors": [
                "V.N. Vapnik"
            ],
            "title": "Estimation of Dependences Based on Empirical Data. SpringerVerlag",
            "year": 1982
        },
        {
            "authors": [
                "V.N. Vapnik",
                "A.Y. Chervonenkis"
            ],
            "title": "Theory of pattern recognition. Nauka, Moscow",
            "year": 1974
        },
        {
            "authors": [
                "V.N. Vapnik"
            ],
            "title": "1998 (to appear))",
            "venue": "Statistical Learning Theory. Wiley",
            "year": 1998
        }
    ],
    "sections": [
        {
            "heading": "1. Introduction",
            "text": "One of the most influential developments in the theory of machine learning in the last few years is Vapnik\u2019s work on support vector machines (SVM) (Vapnik, 1982). Vapnik\u2019s analysis suggests the following simple method for learning complex binary classifiers. First, use some fixed mapping to map the instances into some very high dimensional space in which the two classes are linearly separable. Then use quadratic programming to find the vector that classifies all the data correctly and maximizes the margin, i.e., the minimal distance between the separating hyperplane and the instances.\nThere are two main contributions of his work. The first is a proof of a new bound on the difference between the training error and the test error of a linear classifier that maximizes the margin. The significance of this bound is that it depends only on the size of the margin (or the number of support vectors) and not on the dimension. It is superior to the bounds that can be given for arbitrary consistent linear classifiers.\nThe second contribution is a method for computing the maximal-margin classifier efficiently for some specific high dimensional mappings. This method is based on the idea of kernel functions, which are described in detail in Section 4.\nThe main part of algorithms for finding the maximal-margin classifier is a computation of a solution for a large quadratic program. The constraints in the program correspond to the training examples so their number can be very large. Much of the recent practical work on support vector machines is centered on finding efficient ways of solving these quadratic programming problems.\nIn this paper, we introduce a new and simpler algorithm for linear classification which takes advantage of data that are linearly separable with large margins. We named the new algorithm the voted-perceptron algorithm. The algorithm is based on the well known\nperceptron algorithm of Rosenblatt (1958, 1962) and a transformation of online learning algorithms to batch learning algorithms developed by Helmbold and Warmuth (1995). Moreover, following the work of Aizerman, Braverman and Rozonoer (1964), we show that kernel functions can be used with our algorithm so that we can run our algorithm efficiently in very high dimensional spaces. Our algorithm and its analysis involve little more than combining these three known methods. On the other hand, the resulting algorithm is very simple and easy to implement, and the theoretical bounds on the expected generalization error of the new algorithm are almost identical to the bounds for SVM\u2019s given by Vapnik and Chervonenkis (1974) in the linearly separable case.\nWe repeated some of the experiments performed by Cortes and Vapnik (1995) on the use of SVM on the problem of classifying handwritten digits. We tested both the votedperceptron algorithm and a variant based on averaging rather than voting. These experiments indicate that the use of kernel functions with the perceptron algorithm yields a dramatic improvement in performance, both in test accuracy and in computation time. In addition, we found that, when training time is limited, the voted-perceptron algorithm performs better than the traditional way of using the perceptron algorithm (although all methods converge eventually to roughly the same level of performance).\nRecently, Friess, Cristianini and Campbell (1998) have experimented with a different online learning algorithm called the adatron. This algorithm was suggested by Anlauf and Biehl (1989) as a method for calculating the largest margin classifier (also called the \u201cmaximally stable perceptron\u201d). They proved that their algorithm converges asymptotically to the correct solution.\nOur paper is organized as follows. In Section 2, we describe the voted perceptron algorithm. In Section 3, we derive upper bounds on the expected generalization error for both the linearly separable and inseparable cases. In Section 4, we review the method of kernels and describe how it is used in our algorithm. In Section 5, we summarize the results of our experiments on the handwritten digit recognition problem. We conclude with Section 6 in which we summarize our observations on the relations between the theory and the experiments and suggest some new open problems."
        },
        {
            "heading": "2. The Algorithm",
            "text": "We assume that all instances are points x . We use ! x ! to denote the Euclidean length of x. For most of the paper, we assume that labels \" are in # $&% ')(*% + .\nThe basis of our study is the classical perceptron algorithm invented by Rosenblatt (1958, 1962). This is a very simple algorithm most naturally studied in the online learning model. The online perceptron algorithm starts with an initial zero prediction vector ,.-0/ . It predicts the label of a new instance x to be 1\"2- sign 3 ,54 x 6 . If this prediction differs from the label \" , it updates the prediction vector to , -7,8(9\" x. If the prediction is correct then, is not changed. The process then repeats with the next example.\nThe most common way the perceptron algorithm is used for learning from a batch of training examples is to run the algorithm repeatedly through the training set until it finds a prediction vector which is correct on all of the training set. This prediction rule is then used for predicting the labels on the test set.\n8\nBlock (1962), Novikoff (1962) and Minsky and Papert (1969) have shown that if the data are linearly separable, then the perceptron algorithm will make a finite number of mistakes, and therefore, if repeatedly cycled through the training set, will converge to a vector which correctly classifies all of the examples. Moreover, the number of mistakes is upper bounded by a function of the gap between the positive and negative examples, a fact that will be central to our analysis.\nIn this paper, we propose to use a more sophisticated method of applying the online perceptron algorithm to batch learning, namely, a variation of the leave-one-out method of Helmbold and Warmuth (1995). In the voted-perceptron algorithm, we store more information during training and then use this elaborate information to generate better predictions on the test data. The algorithm is detailed in Figure 1. The information we maintain during training is the list of all prediction vectors that were generated after each and every mistake. For each such vector, we count the number of iterations it \u201csurvives\u201d until the next mistake is made; we refer to this count as the \u201cweight\u201d of the prediction vector. To calculate a prediction we compute the binary prediction of each one of the prediction vectors and combine all these predictions by a weighted majority vote. The weights used are the survival times described above. This makes intuitive sense as \u201cgood\u201d prediction vectors tend to survive for a long time and thus have larger weight in the majority vote."
        },
        {
            "heading": "3. Analysis",
            "text": "In this section, we give an analysis of the voted-perceptron algorithm for the case - % in which the algorithm runs exactly once through the training data. We also quote a theorem of Vapnik and Chervonenkis (1974) for the linearly separable case. This theorem bounds the generalization error of the consistent perceptron found after the perceptron algorithm is run to convergence. Interestingly, for the linearly separable case, the theorems yield very similar bounds.\nAs we shall see in the experiments, the algorithm actually continues to improve performance after - % . We have no theoretical explanation for this improvement.\nIf the data are linearly separable, then the perceptron algorithm will eventually converge on some consistent hypothesis (i.e., a prediction vector that is correct on all of the training examples). As this prediction vector makes no further mistakes, it will eventually dominate the weighted vote in the voted-perceptron algorithm. Thus, for linearly separable data, when , the voted-perceptron algorithm converges to the regular use of the perceptron algorithm, which is to predict using the final prediction vector.\nAs we have recently learned, the performance of the final prediction vector has been analyzed by Vapnik and Chervonenkis (1974). We discuss their bound at the end of this section.\nWe now give our analysis for the case - % . The analysis is in two parts and mostly combines known material. First, we review the classical analysis of the online perceptron algorithm in the linearly separable case, as well as an extension to the inseparable case. Second, we review an analysis of the leave-one-out conversion of an online learning algorithm to a batch learning algorithm.\nTraining Input: a labeled training set 3 x ')\" 6 ' )' 3 x 2')\" 6 number of epochs Output: a list of weighted perceptrons 3 , ' 6 ' )' 3 , ' 6 Initialize: - , , - / , - . Repeat times:\n\u2013 For - % ' )' : Compute prediction: 1\" - sign 3 , &4 x 6 If 1\" - \" then - ( % .\nelse , -7, ( \" x ; - % ; - ( % .\nPrediction Given: the list of weighted perceptrons: 3 , ' 6 ' )' 3 , ' 6 an unlabeled instance: x compute a predicted label 1\" as follows:\n-\nsign 3 , 4 x 6! 1\"&- sign 3 6\"\nFigure 1. The voted-perceptron algorithm."
        },
        {
            "heading": "3.1. The online perceptron algorithm in the separable case",
            "text": "Our analysis is based on the following well known result first proved by Block (1962) and Novikoff (1962). The significance of this result is that the number of mistakes does not depend on the dimension of the instances. This gives reason to believe that the perceptron algorithm might perform well in high dimensional spaces.\nTHEOREM 1 (BLOCK, NOVIKOFF) Let 3 x ')\" 6 ' )' 3 x ' \" 6 be a sequence of labeled examples with ! x ! $#&% . Suppose that there exists a vector ' such that ! ' ! - % and\" )3 '54 x 6)(+* for all examples in the sequence. Then the number of mistakes made by the online perceptron algorithm on this sequence is at most 3,%.- * 6 / . Proof: Although the proof is well known, we repeat it for completeness. Let , denote the prediction vector used prior to the th mistake. Thus, , - / and, ifthe th mistake occurs on 3 x ' \" 6 then \" 3 , 4 x 60# and , 1 -7, ( \" x .We have , 42'5-7, 4!'8( \" 3 '54 x 6)( , 4 ' (4*\n8 Therefore, , 1 42' ( * .Similarly,\n! , 1 ! / -. ! , ! / ( \" 3 , &4 x 6 ( ! x / # ! , ! / (4% / Therefore, ! , ! / # %./ .Combining, gives\n% ( , ! ( , 4!' ( * which implies # 3 % - * 6 / proving the theorem."
        },
        {
            "heading": "3.2. Analysis for the inseparable case",
            "text": "If the data are not linearly separable then Theorem 1 cannot be used directly. However, we now give a generalized version of the theorem which allows for some mistakes in the training set. As far as we know, this theorem is new, although the proof technique is very similar to that of Klasner and Simon (1995, Theorem 2.2). See also the recent work of Shawe-Taylor and Cristianini (1998) who used this technique to derive generalization error bounds for any large margin classifier.\nTHEOREM 2 Let )3 x ' \" 6 ' )' 3 x ')\" 6 be a sequence of labeled examples with ! x ! #% . Let ' be any vector with ! ' ! -.% and let * . Define the deviation of each example as - # ' *2$9\" 3 '54 x 6)+ ' and define - / . Then the number of mistakes of the online perceptron algo-rithm on this sequence is bounded by % (\n* / Proof: The case - follows from Theorem 1, so we can assume that .\nThe proof is based on a reduction of the inseparable case to a separable case in a higher dimensional space. As we will see, the reduction does not change the algorithm.\nWe extend the instance space to by adding new dimensions, one for each example. Let x . denote the extension of the instance x . We set the first coordinates of x equal to x . We set the 3 (+ 6 \u2019th coordinate to where is a positive real constant whose value will be specified later. The rest of the coordinates of x are set to zero.\nNext we extend the comparison vector ' 7 to ' . We use the constant , which we calculate shortly, to ensure that the length of ' is one. We set the first coordinates of ' equal to ' - . We set the 3 ( 6 \u2019th coordinate to 3 \" 6 - 3 6 . It is easy to check that the appropriate normalization is - % ( / - / .\nConsider the value of \" 3 ' 4 x 6 : \" )3 ' 4 x 6 - \" ' 4 x ( \"\n- \" 3 ' 4 x 6 ( ( \" 3 ' 4 x 6 ( * $ \" 3 '54 x 6 - *\nThus the extended prediction vector ' achieves a margin of * - % ( / - / on the extended examples. In order to apply Theorem 1, we need a bound on the length of the instances. As % ( ! x ! for all , and the only additional non-zero coordinate has value , we get that ! x / # %./ ( / . Using these values in Theorem 1 we get that the number of mistakes of the online perceptron algorithm if run in the extended space is at most\n3,%./ ( / 6 3 % ( / - / 6 * /\nSetting - % minimizes the bound and yields the bound given in the statement of the theorem.\nTo finish the proof we show that the predictions of the perceptron algorithm in the extended space are equal to the predictions of the perceptron in the original space. We use, to denote the prediction vector used for predicting the instance x in the original space and , to denote the prediction vector used for predicting the corresponding instance x in the extended space. The claim follows by induction over %.# # of the following three claims:\n1. The first coordinates of , are equal to those of , . 2. The 3 (4 6 \u2019th coordinate of , is equal to zero. 3. sign 3 , 4 x 6 - sign 3 , 4 x 6 ."
        },
        {
            "heading": "3.3. Converting online to batch",
            "text": "We now have an algorithm that will make few mistakes when presented with the examples one by one. However, the setup we are interested in here is the batch setup in which we are given a training set, according to which we generate a hypothesis, which is then tested on a seperate test set. If the data are linearly separable then the perceptron algorithm eventually converges and we can use this final prediction rule as our hypothesis. However, the data might not be separable or we might not want to wait till convergence is achieved.\n8\nIn this case, we have to decide on the best prediction rule given the sequence of different classifiers that the online algorithm genarates. One solution to this problem is to use the prediction rule that has survived for the longest time before it was changed. A prediction rule that has survived for a long time is likely to be better than one that has only survived for a few iterations. This method was suggested by Gallant (1986) who called it the pocket method. Littlestone (1989), suggested a two-phase method in which the performance of all of the rules is tested on a seperate test set and the rule with the least error is then used. Here we use a different method for converting the online perceptron algorithm into a batch learning algorithm; the method combines all of the rules generated by the online algorithm after it was run for just a single time through the training data.\nWe now describe Helmbold and Warmuth\u2019s (1995) very simple \u201cleave-one-out\u201d method of converting an online learning algorithm into a batch learning algorithm. Our votedperceptron algorithm is a simple application of this general method. We start with the randomized version. Given a training set 3 x ' \" 6 ' )' 3 x ')\" 6 and an unlabeled in-stance x, we do the following. We select a number in #1 ' ' + uniformly at random. We then take the first examples in the training sequence and append the unlabeled instance to the end of this subsequence. We run the online algorithm on this sequence of length ( % , and use the prediction of the online algorithm on the last unlabeled instance.\nIn the deterministic leave-one-out conversion, we modify the randomized leave-one-out conversion to make it deterministic in the obvious way by choosing the most likely prediction. That is, we compute the prediction that would result for all possible choices of in#1 ' ' + , and we take majority vote of these predictions. It is straightforward to show that taking a majority vote runs the risk of doubling the probability of mistake while it has the potential of significantly decreasing it. In this work we decided to focus primarily on deterministic voting rather than randomization.\nThe following theorem follows directly from Helmbold and Warmuth (1995). (See also Kivinen and Warmuth (1997) and Cesa-Bianchi et al. (1997).)\nTHEOREM 3 Assume all examples 3 x ')\" 6 are generated i.i.d. Let be the expected number of mistakes that the online algorithm makes on a randomly generated sequence of ( % examples. Then given random training examples, the expected probability that the randomized leave-one-out conversion of makes a mistake on a randomly generated test instance is at most - 3, ( % 6 . For the deterministic leave-one-out conversion, this expected probability is at most - 3, .(7% 6 ."
        },
        {
            "heading": "3.4. Putting it all together",
            "text": "It can be verified that the deterministic leave-one-out conversion of the online perceptron algorithm is exactly equivalent to the voted-perceptron algorithm of Figure 1 with - % . Thus, combining Theorems 2 and 3, we have:\nCOROLLARY 1 Assume all examples are generated i.i.d. at random. Let 3 x ' \" 6 ' )' 3 x ')\" 6 be a sequence of training examples and let 3 x ')\" 6 be a test example. Let % - ! x . For ! ' -.% and * , let\n-\n3 #1 ' * $ \" 3 '54 x 6 + 6 /\nThen the probability (over the choice of all ( % examples) that the voted-perceptron algorithm with - % does not predict \" on test instance x is at most\n( % % ( * / (where the expectation is also over the choice of all ( % examples).\nIn fact, the same proof yields a slightly stronger statement which depends only on examples on which mistakes occur. Formally, this can be stated as follows:\nCOROLLARY 2 Assume all examples are generated i.i.d. at random. Suppose that we run the online perceptron algorithm once on the sequence )3 x ')\" 6 ' ' 3 x ')\" 6 , and that mistakes occur on examples with indices ' )' . Redefine % - ! x ! , and redefine\n- # ' *2$ \" 3 ' 4 x 6)+! / Now suppose that we run the voted-perceptron algorithm on training examples 3 x ' \" 6 ' )' 3 x ')\" 6 for a single epoch. Then the probability (over the choice of all ( % examples) that the voted-perceptron algorithm does not predict \" on test instance x is at most ( % #\" $ # ( % % % ( * / (where the expectation is also over the choice of all ( % examples).\nA rather similar theorem was proved by Vapnik and Chervonenkis (1974, Theorem 6.1) for training the perceptron algorithm to convergence and predicting with the final perceptron vector.\nTHEOREM 4 (VAPNIK AND CHERVONENKIS) Assume all examples are generated i.i.d. at random. Suppose that we run the online perceptron algorithm on the sequence 3 x ' \" 6 ' )' 3 x ')\" 6 repeatedly until convergence, and that mistakes occur on a total of examples with indices ' )' . Let %7- ! x ! , and let\n*8- \" 3 ' 4 x 6! Assume * with probability one.\nNow suppose that we run the perceptron algorithm to convergence on training examples 3 x ' \" 6 ' )' 3 x ')\" 6 . Then the probability (over the choice of all ( % examples) that the final perceptron does not predict \" on test instance x is at most\n8 %\n( % ' % * / (where the expectation is also over the choice of all ( % examples).\nFor the separable case (in which can be set to zero), Corollary 2 is almost identical to Theorem 4. One difference is that in Corolary 2, we lose a factor of 2. This is because we use the deterministic algorithm, rather than the randomized one. The other, more important difference is that , the number of mistakes that the perceptron makes, will almost certainly be larger when the perceptron is run to convergence than when it is run just for a single epoch. This gives us some indication that running the voted-perceptron algorithm with - % might be better than running it to convergence; however, our experiments do not support this prediction.\nVapnik (to appear) also gives a very similar bound for the expected error of supportvector machines. There are two differences between the bounds. First, the set of vectors on which the perceptron makes a mistake is replaced by the set of \u201cessential support vectors.\u201d Second, the radius % is the maximal distance of any support vector from some optimally chosen vector, rather than from the origin. (The support vectors are the training examples which fall closest to the decision boundary.)"
        },
        {
            "heading": "4. Kernel-based Classification",
            "text": "We have seen that the voted-perceptron algorithm has guaranteed performance bounds when the data are (almost) linearly separable. However, linear separability is a rather strict condition. One way to make the method more powerful is by adding dimensions or features to the input space. These new coordinates are nonlinear functions of the original coordinates. Usually if we add enough coordinates we can make the data linearly separable. If the separation is sufficiently good (in the senses of Theorems 1 and 2) then the expected generalization error will be small (provided we do not increase the complexity of instances too much by moving to the higher dimensional space).\nHowever, from a computational point of view, computing the values of the additional coordinates can become prohibitively hard. This problem can sometimes be solved by the elegant method of kernel functions. The use of kernel functions for classification problems was proposed by suggested Aizerman, Braverman and Rozonoer (1964) who specifically described a method for combining kernel functions with the perceptron algorithm. Continuing their work, Boser, Guyon and Vapnik (1992) suggested using kernel functions with SVM\u2019s.\nKernel functions are functions of two variables 93 x ' y 6 which can be represented as an inner product 3 x 6 4 3 y 6 for some function and some . In other words, we can calculate 93 x ' y 6 by mapping x and y to vectors 3 x 6 and 3 y 6 and then taking their inner product.\nFor instance, an important kernel function that we use in this paper is the polynomial expansion\n93 x ' y 6 - 3 % ( x 4 y 6 (1)\nThere exist general conditions for checking if a function is a kernel function. In this particular case, however, it is straightforward to construct witnessing that is a kernel function. For instance, for - and - , we can choose\n3 x 6 - 3 % ' / ' // ' / ' ' / ' ' / ' ' / 62\nIn general, for , we can define 3 x 6 to have one coordinate 3 x 6 for each monomial 3 x 6 of degree at most over the variables ' ' , and where is an appropriatelychosen constant. Aizerman, Braverman and Rozonoer observed that the perceptron algorithm can be formulated in such a way that all computations involving instances are in fact in terms of inner products x 4 y between pairs of instances. Thus, if we want to map each instance x to a vector 3 x 6 in a high dimensional space, we only need to be able to compute inner products 3 x 6 4 3 y 6 , which is exactly what is computed by a kernel function. Conceptually, then, with the kernel method, we can work with vectors in a very high dimensional space and the algorithm\u2019s performance only depends on linear separability in this expanded space. Computationally, however, we only need to modify the algorithm by replacing each inner product computation x 4 y with a kernel function computation 93 x ' y 6 . Similar observations were made by Boser, Guyon and Vapnik for Vapnik\u2019s SVM algorithm.\nIn this paper, we observe that all the computations in the voted-perceptron learning algorithm involving instances can also be written in terms of inner products, which means that we can apply the kernel method to the voted-perceptron algorithm as well. Referring to Figure 1, we see that both training and prediction involve inner products between instances x and prediction vectors , . In order to perform this operation efficiently, we store each prediction vector , in an implicit form, as the sum of instances that were added or subtracted in order to create it. That is, each , can be written and stored as a sum\n, &- \" x\nfor appropriate indices . We can thus calculate the inner product with x as , 4 x -\n\" 3 x 4 x 62 To use a kernel function , we would merely replace each x 4 x by 3 x ' x 6 .\nComputing the prediction of the final vector , on a test instance x requires kernel calculations where is the number of mistakes made by the algorithm during training. Naively, the prediction of the voted-perceptron would seem to require 3, / 6 kernel calculations since we need to compute , 4 x for each # , and since itself involves a sum of $*% instances. However, taking advantage of the recurrence , 4 x -7, 4 x (&\" 3 x 4 x 6 , itis clear that we can compute the prediction of the voted-perceptron also using only kernel calculations.\nThus, calculating the prediction of the voted-perceptron when using kernels is only marginally more expensive than calculating the prediction of the final prediction vector, assuming that both methods are trained for the same number of epochs.\n8"
        },
        {
            "heading": "5. Experiments",
            "text": "In our experiments, we followed closely the experimental setup used by Cortes and Vapnik (1995) in their experiments on the NIST OCR database. / We chose to use this setup because the dataset is widely available and because LeCun et al. (1995) have published a detailed comparison of the performance of some of the best digit classification systems in this setup.\nExamples in this NIST database consist of labeled digital images of individual handwritten digits. Each instance is a matrix in which each entry is an 8-bit representation of a grey value, and labels are from the set # ' ' + . The dataset consists of 60,000 training examples and 10,000 test examples. We treat each image as a vector in , and, like Cortes and Vapnik, we use the polynomial kernels of Eq. (1) to expand this vector into very high dimensions.\nTo handle multiclass data, we essentially reduced to 10 binary problems. That is, we trained the voted-perceptron algorithm once for each of the 10 classes. When training on class , we replaced each labeled example 3 x )' \" 6 (where \" #1 ' ' + ) by the binarylabeled example 3 x ')(*% 6 if \" - and by 3 x )' $ % 6 if \"1 - . Let\n3 , ' 6 ' ' 3 , ' 6 be the sequence of weighted prediction vectors which result from training on class .\nTo make predictions on a new instance x, we tried four different methods. In each method, we first compute a score for each # ' )' + and then predict with thelabel receiving the highest score:\n1\"&-\nThe first method is to compute each score using the respective final prediction vector:\n- , 4 x\nThis method is denoted \u201clast (unnormalized)\u201d in the results. A variant of this method is to compute scores after first normalizing the final prediction vectors:\n- , 4 x ! , !\nThis method is denoted \u201clast (normalized)\u201d in the results. Note that normalizing vectors has no effect for binary problems, but can plausibly be important in the multiclass case.\nThe next method (denoted \u201cvote\u201d) uses the analog of the deterministic leave-one-out conversion. Here we set\n8\nof the prediction vectors\n- 3 , 4 x 62 As in the \u201clast\u201d method, we also tried a variant (denoted \u201caverage (normalized)\u201d) using normalized prediction vectors:\n-\n, 4 x ! , !\nThe final method (denoted \u201crandom (unnormalized)\u201d), is a possible analog of the randomized leave-one-out method in which we predict using the prediction vectors that exist at a randomly chosen \u201ctime slice.\u201d That is, let be the number of rounds executed (i.e., the number of examples processed by the inner loop of the algorithm) so that\n-\nfor all . To classify x, we choose a \u201ctime slice\u201d 9#1 ' )' + uniformly at random. We then set\n- , 4 x\n8\nwhere is the index of the final vector which existed at time for label . Formally, isthe largest number in #1 ' ' + satisfying\n#\nThe analogous normalized method (\u201cRandom (normalized)\u201d) uses\n- , 4 x ! , !\nOur analysis is applicable only for the cases of voted or randomly chosen predictions and where - % . However, in the experiments, we ran the algorithm with up to . When using polynomial kernels of degree 5 or more, the data becomes linearly separable. Thus, after several iterations, the perceptron algorithm converges to a consistent prediction vector and makes no more mistakes. After this happens, the final perceptron gains more and more weight in both \u201cvote\u201d and \u201caverage.\u201d This tends to have the effect of causing all of the variants to converge eventually to the same solution. By reaching this limit we compare the voted-perceptron algorithm to the standard way in which the perceptron algorithm is used, which is to find a consistent prediction rule.\nWe performed experiments with polynomial kernels for dimensions - % (which corresponds to no expansion) up to - . We preprocessed the data on each experiment by randomly permuting the training sequence. Each experiment was repeated 10 times, each time with a different random permutation of the training examples. For\n- % , we were only able to run the experiment for ten epochs for reasons which are described below.\nFigure 2 shows plots of the test error as a function of the number of epochs for four of the prediction methods \u2014 \u201cvote\u201d and the unnormalized versions of \u201clast,\u201d \u201caverage\u201d and \u201crandom\u201d (we omitted the normalized versions for the sake of readability). Test errors are averaged over the multiple runs of the algorithm, and are plotted one point for every tenth of an epoch.\nSome of the results are also summarized numerically in Tables 1 and 2 which show (average) test error for several values of for the seven different methods in the rows marked \u201cVote,\u201d \u201cAvg. (unnorm),\u201d etc. The rows marked \u201cSupVec\u201d show the number of \u201csupport vectors,\u201d that is, the total number of instances that actually are used in computing scores as above. In other words, this is the size of the union of all instances on which a mistake occured during training. The rows marked \u201cMistake\u201d show the total number of mistakes made during training for the 10 different labels. In every case, we have averaged over the multiple runs of the algorithm.\nThe column corresponding to - !% is helpful for getting an idea of how the algorithms perform on smaller datasets since in this case, each algorithm has only used a tenth of the available data (about 6000 training examples).\nIronically, the algorithm runs slowest with small values of . For larger values of , we move to a much higher dimensional space in which the data becomes linearly separable. For small values of \u2014 especially for\n- % \u2014 the data are not linearly separable which means that the perceptron algorithm tends to make many mistakes which slows down the algorithm significantly. This is why, for - % , we could not even complete a run out to 30\n8\nepochs but had to stop at - % (after about six days of computation). In comparison, for - , we can run 30 epochs in about 25 hours, and for - or , a complete run takes about 8 hours. (All running times are on a single SGI MIPS R10000 processor running at 194 MHZ.)\nThe most significant improvement in performance is clearly between - % and - . The migration to a higher dimensional space makes a tremendous difference compared to running the algorithm in the given space. The improvements for\nare not nearly as dramatic.\nOur results indicate that voting and averaging perform better than using the last vector. This is especially true prior to convergence of the perceptron updates. For\n- % , the data are highly inseparable, so in this case the improvement persists for as long as we were able to run the algorithm. For higher dimensions (\n% ), the data becomes more separable and the perceptron update rule converges (or almost converges), in which case the performance of all the prediction methods is very similar. Still, even in this case, there is an advantage to using voting or averaging for a relatively small number of epochs.\nThere does not seem to be any significant difference between voting and averaging in terms of performance. However, using random vectors performs the worst in all cases. This stands in contrast to our analysis, which applies only to random vectors and gives an upper bound on the error of average vectors which is twice the error of the randomized vectors. A more refined analysis of the effect of averaging is required to better explain the observed behavior.\nUsing normalized vectors seems to sometimes help a bit for the \u201clast\u201d method, but can help or hurt performance slightly for the \u201caverage\u201d method; in any case, the differences in performance between using normalized and unnormalized vectors are always minor.\nLeCun et al. (1995) give a detailed comparison of algorithms on this dataset. The best of the algorithms that they tested is (a rather old version of) boosting on top of the neural net LeNet 4 which achieves an error rate of 0.7%. A version of the optimal margin classifier algorithm (Cortes & Vapnik, 1995), using the same kernel function, performs significantly better than ours, achieving a test error rate of 1.1% for\n- . Table 3 shows how the variants of the perceptron algorithm perform on the ten binary problems corresponding to the 10 class labels. For this table, we fix - , and we also compare performance to that reported by Cortes and Vapnik (1995) for SVM\u2019s. Table 4 gives more details of how the perceptron methods perform on the single binary problem of distinguishing \u201c9\u201d from all other images. Note that these binary problems come closest to the theory discussed earlier in the paper. It is interesting that the perceptron algorithm generally ends up using fewer support vectors than with the SVM algorithm."
        },
        {
            "heading": "6. Conclusions and Summary",
            "text": "The most significant result of our experiments is that running the perceptron algorithm in a higher dimensional space using kernel functions produces very significant improvements in performance, yielding accuracy levels that are comparable, though still inferior, to those obtainable with support-vector machines. On the other hand, our algorithm is much faster and easier to implement than the latter method. In addition, the theoretical analysis of the expected error of the perceptron algorithm yields very similar bounds to those of support-\nvector machines. It is an open problem to develop a better theoretical understanding of the empirical superiority of support-vector machines.\nWe also find it significant that voting and averaging work better than just using the final hypothesis. This indicates that the theoretical analysis, which suggests using voting, is capturing some of the truth. On the other hand, we do not have a theoretical explanation for the improvement in performance following the first epoch."
        },
        {
            "heading": "Acknowledgments",
            "text": "We thank Vladimir Vapnik for some helpful discussions and for pointing us to Theorem 4.\nNotes\n1. Storing all of these vectors might seem an excessive waste of memory. However, as we shall see, when perceptrons are used together with kernels, the excess in memory and computition is really quite minimal. 2. National Institute for Standards and Technology, Special Database 3. See http://www.research.att.com/ yann/ocr/ for information on obtaining this dataset and for a list of relevant publications."
        }
    ],
    "title": "Large Margin Classification Using the Perceptron Algorithm"
}