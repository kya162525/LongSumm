{
    "abstractText": "Recently, graph neural networks (GNNs) have revolutionized the field of graph representation learning through effectively learned node embeddings, and achieved state-of-the-art results in tasks such as node classification and link prediction. However, current GNN methods are inherently flat and do not learn hierarchical representations of graphs\u2014a limitation that is especially problematic for the task of graph classification, where the goal is to predict the label associated with an entire graph. Here we propose DIFFPOOL, a differentiable graph pooling module that can generate hierarchical representations of graphs and can be combined with various graph neural network architectures in an end-to-end fashion. DIFFPOOL learns a differentiable soft cluster assignment for nodes at each layer of a deep GNN, mapping nodes to a set of clusters, which then form the coarsened input for the next GNN layer. Our experimental results show that combining existing GNN methods with DIFFPOOL yields an average improvement of 5\u201310% accuracy on graph classification benchmarks, compared to all existing pooling approaches, achieving a new state-of-the-art on four out of five benchmark data sets.",
    "authors": [
        {
            "affiliations": [],
            "name": "Rex Ying"
        },
        {
            "affiliations": [],
            "name": "Jiaxuan You"
        },
        {
            "affiliations": [],
            "name": "Xiang Ren"
        }
    ],
    "id": "SP:556836fdab944db38ba9cbe84a084547243df007",
    "references": [
        {
            "authors": [
                "M. Bianchini",
                "M. Gori",
                "F. Scarselli"
            ],
            "title": "Processing directed acyclic graphs with recursive neural networks",
            "venue": "IEEE Transactions on Neural Networks, 12(6):1464\u20131470,",
            "year": 2001
        },
        {
            "authors": [
                "K.M. Borgwardt",
                "H.-P. Kriegel"
            ],
            "title": "Shortest-path kernels on graphs",
            "venue": "IEEE International Conference on Data Mining, pages 74\u201381,",
            "year": 2005
        },
        {
            "authors": [
                "K.M. Borgwardt",
                "C.S. Ong",
                "S. Sch\u00f6nauer",
                "S.V.N. Vishwanathan",
                "A.J. Smola",
                "H.- P. Kriegel"
            ],
            "title": "Protein function prediction via graph kernels",
            "venue": "Bioinformatics, 21(Supplement 1):i47\u2013i56,",
            "year": 2005
        },
        {
            "authors": [
                "M.M. Bronstein",
                "J. Bruna",
                "Y. LeCun",
                "A. Szlam",
                "P. Vandergheynst"
            ],
            "title": "Geometric deep learning: Going beyond euclidean data",
            "venue": "IEEE Signal Processing Magazine, 34(4):18\u201342,",
            "year": 2017
        },
        {
            "authors": [
                "J. Bruna",
                "W. Zaremba",
                "A. Szlam",
                "Y. LeCun"
            ],
            "title": "Spectral networks and deep locally connected networks on graphs",
            "venue": "International Conference on Learning Representations,",
            "year": 2014
        },
        {
            "authors": [
                "C.-C. Chang",
                "C.-J. Lin"
            ],
            "title": "LIBSVM: A library for support vector machines",
            "venue": "ACM Transactions on Intelligent Systems and Technology, 2:27:1\u201327:27,",
            "year": 2011
        },
        {
            "authors": [
                "H. Dai",
                "B. Dai",
                "L. Song"
            ],
            "title": "Discriminative embeddings of latent variable models for structured data",
            "venue": "International Conference on Machine Learning, pages 2702\u20132711,",
            "year": 2016
        },
        {
            "authors": [
                "M. Defferrard",
                "X. Bresson",
                "P. Vandergheynst"
            ],
            "title": "Convolutional neural networks on graphs with fast localized spectral filtering",
            "venue": "Advances in Neural Information Processing Systems, pages 3844\u20133852,",
            "year": 2016
        },
        {
            "authors": [
                "I.S. Dhillon",
                "Y. Guan",
                "B. Kulis"
            ],
            "title": "Weighted graph cuts without eigenvectors a multilevel approach",
            "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence, 29(11):1944\u20131957,",
            "year": 2007
        },
        {
            "authors": [
                "P.D. Dobson",
                "A.J. Doig"
            ],
            "title": "Distinguishing enzyme structures from non-enzymes without alignments",
            "venue": "Journal of Molecular Biology, 330(4):771 \u2013 783,",
            "year": 2003
        },
        {
            "authors": [
                "D.K. Duvenaud",
                "D. Maclaurin",
                "J. Iparraguirre",
                "R. Bombarell",
                "T. Hirzel",
                "A. Aspuru-Guzik",
                "R.P. Adams"
            ],
            "title": "Convolutional networks on graphs for learning molecular fingerprints",
            "venue": "Advances in Neural Information Processing Systems, pages 2224\u20132232,",
            "year": 2015
        },
        {
            "authors": [
                "A. Feragen",
                "N. Kasenburg",
                "J. Petersen",
                "M.D. Bruijne",
                "K.M. Borgwardt"
            ],
            "title": "Scalable kernels for graphs with continuous attributes",
            "venue": "Advances in Neural Information Processing Systems, pages 216\u2013224,",
            "year": 2013
        },
        {
            "authors": [
                "M. Fey",
                "J.E. Lenssen",
                "F. Weichert",
                "H. M\u00fcller"
            ],
            "title": "SplineCNN: Fast geometric deep learning with continuous B-spline kernels",
            "venue": "IEEE Conference on Computer Vision and Pattern Recognition,",
            "year": 2018
        },
        {
            "authors": [
                "A. Fout",
                "J. Byrd",
                "B. Shariat",
                "A. Ben-Hur"
            ],
            "title": "Protein interface prediction using graph convolutional networks",
            "venue": "Advances in Neural Information Processing Systems, pages 6533\u20136542,",
            "year": 2017
        },
        {
            "authors": [
                "J. Gilmer",
                "S.S. Schoenholz",
                "P.F. Riley",
                "O. Vinyals",
                "G.E. Dahl"
            ],
            "title": "Neural message passing for quantum chemistry",
            "venue": "International Conference on Machine Learning, pages 1263\u20131272,",
            "year": 2017
        },
        {
            "authors": [
                "W.L. Hamilton",
                "R. Ying",
                "J. Leskovec"
            ],
            "title": "Inductive representation learning on large graphs",
            "venue": "Advances in Neural Information Processing Systems, pages 1025\u20131035,",
            "year": 2017
        },
        {
            "authors": [
                "W.L. Hamilton",
                "R. Ying",
                "J. Leskovec"
            ],
            "title": "Representation learning on graphs: Methods and applications",
            "venue": "IEEE Data Engineering Bulletin, 40(3):52\u201374,",
            "year": 2017
        },
        {
            "authors": [
                "S. Ioffe",
                "C. Szegedy"
            ],
            "title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
            "venue": "International Conference on Machine Learning, pages 448\u2013456,",
            "year": 2015
        },
        {
            "authors": [
                "W. Jin",
                "C.W. Coley",
                "R. Barzilay",
                "T.S. Jaakkola"
            ],
            "title": "Predicting organic reaction outcomes with Weisfeiler-Lehman network",
            "venue": "Advances in Neural Information Processing Systems, pages 2604\u20132613,",
            "year": 2017
        },
        {
            "authors": [
                "K. Kersting",
                "N.M. Kriege",
                "C. Morris",
                "P. Mutzel",
                "M. Neumann"
            ],
            "title": "Benchmark data sets for graph kernels, 2016",
            "year": 2016
        },
        {
            "authors": [
                "T.N. Kipf",
                "E. Fetaya",
                "K.C. Wang",
                "M. Welling",
                "R. Zemel"
            ],
            "title": "Neural relational inference for interacting systems",
            "venue": "International Conference on Machine Learning,",
            "year": 2018
        },
        {
            "authors": [
                "T.N. Kipf",
                "M. Welling"
            ],
            "title": "Semi-supervised classification with graph convolutional networks",
            "venue": "International Conference on Learning Representations,",
            "year": 2017
        },
        {
            "authors": [
                "N.M. Kriege",
                "P.-L. Giscard",
                "R. Wilson"
            ],
            "title": "On valid optimal assignment kernels and applications to graph classification",
            "venue": "Advances in Neural Information Processing Systems, pages 1623\u20131631,",
            "year": 2016
        },
        {
            "authors": [
                "A. Krizhevsky",
                "I. Sutskever",
                "G.E. Hinton"
            ],
            "title": "ImageNet classification with deep convolutional neural networks",
            "venue": "Advances in Neural Information Processing Systems, pages 1097\u20131105,",
            "year": 2012
        },
        {
            "authors": [
                "T. Lei",
                "W. Jin",
                "R. Barzilay",
                "T.S. Jaakkola"
            ],
            "title": "Deriving neural architectures from sequence and graph kernels",
            "venue": "International Conference on Machine Learning, pages 2024\u20132033,",
            "year": 2017
        },
        {
            "authors": [
                "Y. Li",
                "D. Tarlow",
                "M. Brockschmidt",
                "R. Zemel"
            ],
            "title": "Gated graph sequence neural networks",
            "venue": "International Conference on Learning Representations,",
            "year": 2016
        },
        {
            "authors": [
                "R. Liao",
                "M. Brockschmidt",
                "D. Tarlow",
                "A.L. Gaunt",
                "R. Urtasun",
                "R. Zemel"
            ],
            "title": "Graph partition neural networks for semi-supervised classification",
            "venue": "International Conference on Learning Representations (Workshop Track),",
            "year": 2018
        },
        {
            "authors": [
                "A. Lusci",
                "G. Pollastri",
                "P. Baldi"
            ],
            "title": "Deep architectures and deep learning in chemoinformatics: The prediction of aqueous solubility for drug-like molecules",
            "venue": "Journal of Chemical Information and Modeling, 53(7):1563\u20131575,",
            "year": 2013
        },
        {
            "authors": [
                "C. Merkwirth",
                "T. Lengauer"
            ],
            "title": "Automatic generation of complementary descriptors with molecular graph networks",
            "venue": "Journal of Chemical Information and Modeling, 45(5):1159\u20131168,",
            "year": 2005
        },
        {
            "authors": [
                "M. Niepert",
                "M. Ahmed",
                "K. Kutzkov"
            ],
            "title": "Learning convolutional neural networks for graphs",
            "venue": "International Conference on Machine Learning, pages 2014\u20132023,",
            "year": 2016
        },
        {
            "authors": [
                "F. Scarselli",
                "M. Gori",
                "A.C. Tsoi",
                "M. Hagenbuchner",
                "G. Monfardini"
            ],
            "title": "The graph neural network model",
            "venue": "Transactions on Neural Networks, 20(1):61\u201380,",
            "year": 2009
        },
        {
            "authors": [
                "M. Schlichtkrull",
                "T.N. Kipf",
                "P. Bloem",
                "R. van den Berg",
                "I. Titov",
                "M. Welling"
            ],
            "title": "Modeling relational data with graph convolutional networks",
            "venue": "In Extended Semantic Web Conference,",
            "year": 2018
        },
        {
            "authors": [
                "K. Sch\u00fctt",
                "P.J. Kindermans",
                "H.E. Sauceda",
                "S. Chmiela",
                "A. Tkatchenko",
                "K.R. M\u00fcller"
            ],
            "title": "SchNet: A continuous-filter convolutional neural network for modeling quantum interactions",
            "venue": "Advances in Neural Information Processing Systems, pages 992\u20131002,",
            "year": 2017
        },
        {
            "authors": [
                "N. Shervashidze",
                "P. Schweitzer",
                "E.J. van Leeuwen",
                "K. Mehlhorn",
                "K.M. Borgwardt"
            ],
            "title": "Weisfeiler-Lehman graph kernels",
            "venue": "Journal of Machine Learning Research,",
            "year": 2011
        },
        {
            "authors": [
                "N. Shervashidze",
                "S.V.N. Vishwanathan",
                "T.H. Petri",
                "K. Mehlhorn",
                "K.M. Borgwardt"
            ],
            "title": "Efficient graphlet kernels for large graph comparison",
            "venue": "International Conference on Artificial Intelligence and Statistics, pages 488\u2013495,",
            "year": 2009
        },
        {
            "authors": [
                "M. Simonovsky",
                "N. Komodakis"
            ],
            "title": "Dynamic edge-conditioned filters in convolutional neural networks on graphs",
            "venue": "IEEE Conference on Computer Vision and Pattern Recognition, pages 29\u201338,",
            "year": 2017
        },
        {
            "authors": [
                "P. Veli\u010dkovi\u0107",
                "G. Cucurull",
                "A. Casanova",
                "A. Romero",
                "P. Li\u00f2",
                "Y. Bengio"
            ],
            "title": "Graph attention networks",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "S. Verma",
                "Z.-L. Zhang"
            ],
            "title": "Graph capsule convolutional neural networks",
            "venue": "arXiv preprint arXiv:1805.08090,",
            "year": 2018
        },
        {
            "authors": [
                "O. Vinyals",
                "S. Bengio",
                "M. Kudlur"
            ],
            "title": "Order matters: Sequence to sequence for sets",
            "venue": "International Conference on Learning Representations,",
            "year": 2015
        },
        {
            "authors": [
                "P. Yanardag",
                "S.V.N. Vishwanathan"
            ],
            "title": "A structural smoothing framework for robust graph comparison",
            "venue": "Advances in Neural Information Processing Systems, pages 2134\u20132142,",
            "year": 2015
        },
        {
            "authors": [
                "M. Zhang",
                "Z. Cui",
                "M. Neumann",
                "Y. Chen"
            ],
            "title": "An end-to-end deep learning architecture for graph classification",
            "venue": "AAAI Conference on Artificial Intelligence,",
            "year": 2018
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "In recent years there has been a surge of interest in developing graph neural networks (GNNs)\u2014 general deep learning architectures that can operate over graph structured data, such as social network data [16, 22, 37] or graph-based representations of molecules [7, 11, 15]. The general approach with GNNs is to view the underlying graph as a computation graph and learn neural network primitives that generate individual node embeddings by passing, transforming, and aggregating node feature information across the graph [15, 16]. The generated node embeddings can then be used as input to any differentiable prediction layer, e.g., for node classification [16] or link prediction [33], and the whole model can be trained in an end-to-end fashion.\nHowever, a major limitation of current GNN architectures is that they are inherently flat as they only propagate information across the edges of the graph and are unable to infer and aggregate the information in a hierarchical way. For example, in order to successfully encode the graph structure of organic molecules, one would ideally want to encode the local molecular structure (e.g., individual\nPreprint. Work in progress.\nar X\niv :1\n80 6.\n08 80\n4v 4\n[ cs\n.L G\natoms and their direct bonds) as well as the coarse-grained structure of the molecular graph (e.g., groups of atoms and bonds representing functional units in a molecule). This lack of hierarchical structure is especially problematic for the task of graph classification, where the goal is to predict the label associated with an entire graph. When applying GNNs to graph classification, the standard approach is to generate embeddings for all the nodes in the graph and then to globally pool all these node embeddings together, e.g., using a simple summation or neural network that operates over sets [7, 11, 15, 26]. This global pooling approach ignores any hierarchical structure that might be present in the graph, and it prevents researchers from building effective GNN models for predictive tasks over entire graphs.\nHere we propose DIFFPOOL, a differentiable graph pooling module that can be adapted to various graph neural network architectures in an hierarchical and end-to-end fashion (Figure 1). DIFFPOOL allows for developing deeper GNN models that can learn to operate on hierarchical representations of a graph. We develop a graph analogue of the spatial pooling operation in CNNs [24], which allows for deep CNN architectures to iteratively operate on coarser and coarser representations of an image. The challenge in the GNN setting\u2014compared to standard CNNs\u2014is that graphs contain no natural notion of spatial locality, i.e., one cannot simply pool together all nodes in a \u201cm \u00d7m patch\u201d on a graph, because the complex topological structure of graphs precludes any straightforward, deterministic definition of a \u201cpatch\u201d. Moreover, unlike image data, graph data sets often contain graphs with varying numbers of nodes and edges, which makes defining a general graph pooling operator even more challenging.\nIn order to solve the above challenges, we require a model that learns how to cluster together nodes to build a hierarchical multi-layer scaffold on top of the underlying graph. Our approach DIFFPOOL learns a differentiable soft assignment at each layer of a deep GNN, mapping nodes to a set of clusters based on their learned embeddings. In this framework, we generate deep GNNs by \u201cstacking\u201d GNN layers in a hierarchical fashion (Figure 1): the input nodes at the layer l GNN module correspond to the clusters learned at the layer l \u2212 1 GNN module. Thus, each layer of DIFFPOOL coarsens the input graph more and more, and DIFFPOOL is able to generate a hierarchical representation of any input graph after training. We show that DIFFPOOL can be combined with various GNN approaches, resulting in an average 7% gain in accuracy and a new state of the art on four out of five benchmark graph classification tasks. Finally, we show that DIFFPOOL can learn interpretable hierarchical clusters that correspond to well-defined communities in the input graphs."
        },
        {
            "heading": "2 Related Work",
            "text": "Our work builds upon a rich line of recent research on graph neural networks and graph classification.\nGeneral graph neural networks. A wide variety of graph neural network (GNN) models have been proposed in recent years, including methods inspired by convolutional neural networks [5, 8, 11, 16, 22, 25, 30, 37], recurrent neural networks [26], recursive neural networks [1, 31] and loopy belief propagation [7]. Most of these approaches fit within the framework of \u201cneural message passing\u201d proposed by Gilmer et al. [15]. In the message passing framework, a GNN is viewed as a\nmessage passing algorithm where node representations are iteratively computed from the features of their neighbor nodes using a differentiable aggregation function. Hamilton et al. [17] provides a conceptual review of recent advancements in this area, and Bronstein et al. [4] outlines connections to spectral graph convolutions.\nGraph classification with graph neural networks. GNNs have been applied to a wide variety of tasks, including node classification [16, 22], link prediction [32], graph classification [7, 11, 41], and chemoinformatics [29, 28, 14, 19, 33]. In the context of graph classification\u2014the task that we study here\u2014a major challenge in applying GNNs is going from node embeddings, which are the output of GNNs, to a representation of the entire graph. Common approaches to this problem include simply summing up or averaging all the node embeddings in a final layer [11], introducing a \u201cvirtual node\u201d that is connected to all the nodes in the graph [26], or aggregating the node embeddings using a deep learning architecture that operates over sets [15]. However, all of these methods have the limitation that they do not learn hierarchical representations (i.e., all the node embeddings are globally pooled together in a single layer), and thus are unable to capture the natural structures of many real-world graphs. Some recent approaches have also proposed applying CNN architectures to the concatenation of all the node embeddings [30, 41], but this requires a specifying (or learning) a canonical ordering over nodes, which is in general very difficult and equivalent to solving graph isomorphism.\nLastly, there are some recent works that learn hierarchical graph representations by combining GNNs with deterministic graph clustering algorithms [8, 36, 13], following a two-stage approach. However, unlike these previous approaches, we seek to learn the hierarchical structure in an end-to-end fashion, rather than relying on a deterministic graph clustering subroutine."
        },
        {
            "heading": "3 Proposed Method",
            "text": "The key idea of DIFFPOOL is that it enables the construction of deep, multi-layer GNN models by providing a differentiable module to hierarchically pool graph nodes. In this section, we outline the DIFFPOOL module and show how it is applied in a deep GNN architecture."
        },
        {
            "heading": "3.1 Preliminaries",
            "text": "We represent a graph G as (A,F ), where A \u2208 {0, 1}n\u00d7n is the adjacency matrix, and F \u2208 Rn\u00d7d is the node feature matrix assuming each node has d features.1 Given a set of labeled graphs D = {(G1, y1), (G2, y2), ...} where yi \u2208 Y is the label corresponding to graph Gi \u2208 G, the goal of graph classification is to learn a mapping f : G \u2192 Y that maps graphs to the set of labels. The challenge\u2014compared to standard supervised machine learning setup\u2014is that we need a way to extract useful feature vectors from these input graphs. That is, in order to apply standard machine learning methods for classification, e.g., neural networks, we need a procedure to convert each graph to an finite dimensional vector in RD. Graph neural networks. In this work, we build upon graph neural networks in order to learn useful representations for graph classification in an end-to-end fashion. In particular, we consider GNNs that employ the following general \u201cmessage-passing\u201d architecture:\nH(k) =M(A,H(k\u22121); \u03b8(k)), (1) where H(k) \u2208 Rn\u00d7d are the node embeddings (i.e., \u201cmessages\u201d) computed after k steps of the GNN and M is the message propagation function, which depends on the adjacency matrix, trainable parameters \u03b8(k), and the node embeddings H(k\u22121) generated from the previous message-passing step.2 The input node embeddingsH(0) at the initial message-passing iteration (k = 1), are initialized using the node features on the graph, H(0) = F .\nThere are many possible implementations of the propagation function M [15, 16]. For example, one popular variant of GNNs\u2014Kipf\u2019s et al. [22] Graph Convolutional Networks (GCNs)\u2014implements M using a combination of linear transformations and ReLU non-linearities:\nH(k) =M(A,H(k\u22121);W (k)) = ReLU(D\u0303\u2212 1 2 A\u0303D\u0303\u2212 1 2H(k\u22121)W (k\u22121)), (2)\n1We do not consider edge features, although one can easily extend the algorithm to support edge features using techniques introduced in [36].\n2For notational convenience, we assume that the embedding dimension is d for all H(k); however, in general this restriction is not necessary.\nwhere A\u0303 = A+ I , D\u0303 = \u2211\nj A\u0303ij and W (k) \u2208 Rd\u00d7d is a trainable weight matrix. The differentiable\npooling model we propose can be applied to any GNN model implementing Equation (1), and is agnostic with regards to the specifics of how M is implemented.\nA full GNN module will runK iterations of Equation (1) to generate the final output node embeddings Z = H(K) \u2208 Rn\u00d7d, where K is usually in the range 2-6. For simplicity, in the following sections we will abstract away the internal structure of the GNNs and use Z = GNN(A,X) to denote an arbitrary GNN module implementing K iterations of message passing according to some adjacency matrix A and initial input node features X .\nStacking GNNs and pooling layers. GNNs implementing Equation (1) are inherently flat, as they only propagate information across edges of a graph. The goal of this work is to define a general, end-to-end differentiable strategy that allows one to stack multiple GNN modules in a hierarchical fashion. Formally, given Z = GNN(A,X), the output of a GNN module, and a graph adjacency matrix A \u2208 Rn\u00d7n, we seek to define a strategy to output a new coarsened graph containing m < n nodes, with weighted adjacency matrix A\n\u2032 \u2208 Rm\u00d7m and node embeddings Z \u2032 \u2208 Rm\u00d7d. This new coarsened graph can then be used as input to another GNN layer, and this whole process can be repeated L times, generating a model with L GNN layers that operate on a series of coarser and coarser versions of the input graph (Figure 1). Thus, our goal is to learn how to cluster or pool together nodes using the output of a GNN, so that we can use this coarsened graph as input to another GNN layer. What makes designing such a pooling layer for GNNs especially challenging\u2014compared to the usual graph coarsening task\u2014is that our goal is not to simply cluster the nodes in one graph, but to provide a general recipe to hierarchically pool nodes across a broad set of input graphs. That is, we need our model to learn a pooling strategy that will generalize across graphs with different nodes, edges, and that can adapt to the various graph structures during inference."
        },
        {
            "heading": "3.2 Differentiable Pooling via Learned Assignments",
            "text": "Our proposed approach, DIFFPOOL, addresses the above challenges by learning a cluster assignment matrix over the nodes using the output of a GNN model. The key intuition is that we stack L GNN modules and learn to assign nodes to clusters at layer l in an end-to-end fashion, using embeddings generated from a GNN at layer l\u2212 1. Thus, we are using GNNs to both extract node embeddings that are useful for graph classification, as well to extract node embeddings that are useful for hierarchical pooling. Using this construction, the GNNs in DIFFPOOL learn to encode a general pooling strategy that is useful for a large set of training graphs. We first describe how the DIFFPOOL module pools nodes at each layer given an assignment matrix; following this, we discuss how we generate the assignment matrix using a GNN architecture.\nPooling with an assignment matrix. We denote the learned cluster assignment matrix at layer l as S(l) \u2208 Rnl\u00d7nl+1 . Each row of S(l) corresponds to one of the nl nodes (or clusters) at layer l, and each column of S(l) corresponds to one of the nl+1 clusters at the next layer l + 1. Intuitively, S(l) provides a soft assignment of each node at layer l to a cluster in the next coarsened layer l + 1.\nSuppose that S(l) has already been computed, i.e., that we have computed the assignment matrix at the l-th layer of our model. We denote the input adjacency matrix at this layer as A(l) and denote the input node embedding matrix at this layer as Z(l). Given these inputs, the DIFFPOOL layer (A(l+1), X(l+1)) = DIFFPOOL(A(l), Z(l)) coarsens the input graph, generating a new coarsened adjacency matrix A(l+1) and a new matrix of embeddings X(l+1) for each of the nodes/clusters in this coarsened graph. In particular, we apply the two following equations:\nX(l+1) = S(l) T Z(l) \u2208 Rnl+1\u00d7d, (3)\nA(l+1) = S(l) T A(l)S(l) \u2208 Rnl+1\u00d7nl+1 . (4)\nEquation (3) takes the node embeddings Z(l) and aggregates these embeddings according to the cluster assignments S(l), generating embeddings for each of the nl+1 clusters. Similarly, Equation (4) takes the adjacency matrix A(l) and generates a coarsened adjacency matrix denoting the connectivity strength between each pair of clusters.\nThrough Equations (3) and (4), the DIFFPOOL layer coarsens the graph: the next layer adjacency matrix A(l+1) represents a coarsened graph with nl+1 nodes or cluster nodes, where each individual\ncluster node in the new coarsened graph corresponds to a cluster of nodes in the graph at layer l. Note that A(l+1) is a real matrix and represents a fully connected edge-weighted graph; each entry A\n(l+1) ij can be viewed as the connectivity strength between cluster i and cluster j. Similarly, the i-th row of X(l+1) corresponds to the embedding of cluster i. Together, the coarsened adjacency matrix A(l+1) and cluster embeddings X(l+1) can be used as input to another GNN layer, a process which we describe in detail below.\nLearning the assignment matrix. In the following we describe the architecture of DIFFPOOL, i.e., how DIFFPOOL generates the assignment matrix S(l) and embedding matrices Z(l) that are used in Equations (3) and (4). We generate these two matrices using two separate GNNs that are both applied to the input cluster node features X(l) and coarsened adjacency matrix A(l). The embedding GNN at layer l is a standard GNN module applied to these inputs:\nZ(l) = GNNl,embed(A(l), X(l)), (5)\ni.e., we take the adjacency matrix between the cluster nodes at layer l (from Equation 4) and the pooled features for the clusters (from Equation 3) and pass these matrices through a standard GNN to get new embeddings Z(l) for the cluster nodes. In contrast, the pooling GNN at layer l, uses the input cluster features X(l) and cluster adjacency matrix A(l) to generate an assignment matrix:\nS(l) = softmax ( GNNl,pool(A(l), X(l)) ) , (6)\nwhere the softmax function is applied in a row-wise fashion. The output dimension of GNNl,pool corresponds to a pre-defined maximum number of clusters in layer l, and is a hyperparameter of the model.\nNote that these two GNNs consume the same input data but have distinct parameterizations and play separate roles: The embedding GNN generates new embeddings for the input nodes at this layer, while the pooling GNN generates a probabilistic assignment of the input nodes to nl+1 clusters.\nIn the base case, the inputs to Equations (5) and Equations (6) at layer l = 0 are simply the input adjacency matrix A and the node features F for the original graph. At the penultimate layer L\u2212 1 of a deep GNN model using DIFFPOOL, we set the assignment matrix S(L\u22121) be a vector of 1\u2019s, i.e., all nodes at the final layer L are assigned to a single cluster, generating a final embedding vector corresponding to the entire graph. This final output embedding can then be used as feature input to a differentiable classifier (e.g., a softmax layer), and the entire system can be trained end-to-end using stochastic gradient descent.\nPermutation invariance. Note that in order to be useful for graph classification, the pooling layer should be invariant under node permutations. For DIFFPOOL we get the following positive result, which shows that any deep GNN model based on DIFFPOOL is permutation invariant, as long as the component GNNs are permutation invariant.\nProposition 1. Let P \u2208 {0, 1}n\u00d7n be any permutation matrix, then DIFFPOOL(A,Z) = DIFFPOOL(PAPT , PX) as long as GNN(A,X) = GNN(PAPT , X) (i.e., as long as the GNN method used is permutation invariant).\nProof. Equations (5) and (6) are permutation invariant by the assumption that the GNN module is permutation invariant. And since any permutation matrix is orthogonal, applying PTP = I to Equation (3) and (4) finishes the proof."
        },
        {
            "heading": "3.3 Auxiliary Link Prediction Objective and Entropy Regularization",
            "text": "In practice, it can be difficult to train the pooling GNN (Equation 4) using only gradient signal from the graph classification task. Intuitively, we have a non-convex optimization problem and it can be difficult to push the pooling GNN away from spurious local minima early in training. To alleviate this issue, we train the pooling GNN with an auxiliary link prediction objective, which encodes the intuition that nearby nodes should be pooled together. In particular, at each layer l, we minimize LLP = ||A(l), S(l)S(l)\nT ||F , where || \u00b7 ||F denotes the Frobenius norm. Note that the adjacency matrix A(l) at deeper layers is a function of lower level assignment matrices, and changes during training.\nAnother important characteristic of the pooling GNN (Equation 4) is that the output cluster assignment for each node should generally be close to a one-hot vector, so that the membership for each cluster or subgraph is clearly defined. We therefore regularize the entropy of the cluster assignment by minimizing LE = 1n \u2211n i=1H(Si), where H denotes the entropy function, and Si is the i-th row of S.\nDuring training, LLP and LE from each layer are added to the classification loss. In practice we observe that training with the side objective takes longer to converge, but nevertheless achieves better performance and more interpretable cluster assignments."
        },
        {
            "heading": "4 Experiments",
            "text": "We evaluate the benefits of DIFFPOOL against a number of state-of-the-art graph classification approaches, with the goal of answering the following questions:\nQ1 How does DIFFPOOL compare to other pooling methods proposed for GNNs (e.g., using sort pooling [41] or the SET2SET method [15])? Q2 How does DIFFPOOL combined with GNNs compare to the state-of-the-art for graph classification task, including both GNNs and kernel-based methods? Q3 Does DIFFPOOL compute meaningful and interpretable clusters on the input graphs?\nData sets. To probe the ability of DIFFPOOL to learn complex hierarchical structures from graphs in different domains, we evaluate on a variety of relatively large graph data sets chosen from benchmarks commonly used in graph classification [20]. We use protein data sets including ENZYMES, PROTEINS [3, 12], D&D [10], the social network data set REDDIT-MULTI-12K [40], and the scientific collaboration data set COLLAB [40]. See Appendix A for statistics and properties. For all these data sets, we perform 10-fold cross-validation to evaluate model performance, and report the accuracy averaged over 10 folds.\nModel configurations. In our experiments, the GNN model used for DIFFPOOL is built on top of the GRAPHSAGE architecture, as we found this architecture to have superior performance compared to the standard GCN approach as introduced in [22]. We use the \u201cmean\u201d variant of GRAPHSAGE [16] and apply a DIFFPOOL layer after every two GRAPHSAGE layers in our architecture. A total of 2 DIFFPOOL layers are used for the datasets. For small datasets such as ENZYMES and COLLAB, 1 DIFFPOOL layer can achieve similar performance. After each DIFFPOOL layer, 3 layers of graph convolutions are performed, before the next DIFFPOOL layer, or the readout layer. The embedding matrix and the assignment matrix are computed by two separate GRAPHSAGE models respectively. In the 2 DIFFPOOL layer architecture, the number of clusters is set as 25% of the number of nodes before applying DIFFPOOL, while in the 1 DIFFPOOL layer architecture, the number of clusters is set as 10%. Batch normalization [18] is applied after every layer of GRAPHSAGE. We also found that adding an `2 normalization to the node embeddings at each layer made the training more stable. In Section 4.2, we also test an analogous variant of DIFFPOOL on the STRUCTURE2VEC [7] architecture, in order to demonstrate how DIFFPOOL can be applied on top of other GNN models. All models are trained for 3 000 epochs with early stopping applied when the validation loss starts to drop. We also evaluate two simplified versions of DIFFPOOL: \u2022 DIFFPOOL-DET, is a DIFFPOOL model where assignment matrices are generated using a deter-\nministic graph clustering algorithm [9]. \u2022 DIFFPOOL-NOLP is a variant of DIFFPOOL where the link prediction side objective is turned off."
        },
        {
            "heading": "4.1 Baseline Methods",
            "text": "In the performance comparison on graph classification, we consider baselines based upon GNNs (combined with different pooling methods) as well as state-of-the-art kernel-based approaches.\nGNN-based methods. \u2022 GRAPHSAGE with global mean-pooling [16]. Other GNN variants such as those proposed in [22]\nare omitted as empirically GraphSAGE obtained higher performance in the task. \u2022 STRUCTURE2VEC (S2V) [7] is a state-of-the-art graph representation learning algorithm that\ncombines a latent variable model with GNNs. It uses global mean pooling. \u2022 Edge-conditioned filters in CNN for graphs (ECC) [36] incorporates edge information into the\nGCN model and performs pooling using a graph coarsening algorithm.\nFor all the GNN baselines, we use 10-fold cross validation numbers reported by the original authors when possible. For the GRAPHSAGE and SET2SET baselines, we use the base implementation and hyperparameter sweeps as in our DIFFPOOL approach. When baseline approaches did not have the necessary published numbers, we contacted the original authors and used their code (if available) to run the model, performing a hyperparameter search based on the original author\u2019s guidelines.\nKernel-based algorithms. We use the GRAPHLET [35], the SHORTEST-PATH [2], WEISFEILERLEHMAN kernel (WL) [34], and WEISFEILER-LEHMAN OPTIMAL ASSIGNMENT KERNEL (WLOA) [23] as kernel baselines. For each kernel, we computed the normalized gram matrix. We computed the classification accuracies using the C-SVM implementation of LIBSVM [6], using 10-fold cross validation. The C parameter was selected from {10\u22123, 10\u22122, . . . , 102, 103} by 10-fold cross validation on the training folds. Moreover, for WL and WL-OA we additionally selected the number of iteration from {0, . . . , 5}."
        },
        {
            "heading": "4.2 Results for Graph Classification",
            "text": "Table 1 compares the performance of DIFFPOOL to these state-of-the-art graph classification baselines. These results provide positive answers to our motivating questions Q1 and Q2: We observe that our DIFFPOOL approach obtains the highest average performance among all pooling approaches for GNNs, improves upon the base GRAPHSAGE architecture by an average of 6.27%, and achieves stateof-the-art results on 4 out of 5 benchmarks. Interestingly, our simplified model variant, DIFFPOOLDET, achieves state-of-the-art performance on the COLLAB benchmark. This is because many collaboration graphs in COLLAB show only single-layer community structures, which can be captured well with pre-computed graph clustering algorithm [9]. One observation is that despite significant performance improvement, DIFFPOOL could be unstable to train, and there is significant variation in accuracy across different runs, even with the same hyperparameter setting. It is observed that adding the link predictioin objective makes training more stable, and reduces the standard deviation of accuracy across different runs.\nDifferentiable Pooling on STRUCTURE2VEC. DIFFPOOL can be applied to other GNN architectures besides GRAPHSAGE to capture hierarchical structure in the graph data. To further support answering Q1, we also applied DIFFPOOL on Structure2Vec (S2V). We ran experiments using S2V with three layer architecture, as reported in [7]. In the first variant, one DIFFPOOL layer is applied after the first layer of S2V, and two more S2V layers are stacked on top of the output of DIFFPOOL.\nThe second variant applies one DIFFPOOL layer after the first and second layer of S2V respectively. In both variants, S2V model is used to compute the embedding matrix, while GRAPHSAGE model is used to compute the assignment matrix.\nThe results in terms of classification accuracy are summarized in Table 2. We observe that DIFFPOOL significantly improves the performance of S2V on both ENZYMES and D&D data sets. Similar performance trends are also observed on other data sets. The results demonstrate that DIFFPOOL is a general strategy to pool over hierarchical structure that can benefit different GNN architectures.\nRunning time. Although applying DIFFPOOL requires additional computation of an assignment matrix, we observed that DIFFPOOL did not incur substantial additional running time in practice. This is because each DIFFPOOL layer reduces the size of graphs by extracting a coarser representation of the graph, which speeds up the graph convolution operation in the next layer. Concretely, we found that GRAPHSAGE with DIFFPOOL was 12\u00d7 faster than the GRAPHSAGE model with SET2SET pooling, while still achieving significantly higher accuracy on all benchmarks."
        },
        {
            "heading": "4.3 Analysis of Cluster Assignment in DIFFPOOL",
            "text": "Hierarchical cluster structure. To address Q3, we investigated the extent to which DIFFPOOL learns meaningful node clusters by visualizing the cluster assignments in different layers. Figure 2 shows such a visualization of node assignments in the first and second layers on a graph from COLLAB data set, where node color indicates its cluster membership. Node cluster membership is determined by taking the argmax of its cluster assignment probabilities. We observe that even when learning cluster assignment based solely on the graph classification objective, DIFFPOOL can still capture the hierarchical community structure. We also observe significant improvement in membership assignment quality with link prediction auxiliary objectives.\nDense vs. sparse subgraph structure. In addition, we observe that DIFFPOOL learns to collapse nodes into soft clusters in a non-uniform way, with a tendency to collapse densely-connected subgraphs into clusters. Since GNNs can efficiently perform message-passing on dense, clique-like subgraphs (due to their small diameters) [27], pooling together nodes in such a dense subgraph is not likely to lead to any loss of structural information. This intuitively explains why collapsing dense subgraphs is a useful pooling strategy for DIFFPOOL. In contrast, sparse subgraphs may contain many interesting structures, including path-, cycle- and tree-like structures, and given the high-diameter induced by sparsity, GNN message-passing may fail to capture these structures. Thus, by separately pooling distinct parts of a sparse subgraph, DIFFPOOL can learn to capture the meaningful structures present in sparse graph regions (e.g., as in Figure 2).\nAssignment for nodes with similar representations. Since the assignment network computes the soft cluster assignment based on features of input nodes and their neighbors, nodes with both similar input features and neighborhood structure will have similar cluster assignment. In fact, one can construct synthetic cases where 2 nodes, although far away, have exactly the same neighborhood structure and features for self and all neighbors. In this case the pooling network is forced to assign them into the same cluster, which is different from the concept of pooling in other architectures such as image ConvNets. In some cases we do observe that disconnected nodes are pooled together.\nIn practice we rely on the identifiability assumption similar to Theorem 1 in GraphSAGE [16], where nodes are identifiable via their features. This holds in many real datasets 3. The auxiliary link prediction objective is observed to also help discouraging nodes that are far away to be pooled together. Furthermore, it is possible to use more sophisticated GNN aggregation function such as\n3However, some chemistry molecular graph datasets contain many nodes that are structurally similar, and assignment network is observed to pool together nodes that are far away.\nhigh-order moments [38] to distinguish nodes that are similar in structure and feature space. The overall framework remains unchanged.\nSensitivity of the Pre-defined Maximum Number of Clusters. We found that the assignment varies according to the depth of the network and C, the maximum number of clusters. With larger C, the pooling GNN can model more complex hierarchical structure. The trade-off is that very large C results in more noise and less efficiency. Although the value of C is a pre-defined parameter, the pooling net learns to use the appropriate number of clusters by end-to-end training. In particular, some clusters might not be used by the assignment matrix. Column corresponding to unused cluster has low values for all nodes. This is observed in Figure 2(c), where nodes are assigned predominantly into 3 clusters."
        },
        {
            "heading": "5 Conclusion",
            "text": "We introduced a differentiable pooling method for GNNs that is able to extract the complex hierarchical structure of real-world graphs. By using the proposed pooling layer in conjunction with existing GNN models, we achieved new state-of-the-art results on several graph classification benchmarks. Interesting future directions include learning hard cluster assignments to further reduce computational cost in higher layers while also ensuring differentiability, and applying the hierarchical pooling method to other downstream tasks that require modeling of the entire graph structure."
        },
        {
            "heading": "Acknowledgement",
            "text": "This research has been supported in part by DARPA SIMPLEX, Stanford Data Science Initiative, Huawei, JD and Chan Zuckerberg Biohub. Christopher Morris is funded by the German Science Foundation (DFG) within the Collaborative Research Center SFB 876 \u201cProviding Information by Resource-Constrained Data Analysis\u201d, project A6 \u201cResource-efficient Graph Mining\u201d. The authors also thank Marinka Zitnik for help in visualizing the high-level illustration of the proposed methods."
        }
    ],
    "title": "Hierarchical Graph Representation Learning with Differentiable Pooling",
    "year": 2019
}