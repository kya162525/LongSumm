{
    "abstractText": "We present weight normalization: a reparameterization of the weight vectors in a neural network that decouples the length of those weight vectors from their direction. By reparameterizing the weights in this way we improve the conditioning of the optimization problem and we speed up convergence of stochastic gradient descent. Our reparameterization is inspired by batch normalization but does not introduce any dependencies between the examples in a minibatch. This means that our method can also be applied successfully to recurrent models such as LSTMs and to noise-sensitive applications such as deep reinforcement learning or generative models, for which batch normalization is less well suited. Although our method is much simpler, it still provides much of the speed-up of full batch normalization. In addition, the computational overhead of our method is lower, permitting more optimization steps to be taken in the same amount of time. We demonstrate the usefulness of our method on applications in supervised image recognition, generative modelling, and deep reinforcement learning.",
    "authors": [
        {
            "affiliations": [],
            "name": "Tim Salimans"
        },
        {
            "affiliations": [],
            "name": "Diederik P. Kingma"
        }
    ],
    "id": "SP:e23eb8da073cbff012136780a2454ba266b41202",
    "references": [
        {
            "authors": [
                "S. Amari"
            ],
            "title": "Neural learning in structured parameter spaces - natural Riemannian gradient",
            "venue": "Advances in Neural Information Processing Systems, pages 127\u2013133. MIT Press,",
            "year": 1997
        },
        {
            "authors": [
                "M.G. Bellemare",
                "Y. Naddaf",
                "J. Veness",
                "M. Bowling"
            ],
            "title": "The arcade learning environment: An evaluation platform for general agents",
            "venue": "Journal of Artificial Intelligence Research, 47:253\u2013279, 06",
            "year": 2013
        },
        {
            "authors": [
                "G. Desjardins",
                "K. Simonyan",
                "R. Pascanu"
            ],
            "title": "Natural neural networks",
            "venue": "In Advances in Neural Information Processing Systems,",
            "year": 2015
        },
        {
            "authors": [
                "X. Glorot",
                "Y. Bengio"
            ],
            "title": "Understanding the difficulty of training deep feedforward neural networks",
            "venue": "International conference on artificial intelligence and statistics, pages 249\u2013256,",
            "year": 2010
        },
        {
            "authors": [
                "I. Goodfellow",
                "Y. Bengio",
                "A. Courville"
            ],
            "title": "Deep learning",
            "venue": "Book in preparation for MIT Press,",
            "year": 2016
        },
        {
            "authors": [
                "I.J. Goodfellow",
                "D. Warde-Farley",
                "M. Mirza",
                "A. Courville",
                "Y. Bengio"
            ],
            "title": "Maxout networks",
            "venue": "ICML,",
            "year": 2013
        },
        {
            "authors": [
                "K. Gregor",
                "I. Danihelka",
                "A. Graves",
                "D. Wierstra"
            ],
            "title": "Draw: A recurrent neural network for image generation",
            "venue": "arXiv preprint arXiv:1502.04623,",
            "year": 2015
        },
        {
            "authors": [
                "R. Grosse",
                "R. Salakhudinov"
            ],
            "title": "Scaling up natural gradient by sparsely factorizing the inverse fisher matrix",
            "venue": "ICML, pages 2304\u20132313,",
            "year": 2015
        },
        {
            "authors": [
                "K. He",
                "X. Zhang",
                "S. Ren",
                "J. Sun"
            ],
            "title": "Deep residual learning for image recognition",
            "venue": "arXiv preprint arXiv:1512.03385,",
            "year": 2015
        },
        {
            "authors": [
                "S. Hochreiter",
                "J. Schmidhuber"
            ],
            "title": "Long short-term memory",
            "venue": "Neural computation, 9(8):1735\u20131780,",
            "year": 1997
        },
        {
            "authors": [
                "S. Ioffe",
                "C. Szegedy"
            ],
            "title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
            "venue": "ICML,",
            "year": 2015
        },
        {
            "authors": [
                "D. Kingma",
                "J. Ba"
            ],
            "title": "Adam: A method for stochastic optimization",
            "venue": "arXiv preprint arXiv:1412.6980,",
            "year": 2014
        },
        {
            "authors": [
                "D.P. Kingma",
                "M. Welling"
            ],
            "title": "Auto-Encoding Variational Bayes",
            "venue": "Proceedings of the 2nd International Conference on Learning Representations,",
            "year": 2013
        },
        {
            "authors": [
                "P. Kr\u00e4henb\u00fchl",
                "C. Doersch",
                "J. Donahue",
                "T. Darrell"
            ],
            "title": "Data-dependent initializations of convolutional neural networks",
            "venue": "arXiv preprint arXiv:1511.06856,",
            "year": 2015
        },
        {
            "authors": [
                "A. Krizhevsky",
                "G. Hinton"
            ],
            "title": "Learning multiple layers of features from tiny",
            "year": 2009
        },
        {
            "authors": [
                "C.-Y. Lee",
                "S. Xie",
                "P. Gallagher",
                "Z. Zhang",
                "Z. Tu"
            ],
            "title": "Deeply-supervised nets",
            "venue": "Deep Learning and Representation Learning Workshop, NIPS,",
            "year": 2014
        },
        {
            "authors": [
                "M. Lin",
                "C. Qiang",
                "S. Yan"
            ],
            "title": "Network in network",
            "venue": "ICLR: Conference Track,",
            "year": 2014
        },
        {
            "authors": [
                "J. Martens"
            ],
            "title": "Deep learning via hessian-free optimization",
            "venue": "Proceedings of the 27th International Conference on Machine Learning (ICML-10), pages 735\u2013742,",
            "year": 2010
        },
        {
            "authors": [
                "J. Martens",
                "R. Grosse"
            ],
            "title": "Optimizing neural networks with kronecker-factored approximate curvature",
            "venue": "arXiv preprint arXiv:1503.05671,",
            "year": 2015
        },
        {
            "authors": [
                "D. Mishkin",
                "J. Matas"
            ],
            "title": "All you need is a good init",
            "venue": "arXiv preprint arXiv:1511.06422,",
            "year": 2015
        },
        {
            "authors": [
                "V. Mnih",
                "K. Kavukcuoglu",
                "D. Silver",
                "A.A. Rusu",
                "J. Veness",
                "M.G. Bellemare",
                "A. Graves",
                "M. Riedmiller",
                "A.K. Fidjeland",
                "G. Ostrovski"
            ],
            "title": "Human-level control through deep reinforcement learning",
            "venue": "Nature, 518(7540):529\u2013533,",
            "year": 2015
        },
        {
            "authors": [
                "B.T. Polyak",
                "A.B. Juditsky"
            ],
            "title": "Acceleration of stochastic approximation by averaging",
            "venue": "SIAM Journal on Control and Optimization, 30(4):838\u2013855,",
            "year": 1992
        },
        {
            "authors": [
                "T. Raiko",
                "H. Valpola",
                "Y. LeCun"
            ],
            "title": "Deep learning made easier by linear transformations in perceptrons",
            "venue": "International Conference on Artificial Intelligence and Statistics, pages 924\u2013932,",
            "year": 2012
        },
        {
            "authors": [
                "D.J. Rezende",
                "S. Mohamed",
                "D. Wierstra"
            ],
            "title": "Stochastic backpropagation and approximate inference in deep generative models",
            "venue": "ICML, pages 1278\u20131286,",
            "year": 2014
        },
        {
            "authors": [
                "T. Salimans",
                "D.P. Kingma",
                "M. Welling"
            ],
            "title": "Markov chain Monte Carlo and variational inference: Bridging the gap",
            "venue": "ICML,",
            "year": 2015
        },
        {
            "authors": [
                "J.T. Springenberg",
                "A. Dosovitskiy",
                "T. Brox",
                "M. Riedmiller"
            ],
            "title": "Striving for simplicity: The all convolutional net",
            "venue": "ICLR Workshop Track,",
            "year": 2015
        },
        {
            "authors": [
                "N. Srebro",
                "A. Shraibman"
            ],
            "title": "Rank, trace-norm and max-norm",
            "venue": "Proceedings of the 18th Annual Conference on Learning Theory, pages 545\u2014-560,",
            "year": 2005
        },
        {
            "authors": [
                "I. Sutskever",
                "J. Martens",
                "G. Dahl",
                "G. Hinton"
            ],
            "title": "On the importance of initialization and momentum in deep learning",
            "venue": "ICML, pages 1139\u20131147,",
            "year": 2013
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "Recent successes in deep learning have shown that neural networks trained by first-order gradient based optimization are capable of achieving amazing results in diverse domains like computer vision, speech recognition, and language modelling [5]. However, it is also well known that the practical success of first-order gradient based optimization is highly dependent on the curvature of the objective that is optimized. If the condition number of the Hessian matrix of the objective at the optimum is low, the problem is said to exhibit pathological curvature, and first-order gradient descent will have trouble making progress [18, 28]. The amount of curvature, and thus the success of our optimization, is not invariant to reparameterization [1]: there may be multiple equivalent ways of parameterizing the same model, some of which are much easier to optimize than others. Finding good ways of parameterizing neural networks is thus an important problem in deep learning.\nWhile the architectures of neural networks differ widely across applications, they are typically mostly composed of conceptually simple computational building blocks sometimes called neurons: each such neuron computes a weighted sum over its inputs and adds a bias term, followed by the application of an elementwise nonlinear transformation. Improving the general optimizability of deep networks is a challenging task [4], but since many neural architectures share these basic building blocks, improving these building blocks improves the performance of a very wide range of model architectures and could thus be very useful.\nSeveral authors have recently developed methods to improve the conditioning of the cost gradient for general neural network architectures. One approach is to explicitly left multiply the cost gradient with an approximate inverse of the Fisher information matrix, thereby obtaining an approximately whitened natural gradient. Such an approximate inverse can for example be obtained by using a Kronecker factored approximation to the Fisher matrix and inverting it (KFAC, [19]), by using an\nar X\niv :1\n60 2.\n07 86\n8v 3\n[ cs\n.L G\n] 4\nJ un\n2 01\napproximate Cholesky factorization of the inverse Fisher matrix (FANG, [8]), or by whitening the input of each layer in the neural network (PRONG, [3]).\nAlternatively, we can use standard first order gradient descent without preconditioning, but change the parameterization of our model to give gradients that are more like the whitened natural gradients of these methods. For example, Raiko et al. [23] propose to transform the outputs of each neuron to have zero output and zero slope on average. They show that this transformation approximately diagonalizes the Fisher information matrix, thereby whitening the gradient, and that this leads to improved optimization performance. Another approach in this direction is batch normalization [11], a method where the output of each neuron (before application of the nonlinearity) is normalized by the mean and standard deviation of the outputs calculated over the examples in the minibatch. This reduces covariate shift of the neuron outputs and the authors suggest it also brings the Fisher matrix closer to the identity matrix.\nFollowing this second approach to approximate natural gradient optimization, we propose a simple but general method, called weight normalization, for improving the optimizability of the weights of neural network models. The method is inspired by batch normalization, but it is a deterministic method that does not share batch normalization\u2019s property of adding noise to the gradients. In addition, the overhead imposed by our method is lower: no additional memory is required and the additional computation is negligible. The method show encouraging results on a wide range of deep learning applications."
        },
        {
            "heading": "2 Weight Normalization",
            "text": "We consider standard artificial neural networks where the computation of each neuron consists in taking a weighted sum of input features, followed by an elementwise nonlinearity:\ny = \u03c6(w \u00b7 x + b), (1)\nwhere w is a k-dimensional weight vector, b is a scalar bias term, x is a k-dimensional vector of input features, \u03c6(.) denotes an elementwise nonlinearity such as the rectifier max(., 0), and y denotes the scalar output of the neuron.\nAfter associating a loss function to one or more neuron outputs, such a neural network is commonly trained by stochastic gradient descent in the parameters w, b of each neuron. In an effort to speed up the convergence of this optimization procedure, we propose to reparameterize each weight vector w in terms of a parameter vector v and a scalar parameter g and to perform stochastic gradient descent with respect to those parameters instead. We do so by expressing the weight vectors in terms of the new parameters using\nw = g\n||v|| v (2)\nwhere v is a k-dimensional vector, g is a scalar, and ||v|| denotes the Euclidean norm of v. This reparameterization has the effect of fixing the Euclidean norm of the weight vector w: we now have ||w|| = g, independent of the parameters v. We therefore call this reparameterizaton weight normalization.\nThe idea of normalizing the weight vector has been proposed before (e.g. [27]) but earlier work typically still performed optimization in the w-parameterization, only applying the normalization after each step of stochastic gradient descent. This is fundamentally different from our approach: we propose to explicitly reparameterize the model and to perform stochastic gradient descent in the new parameters v, g directly. Doing so improves the conditioning of the gradient and leads to improved convergence of the optimization procedure: By decoupling the norm of the weight vector (g) from the direction of the weight vector (v/||v||), we speed up convergence of our stochastic gradient descent optimization, as we show experimentally in section 5.\nInstead of working with g directly, we may also use an exponential parameterization for the scale, i.e. g = es, where s is a log-scale parameter to learn by stochastic gradient descent. Parameterizing the g parameter in the log-scale is more intuitive and more easily allows g to span a wide range of different magnitudes. Empirically, however, we did not find this to be an advantage. In our experiments, the eventual test-set performance was not significantly better or worse than the results with directly learning g in its original parameterization, and optimization was slightly slower."
        },
        {
            "heading": "2.1 Gradients",
            "text": "Training a neural network in the new parameterization is done using standard stochastic gradient descent methods. Here we differentiate through (2) to obtain the gradient of a loss function L with respect to the new parameters v, g. Doing so gives\n\u2207gL = \u2207wL \u00b7 v ||v|| , \u2207vL = g ||v|| \u2207wL\u2212 g\u2207gL ||v||2 v, (3)\nwhere \u2207wL is the gradient with respect to the weights w as used normally. Backpropagation using weight normalization thus only requires a minor modification to the usual backpropagation equations, and is easily implemented using standard neural network software. We provide reference implementations for Theano at https://github.com/TimSalimans/weight_ norm. Unlike with batch normalization, the expressions above are independent of the minibatch size and thus cause only minimal computational overhead.\nAn alternative way to write the gradient is\n\u2207vL = g\n||v|| Mw\u2207wL, with Mw = I\u2212\nww\u2032\n||w||2 , (4)\nwhere Mw is a projection matrix that projects onto the complement of the w vector. This shows that weight normalization accomplishes two things: it scales the weight gradient by g/||v||, and it projects the gradient away from the current weight vector. Both effects help to bring the covariance matrix of the gradient closer to identity and benefit optimization, as we explain below.\nDue to projecting away from w, the norm of v grows monotonically with the number of weight updates when learning a neural network with weight normalization using standard gradient descent without momentum: Let v\u2032 = v + \u2206v denote our parameter update, with \u2206v \u221d \u2207vL (steepest ascent/descent), then \u2206v is necessarily orthogonal to the current weight vector w since we project away from it when calculating\u2207vL (equation 4). Since v is proportional to w, the update is thus also orthogonal to v and increases its norm by the Pythagorean theorem. Specifically, if ||\u2206v||/||v|| = c the new weight vector will have norm ||v\u2032|| = \u221a ||v||2 + c2||v||2 = \u221a 1 + c2||v|| \u2265 ||v||. The rate of increase will depend on the the variance of the weight gradient. If our gradients are noisy, c will be high and the norm of v will quickly increase, which in turn will decrease the scaling factor g/||v||. If the norm of the gradients is small, we get \u221a 1 + c2 \u2248 1, and the norm of v will stop increasing. Using this mechanism, the scaled gradient self-stabilizes its norm. This property does not strictly hold for optimizers that use separate learning rates for individual parameters, like Adam [12] which we use in experiments, or when using momentum. However, qualitatively we still find the same effect to hold.\nEmpirically, we find that the ability to grow the norm ||v|| makes optimization of neural networks with weight normalization very robust to the value of the learning rate: If the learning rate is too large, the norm of the unnormalized weights grows quickly until an appropriate effective learning rate is reached. Once the norm of the weights has grown large with respect to the norm of the updates, the effective learning rate stabilizes. Neural networks with weight normalization therefore work well with a much wider range of learning rates than when using the normal parameterization. It has been observed that neural networks with batch normalization also have this property [11], which can also be explained by this analysis.\nBy projecting the gradient away from the weight vector w, we also eliminate the noise in that direction. If the covariance matrix of the gradient with respect to w is given by C, the covariance matrix of the gradient in v is given by D = (g2/||v||2)MwCMw. Empirically, we find that w is often (close to) a dominant eigenvector of the covariance matrix C: removing that eigenvector then gives a new covariance matrix D that is closer to the identity matrix, which may further speed up learning."
        },
        {
            "heading": "2.2 Relation to batch normalization",
            "text": "An important source of inspiration for this reparameterization is batch normalization [11], which normalizes the statistics of the pre-activation t for each minibatch as\nt\u2032 = t\u2212 \u00b5[t] \u03c3[t] ,\nwith \u00b5[t], \u03c3[t] the mean and standard deviation of the pre-activations t = v \u00b7 x. For the special case where our network only has a single layer, and the input features x for that layer are whitened (independently distributed with zero mean and unit variance), these statistics are given by \u00b5[t] = 0 and \u03c3[t] = ||v||. In that case, normalizing the pre-activations using batch normalization is equivalent to normalizing the weights using weight normalization.\nConvolutional neural networks usually have much fewer weights than pre-activations, so normalizing the weights is often much cheaper computationally. In addition, the norm of v is non-stochastic, while the minibatch mean \u00b5[t] and variance \u03c32[t] can in general have high variance for small minibatch size. Weight normalization can thus be viewed as a cheaper and less noisy approximation to batch normalization. Although exact equivalence does not usually hold for deeper architectures, we still find that our weight normalization method provides much of the speed-up of full batch normalization. In addition, its deterministic nature and independence on the minibatch input also means that our method can be applied more easily to models like RNNs and LSTMs, as well as noise-sensitive applications like reinforcement learning."
        },
        {
            "heading": "3 Data-Dependent Initialization of Parameters",
            "text": "Besides a reparameterization effect, batch normalization also has the benefit of fixing the scale of the features generated by each layer of the neural network. This makes the optimization robust against parameter initializations for which these scales vary across layers. Since weight normalization lacks this property, we find it is important to properly initialize our parameters. We propose to sample the elements of v from a simple distribution with a fixed scale, which is in our experiments a normal distribution with mean zero and standard deviation 0.05. Before starting training, we then initialize the b and g parameters to fix the minibatch statistics of all pre-activations in our network, just like in batch normalization, but only for a single minibatch of data and only during initialization. This can be done efficiently by performing an initial feedforward pass through our network for a single minibatch of data X, using the following computation at each neuron:\nt = v \u00b7 x ||v|| , and y = \u03c6 ( t\u2212 \u00b5[t] \u03c3[t] ) , (5)\nwhere \u00b5[t] and \u03c3[t] are the mean and standard deviation of the pre-activation t over the examples in the minibatch. We can then initialize the neuron\u2019s biase b and scale g as\ng \u2190 1 \u03c3[t] , b\u2190 \u2212\u00b5[t] \u03c3[t] , (6)\nso that y = \u03c6(w \u00b7x+ b). Like batch normalization, this method ensures that all features initially have zero mean and unit variance before application of the nonlinearity. With our method this only holds for the minibatch we use for initialization, and subsequent minibatches may have slightly different statistics, but experimentally we find this initialization method to work well. The method can also be applied to networks without weight normalization, simply by doing stochastic gradient optimization on the parameters w directly, after initialization in terms of v and g: this is what we compare to in section 5. Independently from our work, this type of initialization was recently proposed by different authors [20, 14] who found such data-based initialization to work well for use with the standard parameterization in terms of w.\nThe downside of this initialization method is that it can only be applied in similar cases as where batch normalization is applicable. For models with recursion, such as RNNs and LSTMs, we will have to resort to standard initialization methods."
        },
        {
            "heading": "4 Mean-only Batch Normalization",
            "text": "Weight normalization, as introduced in section 2, makes the scale of neuron activations approximately independent of the parameters v. Unlike with batch normalization, however, the means of the neuron activations still depend on v. We therefore also explore the idea of combining weight normalization with a special version of batch normalization, which we call mean-only batch normalization: With this normalization method, we subtract out the minibatch means like with full batch normalization,\nbut we do not divide by the minibatch standard deviations. That is, we compute neuron activations using t = w \u00b7 x, t\u0303 = t\u2212 \u00b5[t] + b, y = \u03c6(t\u0303) (7) where w is the weight vector, parameterized using weight normalization, and \u00b5[t] is the minibatch mean of the pre-activation t. During training, we keep a running average of the minibatch mean which we substitute in for \u00b5[t] at test time.\nThe gradient of the loss with respect to the pre-activation t is calculated as\n\u2207tL = \u2207t\u0303L\u2212 \u00b5[\u2207t\u0303L], (8) where \u00b5[.] denotes once again the operation of taking the minibatch mean. Mean-only batch normalization thus has the effect of centering the gradients that are backpropagated. This is a comparatively cheap operation, and the computational overhead of mean-only batch normalization is thus lower than for full batch normalization. In addition, this method causes less noise during training, and the noise that is caused is more gentle as the law of large numbers ensures that \u00b5[t] and \u00b5[\u2207t\u0303] are approximately normally distributed. Thus, the added noise has much lighter tails than the highly kurtotic noise caused by the minibatch estimate of the variance used in full batch normalization. As we show in section 5.1, this leads to improved accuracy at test time."
        },
        {
            "heading": "5 Experiments",
            "text": "We experimentally validate the usefulness of our method using four different models for varied applications in supervised image recognition, generative modelling, and deep reinforcement learning."
        },
        {
            "heading": "5.1 Supervised Classification: CIFAR-10",
            "text": "To test our reparameterization method for the application of supervised classification, we consider the CIFAR-10 data set of natural images [15]. The model we are using is based on the ConvPool-CNN-C architecture of [26], with some small modifications: we replace the first dropout layer by a layer that adds Gaussian noise, we expand the last hidden layer from 10 units to 192 units, and we use 2 \u00d7 2 max-pooling, rather than 3 \u00d7 3. The only hyperparameter that we actively optimized (the standard deviation of the Gaussian noise) was chosen to maximize the performance of the network on a holdout set of 10000 examples, using the standard parameterization (no weight normalization or batch normalization). A full description of the resulting architecture is given in table A in the supplementary material.\nWe train our network for CIFAR-10 using Adam [12] for 200 epochs, with a fixed learning rate and momentum of 0.9 for the first 100 epochs. For the last 100 epochs we set the momentum to 0.5 and linearly decay the learning rate to zero. We use a minibatch size of 100. We evaluate 5 different parameterizations of the network: 1) the standard parameterization, 2) using batch normalization, 3) using weight normalization, 4) using weight normalization combined with mean-only batch normalization, 5) using mean-only batch normalization with the normal parameterization. The network parameters are initialized using the scheme of section 3 such that all four cases have identical parameters starting out. For each case we pick the optimal learning rate in {0.0003, 0.001, 0.003, 0.01}. The resulting error curves during training can be found in figure 1: both weight normalization and batch normalization provide a significant speed-up over the standard parameterization. Batch normalization makes slightly more progress per epoch than weight normalization early on, although this is partly offset by the higher computational cost: with our implementation, training with batch normalization was about 16% slower compared to the standard parameterization. In contrast, weight normalization was not noticeably slower. During the later stage of training, weight normalization and batch normalization seem to optimize at about the same speed, with the normal parameterization (with or without mean-only batch normalization) still lagging behind.\nAfter optimizing the network for 200 epochs using the different parameterizations, we evaluate their performance on the CIFAR-10 test set. The results are summarized in table 2: weight normalization, the normal parameterization, and mean-only batch normalization have similar test accuracy (\u2248 8.5% error). Batch normalization does significantly better at 8.05% error. Mean-only batch normalization combined with weight normalization has the best performance at 7.31% test error, and interestingly does much better than mean-only batch normalization combined with the normal parameterization: This suggests that the noise added by batch normalization can be useful for regularizing the network,\nbut that the reparameterization provided by weight normalization or full batch normalization is also needed for optimal results. We hypothesize that the substantial improvement by mean-only B.N. with weight normalization over regular batch normalization is due to the distribution of the noise caused by the normalization method during training: for mean-only batch normalization the minibatch mean has a distribution that is approximately Gaussian, while the noise added by full batch normalization during training has much higher kurtosis. As far as we are aware, the result with mean-only batch normalization combined with weight normalization represents the state-of-the-art for CIFAR-10 among methods that do not use data augmentation."
        },
        {
            "heading": "5.2 Generative Modelling: Convolutional VAE",
            "text": "Next, we test the effect of weight normalization applied to deep convolutional variational autoencoders (CVAEs) [13, 24, 25], trained on the MNIST data set of images of handwritten digits and the CIFAR-10 data set of small natural images.\nVariational auto-encoders are generative models that explain the data vector x as arising from a set of latent variables z, through a joint distribution of the form p(z,x) = p(z)p(x|z), where the decoder p(x|z) is specified using a neural network. A lower bound on the log marginal likelihood log p(x) can be obtained by approximately inferring the latent variables z from the observed data x using an encoder distribution q(z|x) that is also specified as a neural network. This lower bound is then optimized to fit the model to the data.\nWe follow a similar implementation of the CVAE as in [25] with some modifications, mainly that the encoder and decoder are parameterized with ResNet [9] blocks, and that the diagonal posterior is replaced with auto-regressive variational inference1. For MNIST, the encoder consists of 3 sequences of two ResNet blocks each, the first sequence acting on 16 feature maps, the others on 32 feature maps. The first two sequences are followed by a 2-times subsampling operation implemented using 2 \u00d7 2 stride, while the third sequence is followed by a fully connected layer with 450 units. The decoder has a similar architecture, but with reversed direction. For CIFAR-10, we used a neural architecture with ResNet units and multiple intermediate stochastic layers1. We used Adamax [12] with \u03b1 = 0.002 for optimization, in combination with Polyak averaging [22] in the form of an exponential moving average that averages parameters over approximately 10 epochs.\nIn figure 3, we plot the test-set lower bound as a function of number of training epochs, including error bars based on multiple different random seeds for initializing parameters. As can be seen, the parameterization with weight normalization has lower variance and converges to a better optimum. We observe similar results across different hyper-parameter settings.\n1Manuscript in preparation"
        },
        {
            "heading": "5.3 Generative Modelling: DRAW",
            "text": "Next, we consider DRAW, a recurrent generative model by [7]. DRAW is a variational auto-encoder with generative model p(z)p(x|z) and encoder q(z|x), similar to the model in section 5.2, but with both the encoder and decoder consisting of a recurrent neural network comprised of Long Short-Term Memory (LSTM) [10] units. LSTM units consist of a memory cell with additive dynamics, combined with input, forget, and output gates that determine which information flows in and out of the memory. The additive dynamics enables learning of long-range dependencies in the data.\nAt each time step of the model, DRAW uses the same set of weight vectors to update the cell states of the LSTM units in its encoder and decoder. Because of the recurrent nature of this process it is not clear how batch normalization could be applied to this model: Normalizing the cell states diminishes their ability to pass through information. Fortunately, weight normalization can be applied trivially to the weight vectors of each LSTM unit, and we find this to work well empirically.\nWe take the Theano implementation of DRAW provided at https://github.com/jbornschein/ draw and use it to model the MNIST data set of handwritten digits. We then make a single modification to the model: we apply weight normalization to all weight vectors. As can be seen in figure 4, this significantly speeds up convergence of the optimization procedure, even without modifying the initialization method and learning rate that were tuned for use with the normal parameterization."
        },
        {
            "heading": "5.4 Reinforcement Learning: DQN",
            "text": "Next we apply weight normalization to the problem of Reinforcement Learning for playing games on the Atari Learning Environment [2]. The approach we use is the Deep Q-Network (DQN) proposed by [21]. This is an application for which batch normalization is not well suited: the noise introduced by estimating the minibatch statistics destabilizes the learning process. We were not able to get batch normalization to work for DQN without using an impractically large minibatch size. In contrast, weight normalization is easy to apply in this context, as is the initialization method of section 3. Stochastic gradient learning is performed using Adamax [12] with momentum of 0.5. We search for optimal learning rates in {0.0001, 0.0003, 0.001, 0.003}, generally finding 0.0003 to work well with weight normalization and 0.0001 to work well for the normal parameterization. We also use a larger minibatch size (64) which we found to be more efficient on our hardware (Amazon Elastic Compute Cloud g2.2xlarge GPU instance). Apart from these changes we follow [21] as closely as possible in terms of parameter settings and evaluation methods. However, we use a Python/Theano/Lasagne reimplementation of their work, adapted from the implementation available at https://github.com/spragunr/deep_q_rl, so there may be small additional differences in implementation.\nFigure 5 shows the training curves obtained using DQN with the standard parameterization and with weight normalization on Space Invaders. Using weight normalization the algorithm progresses more quickly and reaches a better final result. Table 6 shows the final evaluation scores obtained by DQN with weight normalization for four games: on average weight normalization improves the performance of DQN."
        },
        {
            "heading": "6 Conclusion",
            "text": "We have presented weight normalization, a simple reparameterization of the weight vectors in a neural network that accelerates the convergence of stochastic gradient descent optimization. Weight normalization was applied to four different models in supervised image recognition, generative modelling, and deep reinforcement learning, showing a consistent advantage across applications. The reparameterization method is easy to apply, has low computational overhead, and does not introduce dependencies between the examples in a minibatch, making it our default choice in the development of new deep learning architectures."
        },
        {
            "heading": "Acknowledgments",
            "text": "We thank John Schulman for helpful comments on an earlier draft of this paper."
        },
        {
            "heading": "A Neural network architecure for CIFAR-10 experiments",
            "text": ""
        }
    ],
    "title": "Weight Normalization: A Simple Reparameterization to Accelerate Training of Deep Neural Networks",
    "year": 2016
}