{
    "abstractText": "It is known that the learning rate is the most important hyper-parameter to tune for training deep neural networks. This paper describes a new method for setting the learning rate, named cyclical learning rates, which practically eliminates the need to experimentally find the best values and schedule for the global learning rates. Instead of monotonically decreasing the learning rate, this method lets the learning rate cyclically vary between reasonable boundary values. Training with cyclical learning rates instead of fixed values achieves improved classification accuracy without a need to tune and often in fewer iterations. This paper also describes a simple way to estimate \u201creasonable bounds\u201d \u2013 linearly increasing the learning rate of the network for a few epochs. In addition, cyclical learning rates are demonstrated on the CIFAR-10 and CIFAR-100 datasets with ResNets, Stochastic Depth networks, and DenseNets, and the ImageNet dataset with the AlexNet and GoogLeNet architectures. These are practical tools for everyone who trains neural networks.",
    "authors": [
        {
            "affiliations": [],
            "name": "Leslie N. Smith"
        }
    ],
    "id": "SP:c95a65738554b82fbae159923ab834728500c7b3",
    "references": [
        {
            "authors": [
                "K. Bache",
                "D. DeCoste",
                "P. Smyth"
            ],
            "title": "Hot swapping for online adaptation of optimization hyperparameters",
            "venue": "arXiv preprint arXiv:1412.6599,",
            "year": 2014
        },
        {
            "authors": [
                "Y. Bengio"
            ],
            "title": "Neural Networks: Tricks of the Trade, chapter Practical recommendations for gradient-based training of deep architectures, pages 437\u2013478",
            "year": 2012
        },
        {
            "authors": [
                "T.M. Breuel"
            ],
            "title": "The effects of hyperparameters on sgd training of neural networks",
            "venue": "arXiv preprint arXiv:1508.02788,",
            "year": 2015
        },
        {
            "authors": [
                "Y.N. Dauphin",
                "H. de Vries",
                "J. Chung",
                "Y. Bengio"
            ],
            "title": "Rmsprop and equilibrated adaptive learning rates for non-convex optimization",
            "venue": "arXiv preprint arXiv:1502.04390,",
            "year": 2015
        },
        {
            "authors": [
                "J. Duchi",
                "E. Hazan",
                "Y. Singer"
            ],
            "title": "Adaptive subgradient methods for online learning and stochastic optimization",
            "venue": "The Journal of Machine Learning Research,",
            "year": 2011
        },
        {
            "authors": [
                "A.P. George",
                "W.B. Powell"
            ],
            "title": "Adaptive stepsizes for recursive estimation with applications in approximate dynamic programming",
            "venue": "Machine learning,",
            "year": 2006
        },
        {
            "authors": [
                "R. Girshick",
                "J. Donahue",
                "T. Darrell",
                "J. Malik"
            ],
            "title": "Rich feature hierarchies for accurate object detection and semantic segmentation",
            "venue": "In Computer Vision and Pattern Recognition (CVPR),",
            "year": 2014
        },
        {
            "authors": [
                "A. Graves",
                "N. Jaitly"
            ],
            "title": "Towards end-to-end speech recognition with recurrent neural networks",
            "venue": "In Proceedings of the 31st International Conference on Machine Learning (ICML-",
            "year": 2014
        },
        {
            "authors": [
                "C. Gulcehre",
                "Y. Bengio"
            ],
            "title": "Adasecant: Robust adaptive secant method for stochastic gradient",
            "venue": "arXiv preprint arXiv:1412.7419,",
            "year": 2014
        },
        {
            "authors": [
                "K. He",
                "X. Zhang",
                "S. Ren",
                "J. Sun"
            ],
            "title": "Deep residual learning for image recognition",
            "venue": "Computer Vision and Pattern Recognition (CVPR),",
            "year": 2016
        },
        {
            "authors": [
                "K. He",
                "X. Zhang",
                "S. Ren",
                "J. Sun"
            ],
            "title": "Identity mappings in deep residual networks",
            "venue": "arXiv preprint arXiv:1603.05027,",
            "year": 2016
        },
        {
            "authors": [
                "G. Huang",
                "Z. Liu",
                "K.Q. Weinberger"
            ],
            "title": "Densely connected convolutional networks",
            "venue": "arXiv preprint arXiv:1608.06993,",
            "year": 2016
        },
        {
            "authors": [
                "G. Huang",
                "Y. Sun",
                "Z. Liu",
                "D. Sedra",
                "K. Weinberger"
            ],
            "title": "Deep networks with stochastic depth",
            "venue": "arXiv preprint arXiv:1603.09382,",
            "year": 2016
        },
        {
            "authors": [
                "B. Huval",
                "T. Wang",
                "S. Tandon",
                "J. Kiske",
                "W. Song",
                "J. Pazhayampallil",
                "M. Andriluka",
                "R. Cheng-Yue",
                "F. Mujica",
                "A. Coates"
            ],
            "title": "An empirical evaluation of deep learning on highway driving",
            "venue": "arXiv preprint arXiv:1504.01716,",
            "year": 2015
        },
        {
            "authors": [
                "S. Ioffe",
                "C. Szegedy"
            ],
            "title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
            "venue": "arXiv preprint arXiv:1502.03167,",
            "year": 2015
        },
        {
            "authors": [
                "D. Kingma",
                "J. Lei-Ba"
            ],
            "title": "Adam: a method for stochastic optimization",
            "venue": "arXiv preprint arXiv:1412.6980,",
            "year": 2015
        },
        {
            "authors": [
                "A. Krizhevsky",
                "I. Sutskever",
                "G.E. Hinton"
            ],
            "title": "Imagenet classification with deep convolutional neural networks",
            "venue": "Advances in neural information processing systems,",
            "year": 2012
        },
        {
            "authors": [
                "I. Loshchilov",
                "F. Hutter"
            ],
            "title": "Sgdr: Stochastic gradient descent with restarts",
            "venue": "arXiv preprint arXiv:1608.03983,",
            "year": 2016
        },
        {
            "authors": [
                "Y. Nesterov"
            ],
            "title": "A method of solving a convex programming problem with convergence rate o (1/k2)",
            "venue": "In Soviet Mathematics Doklady,",
            "year": 1983
        },
        {
            "authors": [
                "S. Ruder"
            ],
            "title": "An overview of gradient descent optimization algorithms",
            "venue": "arXiv preprint arXiv:1600.04747,",
            "year": 2016
        },
        {
            "authors": [
                "O. Russakovsky",
                "J. Deng",
                "H. Su",
                "J. Krause",
                "S. Satheesh",
                "S. Ma",
                "Z. Huang",
                "A. Karpathy",
                "A. Khosla",
                "M. Bernstein",
                "A.C. Berg",
                "L. Fei-Fei"
            ],
            "title": "ImageNet Large Scale Visual Recognition Challenge",
            "venue": "International Journal of Computer Vision (IJCV),",
            "year": 2015
        },
        {
            "authors": [
                "T. Schaul",
                "S. Zhang",
                "Y. LeCun"
            ],
            "title": "No more pesky learning rates",
            "venue": "arXiv preprint arXiv:1206.1106,",
            "year": 2012
        },
        {
            "authors": [
                "K. Simonyan",
                "A. Zisserman"
            ],
            "title": "Very deep convolutional networks for large-scale image recognition",
            "venue": "arXiv preprint arXiv:1409.1556,",
            "year": 2014
        },
        {
            "authors": [
                "I. Sutskever",
                "O. Vinyals",
                "Q.V. Le"
            ],
            "title": "Sequence to sequence learning with neural networks",
            "venue": "In Advances in Neural Information Processing Systems,",
            "year": 2014
        },
        {
            "authors": [
                "C. Szegedy",
                "W. Liu",
                "Y. Jia",
                "P. Sermanet",
                "S. Reed",
                "D. Anguelov",
                "D. Erhan",
                "V. Vanhoucke",
                "A. Rabinovich"
            ],
            "title": "Going deeper with convolutions",
            "venue": "arXiv preprint arXiv:1409.4842,",
            "year": 2014
        },
        {
            "authors": [
                "Y. Taigman",
                "M. Yang",
                "M. Ranzato",
                "L. Wolf"
            ],
            "title": "Deepface: Closing the gap to human-level performance in face verification",
            "venue": "In Computer Vision and Pattern Recognition (CVPR),",
            "year": 2014
        },
        {
            "authors": [
                "T. Tieleman",
                "G. Hinton"
            ],
            "title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude",
            "venue": "COURSERA: Neural Networks for Machine Learning,",
            "year": 2012
        },
        {
            "authors": [
                "O. Vinyals",
                "A. Toshev",
                "S. Bengio",
                "D. Erhan"
            ],
            "title": "Show and tell: A neural image caption generator",
            "venue": "arXiv preprint arXiv:1411.4555,",
            "year": 2014
        },
        {
            "authors": [
                "M.D. Zeiler"
            ],
            "title": "Adadelta: an adaptive learning rate method",
            "venue": "arXiv preprint arXiv:1212.5701,",
            "year": 2012
        }
    ],
    "sections": [
        {
            "heading": "1. Introduction",
            "text": "Deep neural networks are the basis of state-of-the-art results for image recognition [17, 23, 25], object detection [7], face recognition [26], speech recognition [8], machine translation [24], image caption generation [28], and driverless car technology [14]. However, training a deep neural network is a difficult global optimization problem.\nA deep neural network is typically updated by stochastic gradient descent and the parameters \u03b8 (weights) are updated by \u03b8t = \u03b8t\u22121 \u2212 t \u2202L\u2202\u03b8 , where L is a loss function and t is the learning rate. It is well known that too small a learning rate will make a training algorithm converge slowly while too large a learning rate will make the training algorithm diverge [2]. Hence, one must experiment with a variety of learning rates and schedules.\nConventional wisdom dictates that the learning rate should be a single value that monotonically decreases dur-\ning training. This paper demonstrates the surprising phenomenon that a varying learning rate during training is beneficial overall and thus proposes to let the global learning rate vary cyclically within a band of values instead of setting it to a fixed value. In addition, this cyclical learning rate (CLR) method practically eliminates the need to tune the learning rate yet achieve near optimal classification accuracy. Furthermore, unlike adaptive learning rates, the CLR methods require essentially no additional computation.\nThe potential benefits of CLR can be seen in Figure 1, which shows the test data classification accuracy of the CIFAR-10 dataset during training1. The baseline (blue curve) reaches a final accuracy of 81.4% after 70, 000 iterations. In contrast, it is possible to fully train the network using the CLR method instead of tuning (red curve) within 25,000 iterations and attain the same accuracy.\nThe contributions of this paper are:\n1. A methodology for setting the global learning rates for training neural networks that eliminates the need to perform numerous experiments to find the best values and schedule with essentially no additional computation.\n2. A surprising phenomenon is demonstrated - allowing\n1Hyper-parameters and architecture were obtained in April 2015 from caffe.berkeleyvision.org/gathered/examples/cifar10.html\nar X\niv :1\n50 6.\n01 18\n6v 6\n[ cs\n.C V\n] 4\nA pr\n2 01\nthe learning rate to rise and fall is beneficial overall even though it might temporarily harm the network\u2019s performance.\n3. Cyclical learning rates are demonstrated with ResNets, Stochastic Depth networks, and DenseNets on the CIFAR-10 and CIFAR-100 datasets, and on ImageNet with two well-known architectures: AlexNet [17] and GoogleNet [25]."
        },
        {
            "heading": "2. Related work",
            "text": "The book \u201cNeural Networks: Tricks of the Trade\u201d is a terrific source of practical advice. In particular, Yoshua Bengio [2] discusses reasonable ranges for learning rates and stresses the importance of tuning the learning rate. A technical report by Breuel [3] provides guidance on a variety of hyper-parameters. There are also a numerous websites giving practical suggestions for setting the learning rates.\nAdaptive learning rates: Adaptive learning rates can be considered a competitor to cyclical learning rates because one can rely on local adaptive learning rates in place of global learning rate experimentation but there is a significant computational cost in doing so. CLR does not possess this computational costs so it can be used freely.\nA review of the early work on adaptive learning rates can be found in George and Powell [6]. Duchi, et al. [5] proposed AdaGrad, which is one of the early adaptive methods that estimates the learning rates from the gradients.\nRMSProp is discussed in the slides by Geoffrey Hinton2 [27]. RMSProp is described there as \u201cDivide the learning rate for a weight by a running average of the magnitudes of recent gradients for that weight.\u201d RMSProp is a fundamental adaptive learning rate method that others have built on.\nSchaul et al. [22] discuss an adaptive learning rate based on a diagonal estimation of the Hessian of the gradients. One of the features of their method is that they allow their automatic method to decrease or increase the learning rate. However, their paper seems to limit the idea of increasing learning rate to non-stationary problems. On the other hand, this paper demonstrates that a schedule of increasing the learning rate is more universally valuable.\nZeiler [29] describes his AdaDelta method, which improves on AdaGrad based on two ideas: limiting the sum of squared gradients over all time to a limited window, and making the parameter update rule consistent with a units evaluation on the relationship between the update and the Hessian.\nMore recently, several papers have appeared on adaptive learning rates. Gulcehre and Bengio [9] propose an adaptive learning rate algorithm, called AdaSecant, that utilizes the\n2www.cs.toronto.edu/ tijmen/csc321/slides/lecture slides lec6.pdf\nroot mean square statistics and variance of the gradients. Dauphin et al. [4] show that RMSProp provides a biased estimate and go on to describe another estimator, named ESGD, that is unbiased. Kingma and Lei-Ba [16] introduce Adam that is designed to combine the advantages from AdaGrad and RMSProp. Bache, et al. [1] propose exploiting solutions to a multi-armed bandit problem for learning rate selection. A summary and tutorial of adaptive learning rates can be found in a recent paper by Ruder [20].\nAdaptive learning rates are fundamentally different from CLR policies, and CLR can be combined with adaptive learning rates, as shown in Section 4.1. In addition, CLR policies are computationally simpler than adaptive learning rates. CLR is likely most similar to the SGDR method [18] that appeared recently."
        },
        {
            "heading": "3. Optimal Learning Rates",
            "text": ""
        },
        {
            "heading": "3.1. Cyclical Learning Rates",
            "text": "The essence of this learning rate policy comes from the observation that increasing the learning rate might have a short term negative effect and yet achieve a longer term beneficial effect. This observation leads to the idea of letting the learning rate vary within a range of values rather than adopting a stepwise fixed or exponentially decreasing value. That is, one sets minimum and maximum boundaries and the learning rate cyclically varies between these bounds. Experiments with numerous functional forms, such as a triangular window (linear), a Welch window (parabolic) and a Hann window (sinusoidal) all produced equivalent results This led to adopting a triangular window (linearly increasing then linearly decreasing), which is illustrated in Figure 2, because it is the simplest function that incorporates this idea. The rest of this paper refers to this as the triangular learning rate policy.\nAn intuitive understanding of why CLR methods work comes from considering the loss function topology. Dauphin et al. [4] argue that the difficulty in minimizing the loss arises from saddle points rather than poor local minima.\nSaddle points have small gradients that slow the learning process. However, increasing the learning rate allows more rapid traversal of saddle point plateaus. A more practical reason as to why CLR works is that, by following the methods in Section 3.3, it is likely the optimum learning rate will be between the bounds and near optimal learning rates will be used throughout training.\nThe red curve in Figure 1 shows the result of the triangular policy on CIFAR-10. The settings used to create the red curve were a minimum learning rate of 0.001 (as in the original parameter file) and a maximum of 0.006. Also, the cycle length (i.e., the number of iterations until the learning rate returns to the initial value) is set to 4, 000 iterations (i.e., stepsize = 2000) and Figure 1 shows that the accuracy peaks at the end of each cycle.\nImplementation of the code for a new learning rate policy is straightforward. An example of the code added to Torch 7 in the experiments shown in Section 4.1.2 is the following few lines:\nl o c a l c y c l e = math . f l o o r (1 + epochCoun te r / ( 2\u2217 s t e p s i z e ) ) l o c a l x = math . abs ( epochCoun te r / s t e p s i z e \u2212 2\u2217 c y c l e + 1) l o c a l l r = o p t . LR + ( maxLR \u2212 o p t . LR) \u2217 math . max ( 0 , (1\u2212x ) )\nwhere opt.LR is the specified lower (i.e., base) learning rate, epochCounter is the number of epochs of training, and lr is the computed learning rate. This policy is named triangular and is as described above, with two new input parameters defined: stepsize (half the period or cycle length) andmax lr (the maximum learning rate boundary). This code varies the learning rate linearly between the minimum (base lr) and the maximum (max lr).\nIn addition to the triangular policy, the following CLR policies are discussed in this paper:\n1. triangular2; the same as the triangular policy except the learning rate difference is cut in half at the end of each cycle. This means the learning rate difference drops after each cycle.\n2. exp range; the learning rate varies between the minimum and maximum boundaries and each boundary value declines by an exponential factor of gammaiteration."
        },
        {
            "heading": "3.2. How can one estimate a good value for the cycle",
            "text": "length?\nThe length of a cycle and the input parameter stepsize can be easily computed from the number of iterations in an epoch. An epoch is calculated by dividing the number of training images by the batchsize used. For example, CIFAR-10 has 50, 000 training images and the batchsize is 100 so an epoch = 50, 000/100 = 500 iterations. The final\naccuracy results are actually quite robust to cycle length but experiments show that it often is good to set stepsize equal to 2 \u2212 10 times the number of iterations in an epoch. For example, setting stepsize = 8 \u2217 epoch with the CIFAR-10 training run (as shown in Figure 1) only gives slightly better results than setting stepsize = 2 \u2217 epoch.\nFurthermore, there is a certain elegance to the rhythm of these cycles and it simplifies the decision of when to drop learning rates and when to stop the current training run. Experiments show that replacing each step of a constant learning rate with at least 3 cycles trains the network weights most of the way and running for 4 or more cycles will achieve even better performance. Also, it is best to stop training at the end of a cycle, which is when the learning rate is at the minimum value and the accuracy peaks."
        },
        {
            "heading": "3.3. How can one estimate reasonable minimum and",
            "text": "maximum boundary values?\nThere is a simple way to estimate reasonable minimum and maximum boundary values with one training run of the network for a few epochs. It is a \u201cLR range test\u201d; run your model for several epochs while letting the learning rate increase linearly between low and high LR values. This test is enormously valuable whenever you are facing a new architecture or dataset.\nThe triangular learning rate policy provides a simple mechanism to do this. For example, in Caffe, set base lr to the minimum value and set max lr to the maximum value. Set both the stepsize and max iter to the same number of iterations. In this case, the learning rate will increase linearly from the minimum value to the maximum value during this short run. Next, plot the accuracy versus learning rate. Note the learning rate value when the accuracy starts to increase and when the accuracy slows, becomes ragged, or\nstarts to fall. These two learning rates are good choices for bounds; that is, set base lr to the first value and set max lr to the latter value. Alternatively, one can use the rule of thumb that the optimum learning rate is usually within a factor of two of the largest one that converges [2] and set base lr to 13 or 1 4 of max lr.\nFigure 3 shows an example of making this type of run with the CIFAR-10 dataset, using the architecture and hyper-parameters provided by Caffe. One can see from Figure 3 that the model starts converging right away, so it is reasonable to set base lr = 0.001. Furthermore, above a learning rate of 0.006 the accuracy rise gets rough and eventually begins to drop so it is reasonable to set max lr = 0.006.\nWhenever one is starting with a new architecture or dataset, a single LR range test provides both a good LR value and a good range. Then one should compare runs with a fixed LR versus CLR with this range. Whichever wins can be used with confidence for the rest of one\u2019s experiments."
        },
        {
            "heading": "4. Experiments",
            "text": "The purpose of this section is to demonstrate the effectiveness of the CLR methods on some standard datasets and with a range of architectures. In the subsections below, CLR policies are used for training with the CIFAR-10, CIFAR100, and ImageNet datasets. These three datasets and a variety of architectures demonstrate the versatility of CLR."
        },
        {
            "heading": "4.1. CIFAR-10 and CIFAR-100",
            "text": ""
        },
        {
            "heading": "4.1.1 Caffe\u2019s CIFAR-10 architecture",
            "text": "The CIFAR-10 architecture and hyper-parameter settings on the Caffe website are fairly standard and were used here as a baseline. As discussed in Section 3.2, an epoch is equal\nto 500 iterations and a good setting for stepsize is 2, 000. Section 3.3 discussed how to estimate reasonable minimum and maximum boundary values for the learning rate from Figure 3. All that is needed to optimally train the network is to set base lr = 0.001 and max lr = 0.006. This is all that is needed to optimally train the network. For the triangular2 policy run shown in Figure 1, the stepsize and learning rate bounds are shown in Table 2.\nFigure 1 shows the result of running with the triangular2 policy with the parameter setting in Table 2. As shown in Table 1, one obtains the same test classification accuracy of 81.4% after only 25, 000 iterations with the triangular2 policy as obtained by running the standard hyper-parameter settings for 70, 000 iterations.\nOne might speculate that the benefits from the triangular policy derive from reducing the learning rate because this is when the accuracy climbs the most. As a test, a decay policy was implemented where the learning rate starts at the max lr value and then is linearly reduced to the base lr value for stepsize number of iterations. After that, the learning rate is fixed to base lr. For the decay policy, max lr = 0.007, base lr = 0.001, and stepsize = 4000. Table 1 shows that the final accuracy is only 78.5%, providing evidence that both increasing and decreasing the learning rate are essential for the benefits of the CLR method.\nFigure 4 compares the exp learning rate policy in Caffe with the new exp range policy using gamma = 0.99994 for both policies. The result is that when using the exp range policy one can stop training at iteration 42, 000 with a test accuracy of 82.2% (going to iteration 70, 000 does not improve on this result). This is substantially better than the best test accuracy of 79.1% one obtains from using the exp learning rate policy.\nThe current Caffe download contains additional architectures and hyper-parameters for CIFAR-10 and in particular there is one with sigmoid non-linearities and batch normalization. Figure 6 compares the training accuracy using the downloaded hyper-parameters with a fixed learning rate (blue curve) to using a cyclical learning rate (red curve). As can be seen in this Figure, the final accuracy for the fixed learning rate (60.8%) is substantially lower than the cyclical learning rate final accuracy (72.2%). There is clear performance improvement when using CLR with this architecture containing sigmoids and batch normalization.\nExperiments were carried out with architectures featuring both adaptive learning rate methods and CLR. Table 3 lists the final accuracy values from various adaptive learning rate methods, run with and without CLR. All of the adaptive methods in Table 3 were run by invoking the respective option in Caffe. The learning rate boundaries are given in Table 3 (just below the method\u2019s name), which were determined by using the technique described in Section 3.3. Just the lower bound was used for base lr for the fixed policy.\nTable 3 shows that for some adaptive learning rate methods combined with CLR, the final accuracy after only 25,000 iterations is equivalent to the accuracy obtained without CLR after 70,000 iterations. For others, it was necessary (even with CLR) to run until 70,000 iterations to obtain similar results. Figure 5 shows the curves from running the Nesterov method with CLR (reached 81.3% accuracy in only 25,000 iterations) and the Adam method both with and without CLR (both needed 70,000 iterations). When using adaptive learning rate methods, the benefits from CLR are sometimes reduced, but CLR can still valuable as it sometimes provides benefit at essentially no cost."
        },
        {
            "heading": "4.1.2 ResNets, Stochastic Depth, and DenseNets",
            "text": "Residual networks [10, 11], and the family of variations that have subsequently emerged, achieve state-of-the-art results on a variety of tasks. Here we provide comparison experiments between the original implementations and versions with CLR for three members of this residual network family: the original ResNet [10], Stochastic Depth networks [13], and the recent DenseNets [12]. Our experiments can be readily replicated because the authors of these papers make their Torch code available3. Since all three implementation are available using the Torch 7 framework, the experiments in this section were performed using Torch. In addition to the experiment in the previous Section, these networks also incorporate batch normalization [15] and demonstrate the value of CLR for architectures with batch normalization.\nBoth CIFAR-10 and the CIFAR-100 datasets were used\n3https://github.com/facebook/fb.resnet.torch, https://github.com/yueatsprograms/Stochastic Depth, https://github.com/liuzhuang13/DenseNet\nin these experiments. The CIFAR-100 dataset is similar to the CIFAR-10 data but it has 100 classes instead of 10 and each class has 600 labeled examples.\nThe results for these two datasets on these three architectures are summarized in Table 4. The left column give the architecture and whether CLR was used in the experiments. The other two columns gives the average final accuracy from five runs and the initial learning rate or range used in parenthesis, which are reduced (for both the fixed learning rate and the range) during the training according to the same schedule used in the original implementation. For all three architectures, the original implementation uses an initial LR of 0.1 which we use as a baseline.\nThe accuracy results in Table 4 in the right two columns are the average final test accuracies of five runs. The Stochastic Depth implementation was slightly different than the ResNet and DenseNet implementation in that the authors split the 50,000 training images into 45,000 training images and 5,000 validation images. However, the reported results in Table 4 for the SD architecture is only test accuracies for the five runs. The learning rate range used by CLR was determined by the LR range test method and the cycle length was choosen as a tenth of the maximum number of epochs that was specified in the original implementation.\nIn addition to the accuracy results shown in Table 4, similar results were obtained in Caffe for DenseNets [12] on CIFAR-10 using the prototxt files provided by the authors. The average accuracy of five runs with learning rates of 0.1, 0.2, 0.3 was 91.67%, 92.17%, 92.46%, respectively, but running with CLR within the range of 0.1 to 0.3, the average accuracy was 93.33%.\nThe results from all of these experiments show similar or better accuracy performance when using CLR versus using a fixed learning rate, even though the performance drops at\nsome of the learning rate values within this range. These experiments confirm that it is beneficial to use CLR for a variety of residual architectures and for both CIFAR-10 and CIFAR-100."
        },
        {
            "heading": "4.2. ImageNet",
            "text": "The ImageNet dataset [21] is often used in deep learning literature as a standard for comparison. The ImageNet classification challenge provides about 1, 000 training images for each of the 1, 000 classes, giving a total of 1, 281, 167 labeled training images."
        },
        {
            "heading": "4.2.1 AlexNet",
            "text": "The Caffe website provides the architecture and hyperparameter files for a slightly modified AlexNet [17]. These were downloaded from the website and used as a baseline. In the training results reported in this section, all weights\nwere initialized the same so as to avoid differences due to different random initializations.\nSince the batchsize in the architecture file is 256, an epoch is equal to 1, 281, 167/256 = 5, 005 iterations. Hence, a reasonable setting for stepsize is 6 epochs or 30, 000 iterations.\nNext, one can estimate reasonable minimum and maximum boundaries for the learning rate from Figure 7. It can be seen from this figure that the training doesn\u2019t start converging until at least 0.006 so setting base lr = 0.006 is reasonable. However, for a fair comparison to the baseline where base lr = 0.01, it is necessary to set the base lr to 0.01 for the triangular and triangular2 policies or else the majority of the apparent improvement in the accuracy will be from the smaller learning rate. As for the maximum boundary value, the training peaks and drops above a learning rate of 0.015 so max lr = 0.015 is reasonable. For comparing the exp range policy to the exp policy, setting base lr = 0.006 and max lr = 0.014 is reasonable and in this case one expects that the average accuracy of the exp range policy to be equal to the accuracy from the exp policy.\nFigure 9 compares the results of running with the fixed versus the triangular2 policy for the AlexNet architecture. Here, the peaks at iterations that are multiples of 60,000 should produce a classification accuracy that corresponds to the fixed policy. Indeed, the accuracy peaks at the end of a cycle for the triangular2 policy are similar to the accuracies from the standard fixed policy, which implies that the baseline learning rates are set quite well (this is also implied by Figure 7). As shown in Table 1, the final accuracies from the CLR training run are only 0.4% better than the accuracies from the fixed policy.\nFigure 10 compares the results of running with the exp versus the exp range policy for the AlexNet architecture with gamma = 0.999995 for both policies. As expected,\nFigure 10 shows that the accuracies from the exp range policy do oscillate around the exp policy accuracies. The advantage of the exp range policy is that the accuracy of 56.5% is already obtained at iteration 300, 000 whereas the exp policy takes until iteration 460, 000 to reach 56.5%.\nFinally, a comparison between the fixed and exp policies in Table 1 shows the fixed and triangular2 policies produce accuracies that are almost 2% better than their exponentially decreasing counterparts, but this difference is probably due to not having tuned gamma."
        },
        {
            "heading": "4.2.2 GoogLeNet/Inception Architecture",
            "text": "The GoogLeNet architecture was a winning entry to the ImageNet 2014 image classification competition. Szegedy et al. [25] describe the architecture in detail but did not provide the architecture file. The architecture file publicly available from Princeton4 was used in the following experiments. The GoogLeNet paper does not state the learning rate values and the hyper-parameter solver file is not avail-\n4vision.princeton.edu/pvt/GoogLeNet/\nable for a baseline but not having these hyper-parameters is a typical situation when one is developing a new architecture or applying a network to a new dataset. This is a situation that CLR readily handles. Instead of running numerous experiments to find optimal learning rates, the base lr was set to a best guess value of 0.01.\nThe first step is to estimate the stepsize setting. Since the architecture uses a batchsize of 128 an epoch is equal to 1, 281, 167/128 = 10, 009 iterations. Hence, good settings for stepsize would be 20, 000, 30, 000, or possibly 40, 000. The results in this section are based on stepsize = 30000.\nThe next step is to estimate the bounds for the learning rate, which is found with the LR range test by making a run for 4 epochs where the learning rate linearly increases from 0.001 to 0.065 (Figure 11). This figure shows that one can use bounds between 0.01 and 0.04 and still have the model reach convergence. However, learning rates above 0.025 cause the training to converge erratically. For both triangular2 and the exp range policies, the base lr was set to 0.01 and max lr was set to 0.026. As above, the accuracy peaks for both these learning rate policies correspond to the same learning rate value as the fixed and exp policies. Hence, the comparisons below will focus on the peak accuracies from the LCR methods.\nFigure 12 compares the results of running with the fixed versus the triangular2 policy for this architecture (due to time limitations, each training stage was not run until it fully plateaued). In this case, the peaks at the end of each cycle for the triangular2 policy produce better accuracies than the fixed policy. The final accuracy shows an improvement from the network trained by the triangular2 policy (Table 1) to be 1.4% better than the accuracy from the fixed policy. This demonstrates that the triangular2 policy improves on a \u201cbest guess\u201d for a fixed learning rate.\nFigure 13 compares the results of running with the exp versus the exp range policy with gamma = 0.99998. Once again, the peaks at the end of each cycle for the\nexp range policy produce better validation accuracies than the exp policy. The final accuracy from the exp range policy (Table 1) is 2% better than from the exp policy."
        },
        {
            "heading": "5. Conclusions",
            "text": "The results presented in this paper demonstrate the benefits of the cyclic learning rate (CLR) methods. A short run of only a few epochs where the learning rate linearly increases is sufficient to estimate boundary learning rates for the CLR policies. Then a policy where the learning rate cyclically varies between these bounds is sufficient to obtain near optimal classification results, often with fewer iterations. This policy is easy to implement and unlike adaptive learning rate methods, incurs essentially no additional computational expense.\nThis paper shows that use of cyclic functions as a learning rate policy provides substantial improvements in performance for a range of architectures. In addition, the cyclic nature of these methods provides guidance as to times to drop the learning rate values (after 3 - 5 cycles) and when to stop the the training. All of these factors reduce the guesswork in setting the learning rates and make these methods practical tools for everyone who trains neural networks.\nThis work has not explored the full range of applications for cyclic learning rate methods. We plan to determine if equivalent policies work for training different architectures, such as recurrent neural networks. Furthermore, we believe that a theoretical analysis would provide an improved understanding of these methods, which might lead to improvements in the algorithms."
        }
    ],
    "title": "Cyclical Learning Rates for Training Neural Networks",
    "year": 2017
}