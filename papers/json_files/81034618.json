{
    "abstractText": "Data structure synthesis is the task of generating data structure implementations from high-level specifications. Recent work in this area has shown potential to save programmer time and reduce the risk of defects. Existing techniques focus on data structures for manipulating subsets of a single collection, but real-world programs often track multiple related collections and aggregate properties such as sums, counts, minimums, and maximums. This paper shows how to synthesize data structures that track subsets and aggregations of multiple related collections. Our technique decomposes the synthesis task into alternating steps of query synthesis and incrementalization. The query synthesis step implements pure operations over the data structure state by leveraging existing enumerative synthesis techniques, specialized to the data structures domain. The incrementalization step implements imperative state modifications by re-framing them as fresh queries that determine what to change, coupled with a small amount of code to apply the change. As an added benefit of this approach over previous work, the synthesized data structure is optimized for not only the queries in the specification but also the required update operations. We have evaluated our approach in four large case studies, demonstrating that these extensions are broadly applicable.",
    "authors": [
        {
            "affiliations": [],
            "name": "Calvin Loncaric"
        },
        {
            "affiliations": [],
            "name": "Paul G. Allen"
        },
        {
            "affiliations": [],
            "name": "Michael D. Ernst"
        },
        {
            "affiliations": [],
            "name": "Emina Torlak"
        }
    ],
    "id": "SP:20e636aa9351ed487de442cf869fb9b82db0754a",
    "references": [
        {
            "authors": [
                "Sanjay Agrawal",
                "Surajit Chaudhuri",
                "Vivek R. Narasayya"
            ],
            "title": "Automated Selection of Materialized Views and Indexes in SQL Databases",
            "venue": "In Proceedings of the 26th International Conference on Very Large Data Bases (VLDB",
            "year": 2000
        },
        {
            "authors": [
                "Yanif Ahmad",
                "Oliver Kennedy",
                "Christoph Koch",
                "Milos Nikolic"
            ],
            "title": "DBToaster: Higher-order Delta Processing for Dynamic, Frequently Fresh Views",
            "venue": "Proceedings of the VLDB Endowment 5,",
            "year": 2012
        },
        {
            "authors": [
                "Rajeev Alur",
                "Rastislav Bod\u00edk",
                "Garvit Juniwal",
                "Milo M.K. Martin",
                "Mukund Raghothaman",
                "Sanjit A. Seshia",
                "Rishabh Singh",
                "Armando Solar-Lezama",
                "Emina Torlak",
                "Abhishek Udupa"
            ],
            "title": "Syntax-Guided Synthesis. In Formal Methods in Computer-Aided Design (FMCAD \u201913)",
            "year": 2013
        },
        {
            "authors": [
                "Alexandr Andoni",
                "Dumitru Daniliuc",
                "Sarfraz Khurshid"
            ],
            "title": "Evaluating the \u201cSmall Scope Hypothesis",
            "venue": "Technical Report. MIT",
            "year": 2003
        },
        {
            "authors": [
                "Surajit Chaudhuri",
                "Vivek R. Narasayya"
            ],
            "title": "An Efficient Cost-Driven Index Selection Tool for Microsoft SQL Server",
            "venue": "In Proceedings of the 23rd International Conference on Very Large Data Bases (VLDB",
            "year": 1997
        },
        {
            "authors": [
                "Leonardo De Moura",
                "Nikolaj Bj\u00f8rner"
            ],
            "title": "Z3: An Efficient SMT Solver. In Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS/ETAPS \u201908)",
            "year": 2008
        },
        {
            "authors": [
                "Benjamin Delaware",
                "Cl\u00e9ment Pit-Claudel",
                "Jason Gross",
                "Adam Chlipala"
            ],
            "title": "Fiat: Deductive Synthesis of Abstract Data Types in a Proof Assistant",
            "venue": "In Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL \u201915)",
            "year": 2015
        },
        {
            "authors": [
                "Robert B.K. Dewar",
                "Arthur Grand",
                "Ssu-Cheng Liu",
                "Jacob T. Schwartz",
                "Edmond Schonberg"
            ],
            "title": "Programming by Refinement, As Exemplified by the SETL Representation Sublanguage",
            "venue": "ACM Transactions on Programming Languages and Systems",
            "year": 1979
        },
        {
            "authors": [
                "Jay Earley"
            ],
            "title": "Relational Level Data Structures for Programming Languages",
            "venue": "Acta Informatica 2,",
            "year": 1973
        },
        {
            "authors": [
                "Jay Earley"
            ],
            "title": "High Level Iterators and a Method for Automatically Designing Data Structure Representation",
            "venue": "Computer Languages 1,",
            "year": 1975
        },
        {
            "authors": [
                "Peter Hawkins",
                "Alex Aiken",
                "Kathleen Fisher",
                "Martin Rinard",
                "Mooly Sagiv"
            ],
            "title": "Data Representation Synthesis",
            "venue": "In Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI \u201911)",
            "year": 2011
        },
        {
            "authors": [
                "Peter Hawkins",
                "Alex Aiken",
                "Kathleen Fisher",
                "Martin Rinard",
                "Mooly Sagiv"
            ],
            "title": "Concurrent Data Representation Synthesis",
            "venue": "In Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI \u201912)",
            "year": 2012
        },
        {
            "authors": [
                "Daniel Jackson",
                "Craig Damon"
            ],
            "title": "Elements of Style: Analyzing a Software Design Feature with a Counterexample Detector",
            "venue": "In ISSTA. 239\u2013249",
            "year": 1996
        },
        {
            "authors": [
                "Christoph Koch",
                "Daniel Lupei",
                "Val Tannen"
            ],
            "title": "Incremental View Maintenance For Collection Programming",
            "venue": "In Proceedings of the 35th ACM SIGMOD- SIGACT-SIGAI Symposium on Principles of Database Systems (PODS \u201916)",
            "year": 2016
        },
        {
            "authors": [
                "Calvin Loncaric",
                "Emina Torlak",
                "Michael D. Ernst"
            ],
            "title": "Fast Synthesis of Fast Collections",
            "venue": "In Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI \u201916)",
            "year": 2016
        },
        {
            "authors": [
                "Edmond Schonberg",
                "Jacob T. Schwartz",
                "Micha Sharir"
            ],
            "title": "An Automatic Technique for Selection of Data Representations in SETL Programs",
            "venue": "ACM Transactions on Programming Languages and Systems 3,",
            "year": 1981
        },
        {
            "authors": [
                "Jacob T. Schwartz"
            ],
            "title": "Automatic Data Structure Choice in a Language of Very High Level",
            "venue": "In Proceedings of the 2nd ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL \u201975)",
            "year": 1975
        },
        {
            "authors": [
                "Ohad Shacham",
                "Martin Vechev",
                "Eran Yahav"
            ],
            "title": "Chameleon: Adaptive Selection of Collections",
            "venue": "In Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI \u201909)",
            "year": 2009
        },
        {
            "authors": [
                "Laure Simon",
                "Daniel Le Berre",
                "Edward A. Hirsch"
            ],
            "title": "The SAT2002 Competition",
            "venue": "Annals of Mathematics and Artificial Intelligence 43,",
            "year": 2005
        },
        {
            "authors": [
                "Rishabh Singh",
                "Armando Solar-Lezama"
            ],
            "title": "Synthesizing Data Structure Manipulations from Storyboards",
            "venue": "In Proceedings of the 19th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on The Foundations of Software Engineering (ESEC/FSE \u201911)",
            "year": 2011
        },
        {
            "authors": [
                "Douglas R. Smith"
            ],
            "title": "KIDS: A Semiautomatic Program Development System",
            "venue": "IEEE Transactions on Software Engineering 16,",
            "year": 1990
        },
        {
            "authors": [
                "Douglas R. Smith"
            ],
            "title": "Designware: Software Development by Refinement",
            "venue": "Electronic Notes in Theoretical Computer Science",
            "year": 1999
        },
        {
            "authors": [
                "Armando Solar-Lezama"
            ],
            "title": "Program Synthesis by Sketching",
            "venue": "Ph.D. Dissertation. University of CA at Berkeley,",
            "year": 2008
        },
        {
            "authors": [
                "Armando Solar-Lezama",
                "Christopher Grant Jones",
                "Rastislav Bod\u00edk"
            ],
            "title": "Sketching Concurrent Data Structures",
            "venue": "In Proceedings of the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI \u201908)",
            "year": 2008
        },
        {
            "authors": [
                "Armando Solar-Lezama",
                "Liviu Tancau",
                "Rastislav Bod\u00edk",
                "Sanjit Seshia",
                "Vijay Saraswat"
            ],
            "title": "Combinatorial Sketching for Finite Programs",
            "venue": "Operating Systems Review 40,",
            "year": 2006
        },
        {
            "authors": [
                "John Toman",
                "Dan Grossman"
            ],
            "title": "Staccato: A Bug Finder for Dynamic Configuration Updates. In 30th European Conference on Object-Oriented Programming (ECOOP \u201916)",
            "venue": "Schloss Dagstuhl, Dagstuhl,",
            "year": 2016
        },
        {
            "authors": [
                "Abhishek Udupa",
                "Arun Raghavan",
                "Jyotirmoy V. Deshmukh",
                "Sela Mador-Haim",
                "Milo M.K. Martin",
                "Rajeev Alur"
            ],
            "title": "TRANSIT: Specifying Protocols with Concolic Snippets",
            "venue": "In Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI \u201913)",
            "year": 2013
        }
    ],
    "sections": [
        {
            "text": "This paper shows how to synthesize data structures that track subsets and aggregations of multiple related collections. Our technique decomposes the synthesis task into alternating steps of query synthesis and incrementalization. The query synthesis step implements pure operations over the data structure state by leveraging existing enumerative synthesis techniques, specialized to the data structures domain. The incrementalization step implements imperative state modifications by re-framing them as fresh queries that determine what to change, coupled with a small amount of code to apply the change. As an added benefit of this approach over previous work, the synthesized data structure is optimized for not only the queries in the specification but also the required update operations. We have evaluated our approach in four large case studies, demonstrating that these extensions are broadly applicable."
        },
        {
            "heading": "CCS CONCEPTS",
            "text": "\u2022 Theory of computation\u2192Data structures design and analysis; \u2022 Software and its engineering \u2192 Source code generation;"
        },
        {
            "heading": "KEYWORDS",
            "text": "Program synthesis, automatic programming, data structures"
        },
        {
            "heading": "ACM Reference Format:",
            "text": "Calvin Loncaric, Michael D. Ernst, and Emina Torlak. 2018. Generalized Data Structure Synthesis. In Proceedings of International Conference on Software Engineering (ICSE\u201918). ACM, New York, NY, USA, 11 pages. https://doi.org/ 10.1145/nnnnnnn.nnnnnnn\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. ICSE\u201918, May 27\u2013June 3, 2018, Gothenberg, Sweden \u00a9 2018 Copyright held by the owner/author(s). Publication rights licensed to the Association for Computing Machinery. ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00 https://doi.org/10.1145/nnnnnnn.nnnnnnn"
        },
        {
            "heading": "1 INTRODUCTION",
            "text": "Many programming tasks can be framed as data structure problems, especially in domains like user interfaces or web services where software must manage some internal state and also handle asynchronous events. Manually implementing complex applicationspecific data structures can be time-consuming and error-prone. Recent research seeks to automatically synthesize data structure implementations from high-level specifications, thus ensuring correctness and run-time efficiency with minimum programmer effort [11, 12, 16]. Existing techniques can synthesize only a narrow range of data structures\u2014those that retrieve a subset of a single collection. Such a simple API limits their applicability, as real-world software often has more complex requirements.\nFor example, the chat server Openfire [13] uses a custom inmemory data structure to represent a many-to-many relationship between users and groups. This data structure needs to answer many different kinds of queries efficiently, such as which users belong to a given group or whether any two users share a group. It also needs to keep itself up-to-date as users and groups are added, removed, and renamed. Despite its complex implementation, Openfire\u2019s user management code has a simple specification. In general, data structure specifications are much smaller than their implementations because they do not need to manage memory or be algorithmically efficient.\nThis paper presents a new technique for data structure synthesis that overcomes many of the limitations of previous work. Our tool Cozy can synthesize implementations for complex multi-collection data structures\u2014including those found in Openfire\u2014from high-level specifications. Like previous work, a Cozy specification declares the abstract state (what information the data structure stores), queries (methods that perform pure computations on the state), and updates (methods that modify the state) that the data structure must support. Cozy then produces source code that developers can use right away.\nIn previous work, implementations for update methods were hard-coded [16] or derived using a set of hand-written rules [11]. In Cozy, update methods are synthesized rather than hardcoded. This enables Cozy to discover more specialized data representations than previouswork, since Cozy can choose different representations depending on what kinds of updates appear in the specification.\nOur technique iteratively improves the data structure specification using two cooperating components: a query synthesizer that selects a better representation and implementation for each query method and an incrementalization step that ensures the new representation is kept up-to-date when an update method is called. Crucially, the incrementalization step can produce specifications for new query operations to help implement the update procedure.\nCozy thus uses the query synthesizer to implement both pure query operations and imperative updates. Our technique is agnostic to the exact implementations of the query synthesizer and incrementalization step; Section 3 gives a detailed explanation of the concrete choices we made for Cozy.\nThe query synthesizer and incrementalization step interact using concretization functions. A concretization function expresses a data structure\u2019s representation\u2014its concrete state\u2014as a function of its abstract state. For example, the following concretization function represents the count of elements in an abstract set S : C(S) = \u2211x \u2208S 1 . Concretization functions allow Cozy to reason about the effects of updates in pure mathematical terms. The imperative operation S.remove(e)\u2014which removes an instance of e from S if any is present\u2014causes a change to the data representation. The new value of the count thus becomes C(S \u2032) = C(S \u2212 {e}) = \u2211x \u2208(S\u2212{e }) 1 .\nCozy\u2019s query synthesis step outputs both an efficient implementation for each query and a set of concretization functions indicating how the data should be represented. The incrementalization step then uses the concretization functions to produce a specification of the change to the concrete state as a result of each update. For the case of S.remove(e), the change specification is the amount by which the count changes: C(S \u2032)\u2212C(S). These change specifications are queries over the abstract state of the data structure, and to implement them Cozy repeats the query synthesis step. The tool proceeds in this loop until exhausting its time budget\u2014three hours for our evaluation."
        },
        {
            "heading": "Contributions",
            "text": "\u2022 A high-level data structure synthesis algorithm with alternating steps of query synthesis and incrementalization (\u00a72). \u2022 Query synthesis and incrementalization algorithms (\u00a73). \u2022 An implementation, called Cozy (https://cozy.uwplse.org). \u2022 Four real-world case studies that evaluated Cozy\u2019s effect on development time, correctness, and efficiency (\u00a74)."
        },
        {
            "heading": "2 OVERVIEW",
            "text": "This section illustrates Cozy\u2019s high-level algorithm using a simplified example of a real-world data structure from Openfire. The data structure that manages users\u2019 contacts has been a frequent source of bugs (Section 4.4). Cozy can synthesize a complete implementation for Openfire\u2019s data structure given its specification.\nCozy uses the algorithm shown in Figure 1. It takes as input an executable specification of the data structure (Section 2.1), constructs an initial implementation (Section 2.2), and then iteratively improves its implementation using alternating steps of query synthesis (Section 2.3) and incrementalization (Section 2.4). A dead code elimination step (Section 2.5) prunes dead code as synthesis progresses."
        },
        {
            "heading": "2.1 Specification",
            "text": "Figure 2a shows a complete Cozy specification for part of the Openfire contact management data structure. It would be used as the input to Figure 1. In the specification, state declarations describe the abstract state of the data structure, query declarations specify methods that compute values using the abstract state, and op declarations specify methods that alter the abstract state. Methods may also include assumptions (preconditions) about their inputs. In some cases, Cozy can produce better implementations by leveraging these assumptions, but they are optional for specification writers. Callers must ensure that the assumptions hold at each call site.\nIn Openfire, users\u2019 contact lists are implicit and are computed based on the groups that each user belongs to. The data structure must be able to efficiently answer the question \u201cshould user u1 appear in the contacts of user u2?\u201d for any u1 and u2. The query method visible in Figure 2a defines this relationship: u1 is visible to (i.e. appears in the contacts of) u2 if there exists a group \u0434 of which u1 is a member and either \u0434 has been made visible to everyone (\u0434.visibility == Everyone) or u2 is also a member of \u0434.\nThis example has been simplified; our experiments (Section 4) use a full specification of the data structure that also includes explicit contacts and additional visibility modes for groups.\nAs specified, visible runs inO(|groups| \u00d7 |members|) time. Cozy creates a more efficient implementation for visible (Figure 2b) that runs in O(\u0434) time, where \u0434 is the maximum number of groups that any one user is a member of."
        },
        {
            "heading": "2.2 Initial Implementation",
            "text": "Whenever Cozy chooses a data representation, it also creates, for each field in the representation, a concretization function that computes the field\u2019s representation from the abstract state. Since Cozy specifications are executable, they can be converted to implementations whose concrete state is the same as the abstract state. For the specification in Figure 2a, Cozy\u2019s initial implementation has the variables v1, v2, and v3 and trivial concretization functions:\nCv1(users, groups, members) = users Cv2(users, groups, members) = groups Cv3(users, groups, members) = members\nEach query and update operation can be rewritten in terms of v1, v2, and v3 by simple substitution. The visible method becomes\nquery visible(u1, u2 : User): assume u1 \u2208 v1 assume u2 \u2208 v1 return (exists [ \u0434 | \u0434 \u2190 v2, (u1, \u0434) \u2208 v3 and ( \u0434.visibility == Everyone or (u2, \u0434) \u2208 v3) ])\nWhile renaming the abstract members to v1, v2, v3 does not functionally change the specification, it creates initial concretization functions for later steps to consume."
        },
        {
            "heading": "2.3 Query Synthesis",
            "text": "Cozy synthesizes an implementation by iteratively finding improvements to the data structure. The query synthesis step in Figure 1 makes an improvement to some non-deterministically chosen query operation on the data structure. Section 3.2 discusses how Cozy makes the choice and the improvement.\nFigure 2 shows output from one of the query synthesis steps, i.e., an improvement to the query visible that uses a new representation and has associated concretization functions.\nThe query synthesis step may introduce new state variables, but it does not drop unused ones. In Figure 2, the red state variables s1, s2, and s3 are new; v1, v2, and v3 are now unused. The dead code elimination pass will eliminate the unused variables later.\nThe new variables\u2019 concretization functions are more complex than the trivial ones introduced for the initial implementation. The state variable s1, for instance, has the concretization function Cs1, which uses the MakeMap primitive to construct a new map from users to Booleans. The MakeMap primitive takes a collection of keys (users) and a value function (f ) and builds a map where each key u \u2208 users is associated with value f (u). For s1, the value is true if the user is a member of a group with visibility set to \u201cEveryone\u201d. In Cozy, maps are total. Lookups on missing keys return a default value: false for booleans, the empty set for sets, and so on. Thus,\nthe expression s1[u1] efficiently determines whether user u1 is a member of a group with visibility set to \u201cEveryone\u201d.\nThe concretization functions shown in Figure 2c will become the implementation of the constructor for the data structure. The constructor takes the abstract state as input and initializes the concrete state. Furthermore, the concretization functions enable incrementalization."
        },
        {
            "heading": "2.4 Incrementalization",
            "text": "The query synthesis step creates an incorrect data structure: the new state variables s1, s2, and s3 are not kept up-to-date when join is called. The incrementalization step restores correct functioning by adding code to join that updates the new state variables. The new code must preserve the concretization functions in Figure 2c.\nA simple but inefficient solution would be to recompute the value of each concrete state variable from scratch. Because an update usually makes a small change to the abstract state, Cozy produces an incremental update that makes small changes to the concrete state in response to a small change to the abstract state.\nTo incrementally update the concrete state, Cozy rephrases the update procedure as a set of queries that compute what changes should take place, plus a simple hardcoded snippet that applies those computed changes. A previous approach applied this same idea to synthesize remove operations [11], but with concretization functions it can be generalized to insertions and other updates as well. Our approach also allows for more complex update procedures like those that applymultiple changes at once or onlymake a change under certain conditions.\nFigure 3a shows the code that Cozy produces to update the concrete state as a result of a user joining a group. Each concrete state variable gets its own update procedure (e.g. join_s1 for s1). The code for join_s1 is not synthesized; it comes from a lookup table (Section 3.3). However, the new code uses two fresh query operations altered_keys_s1 and new_value_for_key_s1 (Figure 3b) that determine what changes to apply. The former computes the\nset of map keys whose values change, and the latter computes the new value for each key. These two queries are added to the data structure specification, and thus they will be optimized by the query synthesizer on subsequent iterations.\nThe definitions of the fresh queries make use of both the old value of s1 and the new value s1\u2032. The new value is computed using the specification of join and the concretization functions. Mathematically, join sets the abstract state to\nusers\u2032 = users; groups\u2032 = groups; members\u2032 = members \u222a {(u, \u0434)}\nand thus the new value s1\u2032 must be s1\u2032 = Cs1(users\u2032, groups\u2032, members\u2032) = MakeMapf users\nwhere f = \u03bbu . exists Filterp(u) (members \u222a {(u, \u0434)}) p(u) = \u03bb(v, \u0434) . u == v and \u0434.visibility == Everyone\nFigure 3b shows the specifications for altered_keys_s1 and new_value_for_key_s1, which are inefficient. On later iterations, Cozy\u2019s query synthesizer discovers efficient implementations for both. Specifically, Cozy implements altered_keys_s1 to return the singleton set {u} if\u0434 has visibility Everyone andu is not already in such a group, or \u2205 otherwise. Cozy implements new_value_for_key_s1 to simply return true.\nThe implementations of altered_keys_s1 and new_value_for_key_s1 do not require additional concrete state. In general, however, new concrete state might be generated for the fresh queries in later iterations, requiring another phase of incrementalization."
        },
        {
            "heading": "2.5 Dead Code Elimination",
            "text": "At each iteration, Cozy cleans up unused state variables and operations. For instance, the state variable v2 can be eliminated since it is never read. All code that keeps v2 up-to-date can be eliminated as well. Cozy also deduplicates state variables and fresh queries. Duplicates happen in cases where the same concrete state is useful to multiple different query operations."
        },
        {
            "heading": "3 DETAILS",
            "text": "Cozy iteratively improves a specification (Section 3.1) to produce an implementation. At each iteration Cozy attempts to find an improvement to some query (Section 3.2). The improvement may require new concrete state, which must be properly maintained in each update method (Section 3.3). Finally, unused state and code are removed (Section 3.4)."
        },
        {
            "heading": "3.1 Specification and Output Languages",
            "text": "Figure 4 shows the core specification language. All input specifications are desugared to this core language (Figure 5). Cozy\u2019s output language is a superset of its input language that includes additional constructs for maps:\n\u03c4 ::= Map\u27e8\u03c4 ,\u03c4 \u27e9 e ::= MakeMapf e | MapKeys e | e[e]\nMaps could be included in the input language, but they are not needed: a comprehension can group and look up values in a declarative rather than procedural manner. This clarifies what each expression computes and reduces the number of invariants that programmers need to maintain. In the output language, the MakeMap primitive takes an expression e representing the keys of the map and a projection f that gives the value at each key. MapKeys returns the keys of a map. The map index operator e[e] returns the value of a given key in the given map. If the key is not in the map, this operator returns a default value; e.g. false for booleans and the empty set for bags.\nWe plan to extend Cozy with additional primitives for heaps, trees, and other efficient data structures in the future. For the case studies we examined, maps alone are sufficient to discover efficient implementations."
        },
        {
            "heading": "3.2 Synthesis",
            "text": "Cozy attempts to synthesize a better implementation for each query method in the specification, in parallel, with one thread per query. A static cost model (Figure 6) defines \u201cbetter.\u201d Whenever a thread discovers a better implementation: (1) That implementation is immediately passed through the incrementalization step, and new queries it produces get new threads. (2) The whole specification undergoes dead code elimination, and any old queries that were eliminated have their threads terminated.\nEach thread synthesizes improvements for its query using enumerative synthesis, an optimized form of brute-force search. The core algorithm described here was pioneered by previous work [3, 28, 31], but Cozy employs several novel improvements. We describe the core algorithm first, followed by our extensions.\nEnumerative synthesis explores every possible expression in Cozy\u2019s output grammar, in order of size from smallest to largest. For each expression, a verifier (e.g. Z3 [6]) checks whether the expression satisfies the specification\u2014that is, they always produce the same result. If so, the expression is emitted. Then the search continues to look for an even better solution. Since Cozy employs bounded verification (described below), the verifier always produces a result and never times out or returns unknown.\nTo make the search feasible, Cozy employs equivalence class deduplication [16, 31], an optimization that skips most expressions in the search space. The skipping is done safely so that Cozy never"
        },
        {
            "heading": "State Expressions",
            "text": "costS(e) = number of AST nodes in e"
        },
        {
            "heading": "Query Expressions",
            "text": "costQ(e) | e is a state expression = 1 costQ(x) = 1 costQ(e1 op e2) = 1 + costQ(e1) + costQ(e2) costQ(Filterp e) = 1 + costQ(e) + card(e) \u00d7 costQ(p(x))\n(x is a fresh variable) costQ(\u03a3 e) = 1 + costQ(e) + card(e) ..."
        },
        {
            "heading": "Facts About Cardinalities",
            "text": "\u2200e, card(e) \u2265 0 \u2200x , card(x) \u2265 1000 (if x is an abstract state variable) card(\u2205) = 0 card({e}) = 1 card(e1 + e2) = card(e1) + card(e2) unsat(|e1 | > |e2 |) \u2192 card(e1) \u2264 card(e2)"
        },
        {
            "heading": "Partial Order on Costs",
            "text": "sat(c1 < c2) \u2227 \u00acsat(c2 < c1) \u2192 c1 \u227a c2\nmisses a solution, if one exists. Equivalence class deduplication requires a list of example inputs. In Cozy, an example input consists of values for both the abstract state of the data structure and the query arguments. The example inputs are produced by the verifier: every time an expression fails verification, the verifier yields a new example input. Cozy caches built expressions. Whenever two expressions produce the same output on every example, Cozy consults a static cost model (described below) to decide which to keep. In this way, an expression\u2019s set of outputs on the examples puts it in an equivalence class, and only one representative of each equivalence class is cached at any given time. Larger expressions are only built out of those that survive this deduplication. Furthermore, Cozy only tries to verify expressions that produce correct output on every example, reducing the number of calls to the verifier. Since the skipping is so aggressive, the search must restart every time a new example is discovered to ensure that no solutions are missed.\nCozy includes three novel additions to the core enumerative synthesis algorithm: query-time distinction, a symbolic cost model, and diversity injection. Additionally, since verification is undecidable for our specification language, Cozy uses bounded verification instead of full functional verification. This technique was also employed by previous work [26].\nQuery-Time Distinction. Cozy\u2019s query synthesis algorithm must solve two intertwined problems: choosing a good representation for\nthe data and choosing a good algorithm that exploits that representation. Our solution is to tag each node in a synthesized expression as either a state expression or a query expression. The data structure stores each state expression as a member and incrementally maintains it at each update operation. A query expression is evaluated each time the query is called.\nFor instance, an expression to compute the length of a list could be implemented in several different ways, depending on which parts are tagged as state expressions:\n\u03a3 Map\u03bbx .1 S\ufe38 \ufe37\ufe37 \ufe38 state or \u03a3 Map\u03bbx .1 S\ufe38\ufe37\ufe37\ufe38 state .\nThe first case indicates that the data structure stores the length of S as a member and returns the stored value when the query is called. The second case indicates that the data structure stores S as a member and computes the length on-demand. Since these two expressions are equivalent, only the lower-cost one\u2014in this case, the first\u2014is kept during deduplication. Cozy\u2019s cost model does not account for the cost of maintaining the state; instead, that job is delegated to the sub-queries generated during incrementalization. Expressions that contain query arguments may not be tagged as state expressions, since those values will not be available until the query is executed.\nSymbolic Cost Model. Figure 6 shows Cozy\u2019s novel static cost model. The cost model compares state expressions based on their complexity in terms of the number of AST nodes (costS). It compares query-time expressions based on their expected run time (costQ).\nCozy represents costs as symbolic formulas involving the cardinalities of various collections. For example, the cost of performing a filter includes the cost of evaluating the predicate on every element of the collection being filtered.\nTo determine the ordering between two costs c1 and c2, Cozy first makes solver calls to establish as many facts as possible about all the cardinalities (i.e., calls to card) in each expression. Each call to card can then be replaced by a fresh real-type variable. Using these assumptions, Cozy then makes more solver calls. If there are cases where c1 is less than c2 (sat(c1 < c2)) and no cases where c1 is more than c2 (\u00acsat(c2 < c1)), then the expression having cost c1 should always be preferred over the expression having cost c2.\nDiversity Injection. In practice, the enumerative synthesis algorithmmay take a long time to discover good solutions, especially for languages like ours where expression size is not strongly correlated with cost (that is, larger expressions may have lower cost). When the syntax tree for the best solution is of size fifteen or twenty, standard enumerative synthesis may take many centuries to discover it! For comparison, the syntax tree for the efficient implementation of visible in Figure 2 requires 45 nodes.\nTo bias the search toward useful expressions, Cozy employs a small number of handwritten diversity rules that inject new expressions into the search procedure. Whenever Cozy considers a new candidate expression, it also applies these rules and considers the resulting expressions. The diversity rules do not need to be universally correct or efficient: incorrect expressions will be rejected by the verifier, and inefficient expressions will be rejected by the cost model. However, incorrect expressions are still cached to help\nbuild larger expressions, as they might appear as subexpressions of correct solutions later on.\nCozy uses the five diversity rules shown in Figure 7. These diversity rules are specialized to Cozy\u2019s domain and are intended to capture some intuitions human programmers might apply. \u201cMap introduction\u201d converts some linear-time filter operations into efficient map lookups. \u201cCleaners\u201d put expressions into normal form, which helps Cozy identify potential map lookups on later iterations. The \u201crelevant subset\u201d rule converts a collection into the subset that is already stored on the data structure. Finally, the \u201cinstantiation\u201d rule helps transfer insights about a variable to insights about other expressions. For example, if Cozy has discovered the expressions x \u2208 S and y, then y \u2208 S might also be important.\nIn practice, Cozy\u2019s enumerative search machinery does not function well without the diversity rules and vice-versa. If the diversity rules are disabled, Cozy does not find a good solution to any specification for any of our subject programs within a three hour timeout. Similarly if the diversity rules are applied without the rest of Cozy\u2019s enumerative search machinery, the search quickly runs out of new expressions and stalls without ever finding a good solution.\nBounded Verification. It is undecidable to determine whether an expression in Cozy\u2019s language satisfies a specification. Thus, Cozy employs bounded verification: collection-type variables are limited to a fixed number of elements. In our experiments, we found a limit of four to be sufficient to ensure correct solutions. This may be thanks to the small-scope hypothesis [14], which proposes that most program bugs can be exhibited with small inputs. There is some evidence that the small scope hypothesis is true for simple programs [4], and we found it to be true in our domain as well."
        },
        {
            "heading": "3.3 Incrementalization",
            "text": "After query synthesis picks a new representation for the data, the incrementalization step restores proper functioning by adding code to keep that representation up-to-date as the data structure changes. Cozy\u2019s incrementalize procedure accomplishes that goal by leveraging the existing query synthesis procedure.\nIn join from Section 2.4, Cozy updated s1 using the code for k \u2208 altered_keys_s1(u, \u0434): s1[k] = new_value_for_key_s1(k, u, \u0434)\nFigure 8 shows the rules for Cozy\u2019s incrementalize procedure. Since s1 has a map type, Cozy uses the update sketch shown in the figure for maps. An update sketch is a small snippet of imperative code that updates the variable. An update sketch may require new query\nincrementalize(x ,Cx ): Input: old abstract state \u03c3 and new abstract state \u03c3 \u2032 Output: code to update concrete state x\noperations in order to function. In the case of maps, the update sketch finds the keys whose values have changed and updates each one in the map. Cozy introduces the new query altered_keys_s1 to compute which keys have changed.\nSince the values in s1 are booleans, Cozy uses the fallback sketch for \u201cother\u201d types to update each value. This rule uses a new query new_value_for_key_s1 to compute\u2014from scratch\u2014a new value for s1[k]. As discussed in Section 2.4, the new value for s1[k] is simply true. In practice, new queries generated by incrementalize often have short and efficient implementations."
        },
        {
            "heading": "3.4 Dead Code Elimination",
            "text": "When a better query implementation is found, some state variables may go unused. The imperative operations that keep these variables up-to-date are unnecessary, as are any queries required only by those imperative operations, and so forth. The dead code elimination procedure is important; it frequently eliminates variables in this manner as better query solutions are found.\nTo clean up unused state and operations, Cozy uses mark-andsweep. User-specified query operations start as roots. Any state that they use is marked as relevant, and code to update that state is also marked. Queries used by the update code are then marked, and so on until fixed point. Finally any unmarked state, queries, or update code can be safely removed."
        },
        {
            "heading": "3.5 Termination",
            "text": "The query synthesis procedure (Section 3.2) has no formal termination guarantees, and as a result, neither does Cozy itself. But since the input specification is executable, Cozy always has a correct solution and the synthesis process can be stopped at any time. Our experiments used a fixed timeout of three hours for synthesis."
        },
        {
            "heading": "4 EVALUATION",
            "text": "Cozy has three goals: to reduce programmer effort, to produce bugfree code, and to match the performance of handwritten code. We found that using Cozy requires an order of magnitude fewer lines of code than manual implementation (Section 4.3), makes no mistakes even when human programmers do (Section 4.4), and often matches the performance of handwritten code (Section 4.5)."
        },
        {
            "heading": "4.1 Methodology",
            "text": "For each of four real-world programs (Section 4.2), we\n(1) identified an important, complex, handwritten data structure, (2) manually wrote a Cozy specification, (3) allowed Cozy a three-hour timeout to synthesize a new im-\nplementation, and (4) replaced the original data structure by the synthesized one. Replacing handwritten code with Cozy-synthesized code required some light refactoring in each program. For example, some programmers intertwine data structure code with I/O code. We disentangled these, because Cozy does not synthesize I/O code. This refactoring was only necessary because these projects did not use Cozy from day one. Furthermore, we believe it results in better code style and easier-to-understand abstractions.\nWe ran our experiments on amachinewith 96 cores and 512 Gb of memory. Cozy spawns one thread for each query in the specification and runs fastest on amachine with at least that many cores, but does not require it. The Openfire specification, our largest, has 12 query operations, thus requiring 12 cores for fastest operation. Memory usage steadily climbs the longer Cozy runs; we have observed it reach 32 Gb in the worst case.\nThe three hour synthesis time does not slow down the editcompile-test cycle. Since Cozy specifications are executable, they can be immediately translated into usable but inefficient code. Developers can code and test against the slow version to gain confidence in their specification before running the full synthesizer. We made use of this feature while writing specifications in our evaluation."
        },
        {
            "heading": "4.2 Subject Programs",
            "text": "ZTopo [32] is a topological map viewer implemented in C++. Its cache of map tiles asynchronously loads map tiles over the network and caches them on disk or in memory. The cache enables any other part of the program to query for information about a given map tile. ZTopo was also a target for previous data structure synthesis work [11, 16]. Cozy is also able to synthesize two parts of the cache that previous work could not. First, Cozy can synthesize the code that accounts for the total disk and memory usage of cached map tiles. Second, Cozy synthesizes a key operation to look up a single element by its unique identifier. Previous tools implemented this operation inefficiently by checking whether a computed collection of results contained a single element or not.\nSat4j [17] is a Boolean satisfiability solver implemented in Java. Its variable store tracks, among other things, when a guess was last made about a variable\u2019s value and whether any listeners are watching that variable\u2019s state. Sat4j was also a target for previous data structure synthesis work [16]. As with ZTopo, Cozy\u2019s synthesized implementation of the Sat4j data structure is a closer match to the original than previous tools, requiring less wrapper code."
        },
        {
            "heading": "Project Span Commits LoC LoC",
            "text": "Openfire [13] is a large, scalable IRC server implemented in Java. Its in-memory contact manager is extremely complex. Users\u2019 contacts can be either explicit (added by users manually) or implicit (present due to users\u2019 group memberships). Furthermore, the contact manager must keep its state in sync with the underlying database as users and groups are created, modified, and deleted. This logic has been a frequent source of bugs [30]. Openfire\u2019s implicit contacts require computing information about two distinct collections (users and groups), and thus cannot be handled by any previous tool.\nLucene [29] is a search engine back end implemented in Java. Lucene uses a custom data structure that consumes a stream of words and aggregates key statistics about them. The data structure has an add method that is called once for each token instead of getting the tokens as one big list. The logic for handling each token is tricky since the data structure needs to to be queryable between calls to its addmethod. Cozy helps avoid the logic in the addmethod by having a clean specification that describes the abstract state as a bag of tokens and descriptions of the queries that matter."
        },
        {
            "heading": "4.3 Programmer Effort",
            "text": "We do not know how much time programmers spent implementing and debugging the hand-written data structures, but it was significant. Table 1 shows the size of each implementation, in noncomment non-blank lines of code. It also reports howmany commits contributed to the current version of the data structure implementation, and across how much time those commits were made. The long time periods are because Sat4j, Openfire, and Lucene are established projects and still undergoing active maintenance. In all three, however, bug fixes have been made to the data structure in the last five commits, indicating that full functional correctness has been difficult to achieve.\nThe Cozy specifications are an order of magnitude shorter than the manual implementations. Most of our time was spent reverseengineering to understand the undocumented existing implementation; once we understood it, writing the specification was quick. For example, writing, integrating, and testing the ZTopo and Sat4j specifications took less than a day each. The Openfire roster manager was more challenging because we had to first formalize the implicit contacts function, a task the developers never carried out. We already understood the Cozy specification language (Section 3.1), but we believe that a programmer could learn it more quickly than it took us to reverse-engineer any one of the programs.\nBecause the specifications are shorter, simpler, and more abstract, they are much easier to understand. Programmers writing specifications are therefore less likely to make mistakes, and mistakes\nTable 2: Correctness results. ZTopo has no dedicated issue tracker.\nProject Issues New defects found\nZTopo n/a No Sat4j 7 No Openfire 25 Yes Lucene 1 No\nwill be easier to discover, diagnose, and correct. The specifications also serve as concise, unambiguous documentation."
        },
        {
            "heading": "4.4 Correctness",
            "text": "Cozy might produce an incorrect data structure because of its use of bounded verification. We also might have made an error when writing the specification. To check the correctness of the Cozy-synthesized data structures, we ensured that all tests in each project still pass. ZTopo, Openfire, and Lucene have no tests that cover the data structure we replaced. For these projects we verified that our synthesized data structure behaves identically to the original implementation during execution of the benchmarks we used in Section 4.5.\nTable 2 lists how many data-structure-related issues in each project\u2019s respective issue tracker might have been prevented by Cozy. Most issues relate to defective update code putting the data structure in a bad state. Cozy is perfectly positioned to prevent those defects: changes to a data structure\u2019s abstract state are much easier to specify than the code that updates an optimized representation. We now discuss some of these issues.\nSat4j\u2019s variable metadata storage has suffered both performance and functional correctness issues in the past that Cozy avoids. Today Sat4j has a test suite that achieves 89% statement coverage on the data structure we replaced, and Cozy\u2019s synthesized implementation passes all tests.\nOf Sat4j\u2019s seven reported issues, five relate to update code. Sat4j\u2019s data structure includes several arrays of data that grow exponentially as entries are added, and the logic to grow them and keep the capacity information up-to-date proved tricky to get right. The data structure also supports a reset() method to clear all of its internal state, but developers did not properly revise its implementation when they introduced new state variables. Cozy can prevent these kinds of problems since the programmer does not need to maintain the concrete representation.\nOpenfire, having a more complex data structure, has been even more difficult to get right. Section 2 presented only a simplified portion of the Openfire roster manager specification. The full specification has additional rules and visibility modes for groups. In particular, a useru1 is visible to a useru2 if any one of four different conditions are met: (1) the users have added each other as explicit contacts, (2) u1 is in a group with visibility set to Everyone, (3) both users share a group with visibility set to OnlyGroup, or (4) u1 is in a group \u0434A with visibility set to OnlyGroup and u2 is a member of a group \u0434B configured to have visibility onto \u0434A.\nThis definition gives rise to two kinds of roster items: explicit items due to condition 1 and implicit items due to conditions 2\u20134. The manually written implementation makes a trade-off: all explicit items plus implicit items due to conditions 2 and 3 are held as"
        },
        {
            "heading": "Project Time (orig.) Time (Cozy)",
            "text": "concrete objects inmemory, but implicit items due to condition 4 are constructed on-demand to save memory. Developers had to write a large amount of code to keep the implicit contacts correct when groups change visibility or when group membership changes. That code has been a frequent source of defects, and still has open issues. For example, one issue still open at time of writing reports that when administrators delete a user without first manually removing her from all of her groups, she remains in other users\u2019 contact lists.1 Other issues were caused by the stored state of the roster getting out-of-sync with the abstract state of the roster. By contrast, a Cozy programmer does not need to write the update code; Cozy discovers its own data representation and determines how to update it in response to changes.\nAdditionally, we discovered multiple new failures while replacing the original implementation.2 For example, the original implementation makes it possible to create a situation in which two users see different views of the roster: according to one user, both are visible to each other, while according to another, there is only a one-way visibility. The synthesized implementation does not suffer from these problems. We do not know how many source code defects contribute to the observed failures.\nEven Lucene\u2019s small data structure has been a source of defects. Overlapping words caused some of its internal statistics to become corrupted because the original developers did not foresee this possibility. Our Cozy implementation handles this case gracefully; the natural way to specify Lucene\u2019s operations does not have the defect."
        },
        {
            "heading": "4.5 Performance",
            "text": "We measured the performance of the handwritten and synthesized implementations on realistic workloads. Table 3 reports the wallclock time required to run each benchmark to completion. The benchmarks are end-to-end, and include application behavior in addition to the data structure itself; the resulting time, therefore, represents the overall effect on each program from using the synthesized data structure.\nOur benchmarks for ZTopo and Sat4j are the same ones used to evaluate an earlier iteration of Cozy [16]. The ZTopo benchmark is a log of recorded application usage that we replay. The Cozysynthesized implementation of the ZTopo tile cache matches the performance of the existing implementation almost exactly. The handwritten and synthesized implementations are conceptually identical: both store map tiles in linked lists grouped by tile type. The dominant factor affecting performance is the speed of finding tiles by unique ID, which both implementations do using a hash table.\n1https://issues.igniterealtime.org/browse/OF-1121 2https://community.igniterealtime.org/thread/60317\nSat4j\u2019s benchmark suite consists of eleven randomly-selected input files from the 2002 boolean satisfiability solver competition [18, 22]. The synthesized data structure for Sat4j under-performs the existing implementation. The handwritten code exploits some facts about the data that Cozy does not know: in Sat4j, variable IDs can be used as indexes into an array since they always fall between zero and a known maximum bound. This interacts poorly with Cozy\u2019s total semantics for map lookups. At code generation time, Cozy must insert safety checks at every map lookup. In Sat4j those safety checks are unnecessary and harm performance substantially.\nOur benchmark for Openfire is a replayed sequence of actions against its admin panel that offers direct access to the internal roster data structure, where users, groups, and explicit contacts can be modified. The synthesized structure improves performance slightly. There are several contributing factors, but the dominant one is that the synthesized data structure can avoid a number of expensive internal representation checks. To improve correctness, the handwritten implementation will often clean up its own state, which imposes some overhead. By generating correct code, Cozy avoids these internal checks.\nOur benchmark for Lucene is a series of operations on artificial data. Cozy\u2019s synthesized data structure for Lucene is very similar to the manually written one, leading to identical performance."
        },
        {
            "heading": "5 RELATEDWORK",
            "text": "The data structure synthesis problem dates to the 1970s and iterator inversion, a technique for constructing data structures to accelerate iterative operations [9, 10]. Our syntax for queries is similar to that found in Earley\u2019s work, although our techniques are substantially more powerful. Iterator inversion required handwritten rewrite rules, while Cozy\u2019s exhaustive search discovers complex transformations unaided.\nThe developers of the SETL language took a different approach by splitting it into a pure language and a representation sub-language. The sub-language specifies what structures to use when running pure code [8, 19, 20]. More recently, researchers have investigated dynamic techniques to achieve the same effect [21]. Beyond simply choosing better existing implementations of an interface, Cozy can implement more complex interfaces that require composing data structure representations.\nModern program synthesis techniques have been applied to lowlevel data structure code [23, 27]. These techniques can help to write pointer and array manipulations but, unlike our work, require the programmer to choose a data representation in advance.\nMore recently, researchers have made headway on synthesizing complete data structures. RelC [11] constructs data structure implementations that track subsets of a collection. It was later extended to produce safe concurrent data structures [12]. An earlier version of Cozy [16] used a custom \u201coutline language\u201d to describe data structure implementations and was able to synthesize data structures with richer specifications than RelC. By generalizing to arbitrary expressions and concretization functions, Cozy can now synthesize a far wider class of data structures, including the data structures for Openfire and Lucene that require multiple related collections and aggregation operators. To gain this expressiveness we have given up decidability, relying instead on bounded verification.\nRelC and earlier versions of Cozy had a tuning step that used a user-supplied benchmark to make low-level optimizations. Cozy no longer has this step. Its effectiveness was never fully evaluated and our powerful symbolic cost model now fills the role. Some data structures that Cozy originally supported have also been dropped. These were not necessary for the case studies we explored, but we plan to reimplement them to extend Cozy\u2019s applicability.\nCozy\u2019s high-level algorithm resembles programming by refinement (PBR), in which programs are produced by manual iterative modifications to an initial specification. Unlike PBR tools such as KIDS [24], Designware [25], and Fiat [7], each refinement iteration that Cozy makes may bear little resemblance to the implementation before it. This is because Cozy enumerates possible solutions in a fixed order rather than transforming the input specification. Furthermore, Cozy requires no manual effort beyond writing a specification. The cost of this simplicity is that Cozy cannot produce many of the more complicated algorithms derived by PBR systems. However, Cozy can automate parts of the job, specifically the \u201cfinite differencing\u201d and \u201cdata type refinement\u201d tasks [24].\nThe transformations that Cozy performs are akin to the index selection and view maintenance problems in database systems. Index selection is the task of choosing useful indexes to speed up desired queries. AutoAdmin [1, 5] solves the problem by enumerating many possible indexes and using a query planner to decide which work best. As a result, AutoAdmin is limited by the set of optimization rules available to the query planner.\nViewmaintenance is the problem of keeping an index ormaterialized view up-to-date as the data changes. Materialized views are similar to Cozy\u2019s concretization functions: they can be computed from the original state of the database. DBToaster [2] implements a very efficient view maintenance system. More recently, the same team has worked on generalizing these ideas to collections, including nested collections [15]. While it is possible to augment Cozy with these techniques, Cozy\u2019s enumerative synthesizer generally discovers those same solutions without the need for manual rewrite rules."
        },
        {
            "heading": "6 CONCLUSION",
            "text": "Cozy is effective because incrementalization allows it to implement both pure and imperative operations using only a query synthesizer. A high-quality cost function and diversity injection make the query synthesizer powerful and practical. As a result, Cozy does not need clever analyses or transformation rules. Our case studies demonstrate that data structure synthesis can improve software development time, correctness, and efficiency."
        },
        {
            "heading": "Acknowledgments",
            "text": "David Grant assisted with the Cozy implementation and the Lucene case study. This material is based upon work supported by the United States Air Force under Contract No. FA8750-15-C-0010, and on research sponsored by Air Force Research Laboratory andDARPAunder agreement number FA8750-16-2-0032. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. This work is supported in part by NSF grant CCF-1651225, and the Intel and NSF joint research center for Computer Assisted Programming for Heterogeneous Architectures (CAPA)."
        }
    ],
    "title": "Generalized Data Structure Synthesis",
    "year": 2018
}