{
    "abstractText": "It is common to use weakly consistent replication to achieve high availability and low latency at a global scale. In this setting, concurrent updates may lead to states where application invariants do not hold. Some systems coordinate the execution of (conflicting) operations to avoid invariant violations, leading to high latency and reduced availability for those operations. This problem is worsened by the difficulty in identifying precisely which operations conflict. In this paper we propose a novel approach to preserve application invariants without coordinating the execution of operations. The approach consists of modifying operations in a way that application invariants are maintained in the presence of concurrent updates. When no conflicting updates occur, the modified operations present their original semantics. Otherwise, we use sensible and deterministic conflict resolution policies that preserve the invariants of the application. To implement this approach, we developed a static analysis, IPA, that identifies conflicting operations and proposes the necessary modifications to operations. Our analysis shows that IPA can avoid invariant violations in many applications, including typical database applications. Our evaluation reveals that the offline static analysis runs fast enough for being used with large applications. The overhead introduced in the modified operations is low and it leads to lower latency and higher throughput when compared with other approaches that enforce invariants. PVLDB Reference Format: Valter Balegas, S\u00e9rgio Duarte, Carla Ferreira, Rodrigo Rodrigues, Nuno Pregui\u00e7a. IPA: Invariant-Preserving Applications for Weakly Consistent Replicated Databases. PVLDB, 12(4): 404-418, 2018. DOI: https://doi.org/10.14778/3297753.3297760",
    "authors": [
        {
            "affiliations": [],
            "name": "Valter Balegas"
        },
        {
            "affiliations": [],
            "name": "S\u00e9rgio Duarte"
        },
        {
            "affiliations": [],
            "name": "Carla Ferreira"
        },
        {
            "affiliations": [],
            "name": "Rodrigo Rodrigues"
        },
        {
            "affiliations": [],
            "name": "Nuno Pregui\u00e7a"
        }
    ],
    "id": "SP:bfeae3af0d005992f987a32882477240d9db9b0c",
    "references": [
        {
            "authors": [
                "D.D. Akkoorath",
                "A.Z. Tomsic",
                "M. Bravo",
                "Z. Li",
                "T. Crain",
                "A. Bieniusa",
                "N. Pregui\u00e7a",
                "M. Shapiro"
            ],
            "title": "Cure: Strong semantics meets high availability and low latency",
            "venue": "Proceedings of the 36th IEEE International Conference on Distributed Computing Systems (ICDCS 2016), pages 405\u2013414, Nara, Japan, June",
            "year": 2016
        },
        {
            "authors": [
                "S. Almeida",
                "J. Leit\u00e3o",
                "L. Rodrigues"
            ],
            "title": "ChainReaction: A Causal+ Consistent Datastore Based on Chain Replication",
            "venue": "Proceedings 8th ACM European Conference on Computer Systems, EuroSys \u201913, pages 85\u201398, Prague, Czech Republic,",
            "year": 2013
        },
        {
            "authors": [
                "P. Alvaro",
                "N. Conway",
                "J.M. Hellerstein",
                "D. Maier"
            ],
            "title": "Blazes: Coordination analysis for distributed programs",
            "venue": "Proceedings of the IEEE 30th International Conference on Data Engineering March 31 - April 4, 2014, pages 52\u201363, Chicago, Illinois, USA, Apr.",
            "year": 2014
        },
        {
            "authors": [
                "P. Bailis",
                "A. Davidson",
                "A. Fekete",
                "A. Ghodsi",
                "J.M. Hellerstein",
                "I. Stoica"
            ],
            "title": "Highly available transactions: Virtues and limitations",
            "venue": "PVLDB, 7(3):181\u2013192,",
            "year": 2013
        },
        {
            "authors": [
                "P. Bailis",
                "A. Fekete",
                "M.J. Franklin",
                "A. Ghodsi",
                "J.M. Hellerstein",
                "I. Stoica"
            ],
            "title": "Coordination avoidance in database systems",
            "venue": "PVLDB, 8(3):185\u2013196,",
            "year": 2014
        },
        {
            "authors": [
                "P. Bailis",
                "A. Fekete",
                "M.J. Franklin",
                "A. Ghodsi",
                "J.M. Hellerstein",
                "I. Stoica"
            ],
            "title": "Feral Concurrency Control: An Empirical Investigation of Modern Application Integrity",
            "venue": "Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201915, pages 1327\u20131342, Melbourne, Victoria, Australia,",
            "year": 2015
        },
        {
            "authors": [
                "P. Bailis",
                "A. Fekete",
                "J.M. Hellerstein",
                "A. Ghodsi",
                "I. Stoica"
            ],
            "title": "Scalable Atomic Visibility with RAMP Transactions",
            "venue": "Proceedings 2014 ACM SIGMOD Conference Conference on Management of Data, SIGMOD \u201914, pages 27\u201338, New York, NY, USA,",
            "year": 2014
        },
        {
            "authors": [
                "P. Bailis",
                "A. Ghodsi",
                "J.M. Hellerstein",
                "I. Stoica"
            ],
            "title": "Bolt-on Causal Consistency",
            "venue": "Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201913, pages 761\u2013772, New York, New York, USA,",
            "year": 2013
        },
        {
            "authors": [
                "J. Baker",
                "C. Bond",
                "J.C. Corbett",
                "J. Furman",
                "A. Khorlin",
                "J. Larson",
                "J.-M. Leon",
                "Y. Li",
                "A. Lloyd",
                "V. Yushprakh"
            ],
            "title": "Megastore: Providing Scalable, Highly Available Storage for Interactive Services",
            "venue": "Proceedings of the Conference on Innovative Data system Research (CIDR), pages 223\u2013234,",
            "year": 2011
        },
        {
            "authors": [
                "V. Balegas",
                "S. Duarte",
                "C. Ferreira",
                "R. Rodrigues",
                "N. Pregui\u00e7a",
                "M. Najafzadeh",
                "M. Shapiro"
            ],
            "title": "Putting Consistency Back into Eventual Consistency",
            "venue": "Proceedings of the Tenth European Conference on Computer Systems, EuroSys \u201915, pages 6:1\u20136:16, Bordeaux, France,",
            "year": 2015
        },
        {
            "authors": [
                "V. Balegas",
                "N. Pregui\u00e7a",
                "S. Duarte",
                "C. Ferreira",
                "R. Rodrigues"
            ],
            "title": "IPA: Invariant-preserving Applications for Weakly-consistent Replicated Databases",
            "venue": "CoRR, abs/1802.08474,",
            "year": 2018
        },
        {
            "authors": [
                "V. Balegas",
                "D. Serra",
                "S. Duarte",
                "C. Ferreira",
                "M. Shapiro",
                "R. Rodrigues",
                "N. Pregui\u00e7a"
            ],
            "title": "Extending Eventually Consistent Cloud Databases for Enforcing Numeric Invariants",
            "venue": "Proceedings of the 34th IEEE Symposium on Reliable Distributed Systems (SRDS), pages 31\u201336, Montreal, Canada, Sept",
            "year": 2015
        },
        {
            "authors": [
                "C. Biyikoglu"
            ],
            "title": "Under the Hood: Redis CRDTs",
            "venue": "https://goo.gl/tGqU7h. Accessed",
            "year": 2018
        },
        {
            "authors": [
                "N. Conway",
                "W.R. Marczak",
                "P. Alvaro",
                "J.M. Hellerstein",
                "D. Maier"
            ],
            "title": "Logic and Lattices for Distributed Programming",
            "venue": "Proceedings of the 3rd ACM Symposium on Cloud Computing, SoCC \u201912, pages 1:1\u20131:14, San Jose, California,",
            "year": 2012
        },
        {
            "authors": [
                "J.C. Corbett",
                "J. Dean",
                "M. Epstein",
                "A. Fikes",
                "C. Frost",
                "J.J. Furman",
                "S. Ghemawat",
                "A. Gubarev",
                "C. Heiser",
                "P. Hochschild",
                "W. Hsieh",
                "S. Kanthak",
                "E. Kogan",
                "H. Li",
                "A. Lloyd",
                "S. Melnik",
                "D. Mwaura",
                "D. Nagle",
                "S. Quinlan",
                "R. Rao",
                "L. Rolig",
                "Y. Saito",
                "M. Szymaniak",
                "C. Taylor",
                "R. Wang",
                "D. Woodford"
            ],
            "title": "Spanner: Google\u2019s Globally-distributed Database",
            "venue": "Proceedings 10th USENIX Conference on Operating Systems Design and Implementation, OSDI\u201912, pages 251\u2013264, Hollywood, USA,",
            "year": 2012
        },
        {
            "authors": [
                "L. De Moura",
                "N. Bj\u00f8rner"
            ],
            "title": "Z3: An Efficient SMT Solver",
            "venue": "Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS\u201908/ETAPS\u201908, pages 337\u2013340. Springer-Verlag, Budapest, Hungary,",
            "year": 2008
        },
        {
            "authors": [
                "G. DeCandia",
                "D. Hastorun",
                "M. Jampani",
                "G. Kakulapati",
                "A. Lakshman",
                "A. Pilchin",
                "S. Sivasubramanian",
                "P. Vosshall",
                "W. Vogels"
            ],
            "title": "Dynamo: Amazon\u2019s Highly Available Key-value Store",
            "venue": "Proceedings of the 21st ACM SIGOPS Symposium on Operating Systems Principles, SOSP \u201907, pages 205\u2013220, Stevenson, Washington, USA,",
            "year": 2007
        },
        {
            "authors": [
                "A. Dragojevi\u0107",
                "D. Narayanan",
                "E.B. Nightingale",
                "M. Renzelmann",
                "A. Shamis",
                "A. Badam",
                "M. Castro"
            ],
            "title": "No Compromises: Distributed Transactions with Consistency, Availability, and Performance",
            "venue": "Proceedings of the 25th Symposium on Operating Systems Principles, SOSP \u201915, pages 54\u201370, Monterey, California,",
            "year": 2015
        },
        {
            "authors": [
                "M.D. Ernst",
                "J.H. Perkins",
                "P.J. Guo",
                "S. McCamant",
                "C. Pacheco",
                "M.S. Tschantz",
                "C. Xiao"
            ],
            "title": "The Daikon System for Dynamic Detection of Likely Invariants",
            "venue": "Science of Computer Programming, 69(1-3):35\u201345, Dec.",
            "year": 2007
        },
        {
            "authors": [
                "C. Flanagan",
                "K.R.M. Leino"
            ],
            "title": "Houdini, an Annotation Assistant for ESC/Java",
            "venue": "Proceedings of the International Symposium of Formal Methods Europe on Formal Methods for Increasing Software Productivity, FME \u201901, pages 500\u2013517, Berlin, Germany,",
            "year": 2001
        },
        {
            "authors": [
                "C. Flanagan",
                "K.R.M. Leino",
                "M. Lillibridge",
                "G. Nelson",
                "J.B. Saxe",
                "R. Stata"
            ],
            "title": "Extended Static Checking for Java",
            "venue": "Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, PLDI \u201902, pages 234\u2013245, Berlin, Germany,",
            "year": 2002
        },
        {
            "authors": [
                "H. Garcia-Molina",
                "K. Salem"
            ],
            "title": "Sagas",
            "venue": "Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201987, pages 249\u2013259, San Francisco, USA,",
            "year": 1987
        },
        {
            "authors": [
                "S. Gilbert",
                "N. Lynch"
            ],
            "title": "Brewer\u2019s Conjecture and the 416 Feasibility of Consistent, Available, Partition-tolerant Web Services",
            "venue": "SIGACT News, 33(2):51\u201359, June",
            "year": 2002
        },
        {
            "authors": [
                "A. Gotsman",
                "H. Yang",
                "C. Ferreira",
                "M. Najafzadeh",
                "M. Shapiro"
            ],
            "title": "Cause I\u2019m Strong Enough: Reasoning About Consistency Choices in Distributed Systems",
            "venue": "Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL \u201916, pages 371\u2013384, St. Petersburg, USA,",
            "year": 2016
        },
        {
            "authors": [
                "C. Hawblitzel",
                "J. Howell",
                "M. Kapritsos",
                "J.R. Lorch",
                "B. Parno",
                "M.L. Roberts",
                "S. Setty",
                "B. Zill"
            ],
            "title": "IronFleet: Proving Practical Distributed Systems Correct",
            "venue": "Proceedings of the 25th Symposium on Operating Systems Principles, SOSP \u201915, pages 1\u201317, Monterey, USA,",
            "year": 2015
        },
        {
            "authors": [
                "P. Helland",
                "D. Campbell"
            ],
            "title": "Building on quicksand",
            "venue": "Online Proceedings of CIDR 2009 Fourth Biennial Conference on Innovative Data Systems Research, Asilomar, USA, Jan.",
            "year": 2009
        },
        {
            "authors": [
                "B. Holt",
                "J. Bornholt",
                "I. Zhang",
                "D. Ports",
                "M. Oskin",
                "L. Ceze"
            ],
            "title": "Disciplined Inconsistency with Consistency Types",
            "venue": "Proceedings of the 7th ACM Symposium on Cloud Computing, SoCC \u201916, pages 279\u2013293, Santa Clara, USA,",
            "year": 2016
        },
        {
            "authors": [
                "T. Kraska",
                "G. Pang",
                "M.J. Franklin",
                "S. Madden",
                "A. Fekete"
            ],
            "title": "MDCC: Multi-data Center Consistency",
            "venue": "Proceedings 8th ACM European Conference on Computer Systems, EuroSys \u201913, pages 113\u2013126, Prague, Czech Republic,",
            "year": 2013
        },
        {
            "authors": [
                "A. Lakshman",
                "P. Malik"
            ],
            "title": "Cassandra: A Decentralized Structured Storage System",
            "venue": "SIGOPS Oper. Syst. Rev., 44(2):35\u201340, Apr.",
            "year": 2010
        },
        {
            "authors": [
                "L. Lamport"
            ],
            "title": "Time, Clocks, and the Ordering of Events in a Distributed System",
            "venue": "Communications of the ACM, 21(7):558\u2013565, July",
            "year": 1978
        },
        {
            "authors": [
                "C. Li",
                "J. Leit\u00e3o",
                "A. Clement",
                "N. Pregui\u00e7a",
                "R. Rodrigues",
                "V. Vafeiadis"
            ],
            "title": "Automating the Choice of Consistency Levels in Replicated Systems",
            "venue": "Proceedings of the 2014 USENIX Annual Technical Conference (USENIX ATC 14), pages 281\u2013292, Philadelphia, PA, June",
            "year": 2014
        },
        {
            "authors": [
                "C. Li",
                "D. Porto",
                "A. Clement",
                "J. Gehrke",
                "N. Pregui\u00e7a",
                "R. Rodrigues"
            ],
            "title": "Making Geo-replicated Systems Fast As Possible, Consistent when Necessary",
            "venue": "Proceedings 10th USENIX Conference on Operating Systems Design and Implementation, OSDI\u201912, pages 265\u2013278, Hollywood, USA,",
            "year": 2012
        },
        {
            "authors": [
                "C. Li",
                "N. Pregui\u00e7a",
                "R. Rodrigues"
            ],
            "title": "Fine-grained consistency for geo-replicated systems",
            "venue": "Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC 18), pages 359\u2013372, Boston, MA,",
            "year": 2018
        },
        {
            "authors": [
                "W. Lloyd",
                "M.J. Freedman",
                "M. Kaminsky",
                "D.G. Andersen"
            ],
            "title": "Don\u2019t Settle for Eventual: Scalable Causal Consistency for Wide-area Storage with COPS",
            "venue": "Proceedings of the 23rd ACM Symposium on Operating Systems Principles, SOSP \u201911, pages 401\u2013416, Cascais, Portugal,",
            "year": 2011
        },
        {
            "authors": [
                "W. Lloyd",
                "M.J. Freedman",
                "M. Kaminsky",
                "D.G. Andersen"
            ],
            "title": "Stronger Semantics for Low-latency Geo-replicated Storage",
            "venue": "Proceedings 10th USENIX Conference on Networked Systems Design and Implementation, NSDI\u201913, pages 313\u2013328, Lombard, USA,",
            "year": 2013
        },
        {
            "authors": [
                "P.E. O\u2019Neil"
            ],
            "title": "The Escrow Transactional Method",
            "venue": "ACM Trans. Database Syst.,",
            "year": 1986
        },
        {
            "authors": [
                "G. Pang",
                "T. Kraska",
                "M.J. Franklin",
                "A. Fekete"
            ],
            "title": "PLANET: Making Progress with Commit Processing in Unpredictable Environments",
            "venue": "Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201914, pages 3\u201314, Snowbird, Utah, USA,",
            "year": 2014
        },
        {
            "authors": [
                "D.L. Parnas"
            ],
            "title": "Precise Documentation: The Key to Better Software",
            "venue": "S. Nanz, editor, The Future of Software Engineering, pages 125\u2013148. Springer,",
            "year": 2010
        },
        {
            "authors": [
                "S. Roy",
                "L. Kot",
                "G. Bender",
                "B. Ding",
                "H. Hojjat",
                "C. Koch",
                "N. Foster",
                "J. Gehrke"
            ],
            "title": "The Homeostasis Protocol: Avoiding Transaction Coordination Through Program Analysis",
            "venue": "Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201915, pages 1311\u20131326, Melbourne, Victoria, Australia,",
            "year": 2015
        },
        {
            "authors": [
                "M. Shapiro",
                "N. Pregui\u00e7a",
                "C. Baquero",
                "M. Zawirski"
            ],
            "title": "A comprehensive Study of Convergent and Commutative Replicated Data Types",
            "venue": "Research Report RR-7506, INRIA, Jan.",
            "year": 2011
        },
        {
            "authors": [
                "M. Shapiro",
                "N. Pregui\u00e7a",
                "C. Baquero",
                "M. Zawirski"
            ],
            "title": "Conflict-free Replicated Data Types",
            "venue": "Proceedings of the 13th Conference Conference on Stabilization, Safety, and Security of Distributed Systems, SSS\u201911, pages 386\u2013400, Grenoble, France,",
            "year": 2011
        },
        {
            "authors": [
                "S. Sivasubramanian"
            ],
            "title": "Amazon DynamoDB: A Seamlessly Scalable Non-relational Database Service",
            "venue": "Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201912, pages 729\u2013730, Scottsdale, Arizona, USA,",
            "year": 2012
        },
        {
            "authors": [
                "V.B. Sousa"
            ],
            "title": "Invariant Preservation in Geo-replicated Data Stores",
            "venue": "PhD thesis, Faculdade de Ci\u00eancias e Tecnologia, Universidade NOVA de Lisboa, 12",
            "year": 2017
        },
        {
            "authors": [
                "Y. Sovran",
                "R. Power",
                "M.K. Aguilera",
                "J. Li"
            ],
            "title": "Transactional Storage for Geo-replicated Systems",
            "venue": "Proceedings of the 23rd ACM Symposium on Operating Systems Principles, SOSP \u201911, pages 385\u2013400, Cascais, Portugal,",
            "year": 2011
        },
        {
            "authors": [
                "D.B. Terry",
                "M.M. Theimer",
                "K. Petersen",
                "A.J. Demers",
                "M.J. Spreitzer",
                "C.H. Hauser"
            ],
            "title": "Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System",
            "venue": "Proceedings of the 15th ACM Symposium on Operating Systems Principles, SOSP \u201995, pages 172\u2013182, Copper Mountain, Colorado, USA,",
            "year": 1995
        },
        {
            "authors": [
                "S. Tu",
                "W. Zheng",
                "E. Kohler",
                "B. Liskov",
                "S. Madden"
            ],
            "title": "Speedy Transactions in Multicore In-memory Databases",
            "venue": "Proceedings of the 24th ACM Symposium on Operating Systems Principles, SOSP \u201913, pages 18\u201332, Farminton, Pennsylvania, USA,",
            "year": 2013
        },
        {
            "authors": [
                "W. Vogels"
            ],
            "title": "Eventually consistent",
            "venue": "Communications of the ACM, 52(1):40\u201344, Jan.",
            "year": 2009
        },
        {
            "authors": [
                "T. Warszawski",
                "P. Bailis"
            ],
            "title": "ACIDRain: Concurrency-Related Attacks on Database-Backed Web Applications",
            "venue": "Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD \u201917, pages 5\u201320, Chicago, Illinois, USA,",
            "year": 2017
        },
        {
            "authors": [
                "M. Whittaker",
                "J.M. Hellerstein"
            ],
            "title": "Interactive checks for coordination avoidance",
            "venue": "PVLDB, 2(1):14\u201327,",
            "year": 2018
        },
        {
            "authors": [
                "J.R. Wilcox",
                "D. Woos",
                "P. Panchekha",
                "Z. Tatlock",
                "X. Wang",
                "M.D. Ernst",
                "T. Anderson"
            ],
            "title": "Verdi: A Framework for Implementing and Formally Verifying Distributed Systems",
            "venue": "Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI \u201915, pages 357\u2013368, Portland, OR, USA,",
            "year": 2015
        },
        {
            "authors": [
                "C. Xie",
                "C. Su",
                "M. Kapritsos",
                "Y. Wang",
                "N. Yaghmazadeh",
                "L. Alvisi",
                "P. Mahajan"
            ],
            "title": "Salt: Combining acid and base in a distributed database",
            "venue": "Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation, OSDI\u201914, pages 495\u2013509, Broomfield, CO, 417 USA,",
            "year": 2014
        },
        {
            "authors": [
                "M. Zawirski",
                "N. Pregui\u00e7a",
                "S. Duarte",
                "A. Bieniusa",
                "V. Balegas",
                "M. Shapiro"
            ],
            "title": "Write Fast, Read in the Past: Causal Consistency for Client-Side Applications",
            "venue": "Proceedings of the 16th Annual Middleware Conference, Middleware \u201915, pages 75\u201387, Vancouver, BC, Canada,",
            "year": 2015
        },
        {
            "authors": [
                "Y. Zhang",
                "R. Power",
                "S. Zhou",
                "Y. Sovran",
                "M.K. Aguilera",
                "J. Li"
            ],
            "title": "Transaction Chains: Achieving Serializability with Low Latency in Geo-distributed Storage Systems",
            "venue": "Proceedings of the 24th ACM Symposium on Operating Systems Principles, SOSP \u201913, pages 276\u2013291, Farminton, Pennsylvania, USA,",
            "year": 2013
        }
    ],
    "sections": [
        {
            "text": "In this paper we propose a novel approach to preserve application invariants without coordinating the execution of operations. The approach consists of modifying operations in a way that application invariants are maintained in the presence of concurrent updates. When no conflicting updates occur, the modified operations present their original semantics. Otherwise, we use sensible and deterministic conflict resolution policies that preserve the invariants of the application. To implement this approach, we developed a static analysis, IPA, that identifies conflicting operations and proposes the necessary modifications to operations.\nOur analysis shows that IPA can avoid invariant violations in many applications, including typical database applications. Our evaluation reveals that the offline static analysis runs fast enough for being used with large applications. The overhead introduced in the modified operations is low and it leads to lower latency and higher throughput when compared with other approaches that enforce invariants.\nPVLDB Reference Format: Valter Balegas, Se\u0301rgio Duarte, Carla Ferreira, Rodrigo Rodrigues, Nuno Preguic\u0327a. IPA: Invariant-Preserving Applications for Weakly Consistent Replicated Databases. PVLDB, 12(4): 404-418, 2018. DOI: https://doi.org/10.14778/3297753.3297760"
        },
        {
            "heading": "1. INTRODUCTION",
            "text": "Databases are commonly replicated in different geographical regions to ensure low latency and high availability across the globe [22,\nThis work is licensed under the Creative Commons AttributionNonCommercial-NoDerivatives 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/. For any use beyond those covered by this license, obtain permission by emailing info@vldb.org. Copyright is held by the owner/author(s). Publication rights licensed to the VLDB Endowment. Proceedings of the VLDB Endowment, Vol. 12, No. 4 ISSN 2150-8097. DOI: https://doi.org/10.14778/3297753.3297760\n49, 20]. To provide these guarantees, systems often adopt weak consistency. This approach can expose temporary state divergence to clients, making application development more difficult. Many techniques have been proposed to make these systems easier to program: conflict-free replicated data types [45] (CRDTs) ensure state convergence; causal consistency [39, 12, 57] enforces that operations are made visible respecting the happens-before relation; and, finally, highly available transactions [8, 11, 40, 49, 57] can group multiple operations that must take effect all at once.\nDespite these proposals, it remains difficult to develop applications under weak consistency. Several studies [10, 32, 53] show that, in many applications, concurrent executions lead to the violation of application invariants, resulting in inconsistent states. To give an example, consider an online e-games platform, and assume that the application is correct when executed under strong consistency. Consider that a user enrolls in some tournament and concurrently the organizer decides to cancel the tournament. The first operation creates a new reference between the user and the tournament, while the second removes the tournament, and all references to it. Since these operations are concurrent, the remove operation does not delete the newly created reference, which now points to a tournament that no longer exists, thus breaking referential integrity.\nTo prevent invariant violations efficiently, some systems provide primitives for executing operations synchronously [49, 37], paying the cost of coordination only when necessary. However, it is difficult to identify the problematic executions, especially because inconsistencies may occur only for some combinations of operations and in some specific states. The result is that programmers often end up constraining concurrency too much to preserve correctness, with an impact on the availability and latency of systems [14, 19].\nThis paper proposes a novel approach for preserving application invariants under weak consistency that does not impact the availability and latency of applications. The key idea is to extend operations with updates that preventively guarantee the preservation of invariants in the presence of concurrent updates. The additional updates should have no visible effect if no concurrent operation is executed, keeping the semantics of the operation in the sequential case. These updates come into effect when needed to correct the undesirable semantics of concurrent operations. In our previous example, it is possible to maintain referential integrity by restoring the removed tournament. To this end, the enroll operation is extended with an update that prevents the concurrent deletion of the tournament.\nTo help programmers adopt our approach, we propose a methodology for modifying applications. The key element of the methodology is our invariant-preservation analysis (IPA) and static analysis tool that relies on information about the application, including invariants and operations, to identify which operations might lead to invariant violations and to suggest modifications to the operations to prevent those violations from occurring. Previous work employed static analysis to optimize the use of coordination in applications running under weak consistency [36, 14, 44]. In contrast, instead of resorting to coordination for avoiding the concurrent execution of conflicting operations, we allow operations to execute concurrently and leverage conflict resolution policies to ensure a result that is deterministic (given the operations that execute concurrently) and preserves invariants. To our knowledge, our work is the first to adopt such an approach to enforce invariants that span multiple database objects (that can be stored on different machines).\nOur evaluation is threefold. First, we analyzed a number of applications/benchmarks that are representative of common OLTP applications, concluding that our approach can identify the most common relational database invariant violations, and that the suggested modifications lead to sensible and deterministic semantics in the concurrent case. Furthermore, the semantics of the modified operations is equivalent to the original operations when no conflicting operation executes concurrently. Second, we analyze the scalability of the static analysis process, showing that it is fast enough to be used with large applications. Third, the results of our experiments show that the performance of the modified applications has only a small overhead compared to the unmodified versions and is faster than a state-of-the-art solution that maintains invariants using coordination to prevent invariant violations.\nIn this paper we make the following contributions: (i) a novel approach to preserve invariants under weak consistency without resorting to coordination, which combines the extension of operations with new updates and the use of appropriate conflict resolution policies; (ii) an algorithm that takes information about operations and application invariants and proposes modifications to operations and conflict resolution policies to preserve invariants while keeping the original semantics of the operations in the absence of conflicts; (iii) the design of new CRDTs that support the conflict resolution policies necessary for adopting our approach; (iv) an implementation and evaluation of the proposed approach.\nThe paper discusses the difficulties in designing applications on top of weak consistency (\u00a72); presents an overview of the IPA approach (\u00a73); presents the system model and defines the key principles for IPA (\u00a74); details the IPA analysis (\u00a75); discusses implementation details (\u00a76); evaluates the approach and prototype (\u00a77); discusses related work (\u00a78); and presents some final remarks (\u00a79)."
        },
        {
            "heading": "2. BACKGROUND",
            "text": "In this section we discuss the problem of application correctness when executing applications under weak consistency."
        },
        {
            "heading": "2.1 Eventual consistency and CRDTs",
            "text": "Storage systems that adopt weak consistency models, such as eventual consistency [50, 52, 22, 34] or causal+ consistency [39, 40, 57], need to include a mechanism to merge concurrent updates, guaranteeing that all replicas converge to the same state after applying the same set of updates. In last-writer-wins, the latest update, according to some total order defined among updates, prevails. This strategy may lead to lost updates, as the effects of an update may be overwritten by a concurrent update. To address this problem, some systems, such as Cassandra, support type-specific merge for some data types \u2013 e.g., for counters, the final value reflects all updates.\nConflict-free replicated data types (CRDTs) [45, 46] are a principled approach for defining replicated objects. A CRDT is an abstract data type designed to be replicated. Any replica of a CRDT can be modified without coordination and any two replicas that receive the same set of updates converge to the same state, deterministically.\nA CRDT implements type-specific concurrency semantics, namely defining how to merge concurrent updates. For example, a set exports two operations for adding and removing an element: add(e) and remove(e). As these operations do not commute when referring to the same element, the concurrency semantics must arbitrate the state of the object when an add(e) and a remove(e) execute concurrently. Several concurrency semantics are possible. In the Add-wins semantics, an add wins (takes priority) over a concurrent remove, leading to a state where e belongs to the set after applying both updates. In the Rem-wins semantics, the remove wins over a concurrent add, leading to a state where e does not belong to the set.\nCRDTs were first used in research systems, such as Walter [49] and SwiftCloud [57]. More recently, they were adopted in production systems, such as Redis [18], Akka [4] and Riak [17]."
        },
        {
            "heading": "2.2 Convergence is not enough",
            "text": "State convergence is not sufficient to guarantee application correctness, as the final state might be invalid. This can occur when the rules for maintaining convergence are defined per data-type, not considering the relations among the multiple objects of the state.\nWe illustrate this problem with the application that stores information for an e-games platform introduced before. In this application, the database stores information about players , tournaments and which players are enrolled in which tournaments. Players can enroll or disenroll from tournaments, and a tournament can be removed by the administrator if there are no players enrolled. There is an implicit referential integrity invariant that states that a player may only enroll in an existing tournament.\nNow consider the concurrent execution of two operations to remove a tournament and enroll a player in that tournament, as shown in Figure 1. In state Si, the remove verifies that there is no entry in the enrolled table referring to tournament t and removes it. In the same state, the enroll operation creates a new reference between player p1 and t. Since the effects of each operation are generated in different replicas, the remove operation does not see p1 enrolled in t, whereas enroll still sees t. When the state of both replicas converges (Sf ), the state will have player p1 enrolled in tournament t, which no longer exists, thus breaking referential integrity.\nWe note that this problem still occurs in weakly consistent systems that provide additional guarantees, such as causal+ consistency and highly available transactions. Causal+ consistency [39, 40, 6] guarantees that the effects of an operation are only visible after the effects of all operations that happened-before [35] it. However, this does not impact the execution of concurrent operations.\nSome systems [8, 11, 57, 40] provide highly available transactions, in which a set of updates is applied atomically in a replica: concurrent transactions either see the effects of all updates or none. This type of transactions differs from ACID transactions by allowing concurrent updates to the same object, and the final value of the object is defined by the conflict resolution policy of the object."
        },
        {
            "heading": "3. OVERVIEW",
            "text": "In this section we explain our proposal to modify applications to ensure invariant preservation without coordination. The invariant violation of Figure 1 can be repaired, after it is detected, by either: (i) removing the new player enrollment from the enrolled table; or (ii) restoring the tournament to its previous state. In this type of approach, known as compensations [50, 27], when the system detects that the database is inconsistent, it applies some compensation effects to restore the database integrity.\nOur insight is that in many situations the effects to restore the database integrity can be applied preventively alongside the original operations, repairing the invariant violation automatically in a conflicting execution. Going back to our previous example, restoring a tournament to its previous state can be achieved by executing a touch operation in the tournament when executing the enroll, and adopting a conflict resolution policy where the touch wins over a concurrent delete. The touch operation has no observable effect, only updating the metadata to guarantee that the concurrent execution is detected and solved according to the defined conflict resolution policy. This approach has several interesting properties. First, it does not require any form of coordination during the execution of operations, or any mechanism for detecting invariant violations at runtime (which can be expensive, particularly when the invariant relates data stored in different servers). Second, the additional operations have no observable effect if no conflicting concurrent operations are executed.\nThis approach requires combining appropriate conflict resolution policies with a careful selection of which updates to add to each operation. The goal is to guarantee that the extra updates have no observable effect unless a conflicting operation is executed, and that, in such cases, the additional updates guarantee that the invariant is preserved. Additionally, it is necessary to guarantee that the extra updates do not lead to the violation of any other invariant and that modified operations do not interfere among themselves.\nTo help in this process, we devised algorithms that use static analysis to detect executions that might violate an application invariant, and search for modifications that prevent those violations. Typically, there will be several alternative modifications for preserving invariants \u2013 the programmer must select the most appropriate for her application. In most cases, the additional updates have no observable effect and can be applied preventively with the operations.\nFor some cases, the additional updates might have an observable effect on the database state. To address these cases, we also support a compensation mechanism that applies these updates if a conflict violation is detected. For instance, it is not possible to prevent flight overbooking, but it is possible to compensate the event by reimbursing users or finding alternative flights. Unlike other solutions, our approach does not require coordination to execute compensations, which can execute at any replica. However, the detection of invariant violation is limited to conditions over the state of a single object.\nExample: We now detail how our approach works, using the example of Figure 1. Consider that the database tables, player and tournament, and relationship, enrolled, are stored in separate sets.\nAs mentioned before, for preventing the invariant violation by recreating the deleted tournament, it suffices to extend the effects of the enroll operation to touch tournament t. By adopting the Add-wins policy for the tournament, with the touch tournament winning over a concurrent remove tournament, this guarantees that tournament t survives the concurrent execution of a remove t operation.\nFor preventing the invariant violation by deleting enrollments in removed tournaments, it suffices to extend the effects of the remove tournament t to preventively remove any concurrently enrolled pair associated with t. This does not produce any observable effect because there should be no element enrolled in t after the execution of\nthe remove operation. Adopting a Rem-wins policy for the enrolled set guarantees that a concurrent enroll will have no effect.\nWe can view the modifications to the operations as a way of giving priority to one conflicting operation over the other, the same way that a Add-wins (resp. Rem-wins) set CRDT gives priority to an add over a remove (resp. a remove over an add). The additional updates guarantee that the preconditions for executing the operation that is given priority remain valid despite the execution of any concurrent operation. For example, recreating the tournament is to give priority to the enroll over the remove tournament. The enroll precondition that would be violated is that the tournament exists. Touching the tournament and selecting the Add-wins policy guarantees that the precondition remains valid despite concurrent remove tournaments."
        },
        {
            "heading": "4. IPA APPROACH",
            "text": "This section introduces the main principles underlying IPA."
        },
        {
            "heading": "4.1 System model",
            "text": "We consider a database composed of a set of objects fully replicated in multiple data centers. Operations over those objects can execute a sequence of reads and updates enclosed in a transaction. As the transaction executes in an initial replica, the effects of updates are recorded and queued for replication upon transaction commit. Propagation of updates can be asynchronous and must respect causal order. Hereafter, we use the term operation to refer updates produced by the execution of the transaction code in the initial replica.\nWe denote by o(S) the state after applying the updates of operation o to state S. A database snapshot, Sn, is the state of the database after executing a sequence of operations o1, . . . , on in the initial database state, Sinit, i.e., Sn = on(. . . (o1(Sinit))). The set of operations reflected in snapshot S is denoted by Ops(S), e.g., Ops(Sn) = {o1, . . . , on}. The state of a replica results from applying both local and remote operations, in the order received.\nWe say that an operation oa happened-before [35] operation ob, executed initially in database snapshot Sb, oa\u227aob, iff oa\u2208Ops(Sb). Operations oa and ob are concurrent, oa \u2016ob iff oa 6\u227a ob\u2227ob 6\u227aoa.\nFor an execution of a given set of operations O, the happensbefore relation defines a partial order among operations,O = (O,\u227a). We say O\u2032 = (O,<) is a valid serialization of O = (O,\u227a) if O\u2032 is a linear extension of O, i.e., < is a total order compatible with \u227a.\nOperations can execute concurrently, with each replica executing operations according to a different valid serialization. To guarantee state convergence, we assume the system gives the programmer the choice of various deterministic conflict resolution policies on a perobject basis, i.e., the result of applying updates that were executed concurrently is deterministic independently of the execution order. In our prototype, we rely on CRDTs [45, 49] to achieve this goal.\nWe consider that application correctness can be expressed in terms of invariants [9, 14, 29]. An invariant is a logical condition expressed over the database state. A given state S preserves an invariant I iff I(S) = true, where I(S) is a function that checks the validity of the invariant in state S. A state Si is I-valid (or simply valid) iff I(Si) = true; otherwise the state is I-invalid (or simply invalid). We require the initial state, Sinit, to be valid.\nWe say thatO\u2032 = (O,<) is an I-valid serialization ofO = (O,\u227a) if O\u2032 is a valid serialization of O, and I holds in every state that results from executing any possible prefix of O\u2032. If I is the conjunction of all application invariants, then we say that an application is correct if, in any possible execution of that application, every replica evolves through a sequence of I-valid states. We say that an operation o1 conflicts with o2 if the execution of o1 makes the preconditions of o2 false in some database state."
        },
        {
            "heading": "4.2 Principles for IPA",
            "text": "We now present the key principles for guaranteeing the correct execution of an application under weak consistency. We follow the notions introduced by Bailis et al. [9], adapting them to our model.\nDEFINITION 1. Given a set of commutative operations O and the happens-before relation, \u227a, we say O is I-Confluent [9] iff any state S, obtained by executing a prefix of any valid serialization of (O,\u227a), starting from an I-valid state, is I-valid.\nThis means that for a set of I-Confluent operations, despite executing operations in a different serialization order, every replica will evolve only through I-valid states. Along with the commutativity of the operations, this guarantees the correctness of application execution both in terms of convergence and invariant-preservation.\nTo preserve invariants, an operation should only produce side effects in states that satisfy the operation preconditions. For example, for adding a player to a tournament, the player and tournament must exist. When an operation executes in the initial replica, the code of the operation verifies that the local state satisfies the preconditions.\nThe challenge arises when operation side-effects propagate asynchronously to remote replicas. At the remote replica, concurrent operations may have already executed, leading to a state where the operation preconditions do not hold anymore. Applying the sideeffects as-is may result in an invariant violation \u2013 e.g., applying the effects of adding a player to a tournament in a state where the tournament has been removed leads to an invariant violation.\nDEFINITION 2. Given a set of operations O and the happensbefore order, \u227a, we say that S is an admissible state for o \u2208 O iff there is a valid serialization of (O,\u227a) in which S results from applying all operations that precede o to the initial state.\nWith this definition in place, we can state a sufficient condition for having I-Confluent operations, thus enabling the system to execute operations in remote replicas without violating the invariants.\nTHEOREM 1. Given a set of commutative operations O and the happens-before order among them, \u227a, if for any operation o and admissible state S of o, o(S) is also an I-valid state, then O is an I-Confluent set.\nThe key insight of IPA is that, in many cases, it is possible to guarantee both commutativity and the sufficient property of Theorem 1 by leveraging CRDTs and extending operations with updates that restore the operation preconditions. In the example of the previous section, an operation to enroll a player in a tournament can execute safely if it restores the player and tournament. This can be achieved by touching both the player and tournament and using an Add-wins conflict resolution policy for players and tournaments, thus protecting the enroll operation against concurrent removal of the player or tournament. The deterministic nature of Add-wins and Rem-wins, with conflicts solved based only on the type of concurrent operations, is key for achieving the intended result.\nWe note that it is only necessary to restore the preconditions in admissible states, as the serialization of operations must be consistent with the happens-before relation. In practice, it is necessary to execute operations in causal order and revert the effects of concurrent updates that may affect the preconditions of the operation. The additional updates in an operation should be executed atomically with the updates of the operation to guarantee that no inconsistency is observed. In our prototype, we achieve this by relying on highly available transactions [8, 57]. In the next sections we show how to put these principles into practice."
        },
        {
            "heading": "5. IPA DESIGN",
            "text": "We now present our methodology for developing I-Confluent applications, comprising the following three steps. Step 1: Specification: The first step consists of building a specification of the application by identifying application invariants and operation effects. We use the same specification language used in Indigo [14], requiring programmers to specify the invariants and the effects of each operation using first-order logic.\nStep 2: IPA analysis: The IPA analysis, performed by our tool, is an iterative process where, in each iteration: (i) the tool identifies a pair of conflicting operations, i.e., operations that might break some invariant when executed concurrently, and proposes modifications that guarantee that invariants are preserved; (ii) the programmer chooses which conflict resolution he or she prefers. This process executes multiple times until no more conflicts exist.\nStep 3: Code modification: The analysis returns a new specification of the application, which contains the selected modifications, comprising both the use of appropriate conflict resolution policies for each object and the modification to operations to avoid invariant violations. When the modifications produce no observable effect, they are appended to the corresponding operations. Otherwise, they must execute as compensations when a conflict occurs.\nFully patched applications can then execute in any replicated system that provides causal consistency, highly available transactions and the necessary type-specific conflict resolution policies. A number of systems support these features [49, 57, 5]."
        },
        {
            "heading": "5.1 Specification",
            "text": "The specification of an application conveys information about invariants and operation effects. This is done using first-order logic, which is sufficiently expressive to cover most common relational databases constraints and operation effects [14, 29, 10].\nIn Figure 2, we present the specification of the tournament application. Predicates are used to represent the database state. Invariants are represented by quantified boolean statements, and operation effects are modeled with predicate assignments. For example, the logical implication in line 2 specifies an invariant that says that a player p may only be enrolled in a tournament t if player p and tournament t exist in the database. Predicate assignments can either set the value of a boolean predicate to true or false, or apply an arithmetic operator to the predicate, in the case of numerical predicates. As an example, the effects of operation enroll(p, t) set the predicate enrolled(p, t) to true (line 21) and increment the number of elements in the enrolled set for tournament t (line 22)."
        },
        {
            "heading": "5.2 IPA analysis",
            "text": "The IPA analysis is an iterative process to modify the operations of an application in order to guarantee that application invariants are preserved when operations execute concurrently.\nAlgorithm 1 presents the algorithm for executing the IPA analysis. The analysis builds on two main components: (i) conflict detection, for identifying pairs of operations that may cause an invariant violation; and (ii) conflict repair, for finding a modification to a pair of conflicting operations that makes them invariant-preserving.\nThe main function (line 1) has three parameters: (1) the invariant, I , which is a single expression that connects all invariants with a conjunction operator; (2) the set of operations, Ops , with all operations defined in the application; and (3) the initial conflict-resolution policies for the predicates, CR, as defined by the programmer. The function consists of a loop that finds pairs of conflicting operations and a repair for each conflict. The repair consists of an extended version of the operations, which replaces the original ones, and appropriate conflict resolution policies for predicates. The loop continues until no more conflicting operations exist.\nNext, we detail the main components of the analysis. For simplicity, our presentation omits some details. First, it ignores the situation when no repair can be found, which is discussed in Section 5.5. Second, the algorithm only handles boolean predicates. We discuss numerical invariants and compensations in Section 5.3.\n5.2.1 Conflict detection The conflict detection algorithm finds a pair of operations that, when executed concurrently, may break the application invariants. To this end, it considers all pairs of operations in the specification (checking conflicts pairwise is sound, as shown independently by Gotsman [29] and Balegas [48]).\nFor each pair, the algorithm first checks if the operations have opposing effects (line 8), i.e., if one sets a predicate to true while the other sets the same predicate to false, as when add tourn(t) and rem tourn(t) execute concurrently. For each opposing effect, the algorithm uses the rule specified in CR to set the value of the predicate in the operations (line 9). If no rule exists for the predicate, the programmer is asked which rule should be used (Add-wins or Rem-wins), and the updated CR rules are returned by the function.\nFor checking if the concurrent execution of both operations may break an invariant, it is necessary to consider their concurrent execution in all valid states. If any resulting state does not respect I , then the operations conflict. To search for an invalid execution efficiently, we rely on an SMT solver (line 10), which uses several optimizations and heuristics to avoid testing all cases exhaustively.\nFigure 3a exemplifies the conflict detection procedure for two operations, rem tourn(t) and enroll(p, t). To select the states to be checked, the SMT solver determines, from the invariants, the weakest precondition for executing both operations. In this case, it is necessary that tournament(t) and player(p) are set to true.\nAlgorithm 1 IPA algorithm and main functions. . IPA main loop.\n1: function IPA(I , Ops , CR) 2: while existsConflictingPair(I , Ops , CR) do 3: opPair \u2190 findConflictingPair(I , Ops , CR) 4: (newPair ,CR)\u2190 repairConflicts(I , opPair , CR) 5: Ops .replace(opPair , newPair ) 6: return (Ops ,CR)\n. Checks if a pair is conflicting. [invoked in line 17] 7: function ISCONFLICTING(I , OpPair , CR) 8: if opposingEffects(OpPair ) then 9: (OpPair , CR)\u2190 apply(OpPair , CR)\n10: return (SMTCheckConflicting(I , OpPair ), CR) . IPA algorithm for repairing conflicts. [invoked in line 4] 11: function REPAIRCONFLICTS(I , OpPair , CR) 12: sols \u2190 \u2205 13: invPreds \u2190 {getPreds(i) | i \u2208 invClauses(I , opPair )} 14: newOpPairsList \u2190 generate(invPreds, I ,OpPair ) 15: for newOpPair \u2208 newOpPairsList do 16: if not isPairSubset(newOpPair , sols) then 17: (result,newCR)\u2190 isConflicting(I ,newOpPair ,CR) 18: if result == FALSE then 19: sols\u2190 sols \u222a {(newOpPair , newCR)} 20: return USERPickResolution(sols)\n. New operation generation. [invoked in line 14] 21: function GENERATE(invPreds , I , (op1 , op2 )) 22: seed \u2190 {p(true), p(false) | p \u2208 invPreds} 23: effectSets\u2190 powerSetFiltered(seed) 24: pairs \u2190 \u2205 25: for p \u2208 effectSets do 26: pairs \u2190 pairs \u222a {(newOp(op1 , p),op2 )} 27: pairs \u2190 pairs \u222a {(op1 ,newOp(op2 , p)} 28: return order(pairs) . by increasing no. of predicates.\nThe SMT solver then checks if, for every state in which the weakest preconditions hold, the concurrent execution of both operations produces a valid state. In our example, executing rem tourn(t) and enroll(p, t) individually at some Sinit in which tournament(t) and player(p) are set to true, generates S1 and S2 respectively, which are valid states. However, when we combine the effects of both operations, the resulting state violates the invariant that a player must be enrolled in an existing tournament (line 2, Figure 2).\n5.2.2 Conflict repair The conflict repair algorithm (function repairConflicts, line 11)\ntakes two conflicting operations and tries to find modifications to the operations and conflict resolution rules that guarantee the invariants are preserved when these operations execute concurrently.\nThe algorithm starts by creating a pool of predicates to add to the operations to avoid the conflict. To this end, the invariant clauses that might be involved in the conflict are identified, based on the effects of the conflicting operations. The predicates involved in these clauses are the predicates that will be used to try to avoid the conflict (line 13).\nThe next step is to generate the modified versions of the conflicting operations by using the identified predicates (line 14). The generate function (line 21) computes all possible combinations of new effects to add to the operations, by using the powerset of the previously identified predicates (in invPreds), filtered so that in each set a predicate has only the value true or false (line 23). The function returns all pairs of operations extending the original operations with the new effects, ignoring, in each new operation, any predicate that is already present in the operation. The modified pairs are ordered by the number of predicates in each operation (line 28) to ensure that the algorithm analyses operations with fewer predicates first.\nFor each generated pair of operations, the algorithm checks if the effects of the modified operations are not a subset of any previously found solution, i.e., if there is a solution with fewer additional effects that solves the conflict (line 16). If that is the case, the pair is ignored. Otherwise, the algorithm checks if the new pair is nonconflicting (line 17) \u2013 this might require automatically assigning a new conflict resolution policy to a predicate that has no assigned policy yet (if a policy already exists, it is not modified). If the new pair is non-conflicting, it is added to the set of solutions (line 19).\nFinally, the set of solutions is presented to the programmer, who must select the most appropriate one for the application (line 20).\n5.2.3 Running the IPA analysis: an example To exemplify how the IPA analysis works, we consider three\noperations: enroll(p, t), rem tourn(t), and rem player(p). In the first iteration, the conflict detection procedure finds a pair of operations that conflict. Consider that this returns the pair \u3008enroll(p, t),rem tourn(t)\u3009. In this case, the invariant violated by these operations is I = enrolled(p, t)\u21d2 player(p) \u2227 tournament(t). The pool of predicates for generating new operations is {enrolled(p, t), player(p), tournament(t)}. The analysis creates new operations by considering the powerset of those effects. While computing the powerset has exponential complexity, the degree is usually small as the predicate pool is restricted to the predicates of the invariant clause impacted by the conflict.\nWith an initially empty value for the CR set, the following repair actions are possible. The first repair (Figure 3b) consists of extending the enroll(p, t) operation by setting the predicate tournament(t) to true and using the conflict resolution policy (tournament,Add-wins). When the two operations execute concurrently, an opposing effect occurs for predicate tournament(t). With Add-wins for tournament, the resulting value for the predicate is true, leading to a state that contains tournament t, which is compliant with invariant I . Setting tournament(t) to true in operation enroll(p, t) produces no observable effect because one of the preconditions of the operation is that the value of that predicate is true, therefore the effect can be executed preventively. We note that choosing this repair will influence also the result of a concurrent add tourn(t) and rem tourn(t) \u2013 the Add-wins policy will guarantee that the tournament exists in that case. Also, this repair would not be possible if the initial conflict resolution policies included (tournament,Rem-wins).\nThe second repair (Figure 3c) consists of extending rem tourn(t) to force the disenrollment of every player from tournament t and using the conflict resolution policy (enrolled,Rem-wins). Since it is impossible to infer the identifier of the player that might enroll in t, we use a wildcard for the parameter p, enrolled(\u2217, t) = false, as shown in Figure 3c. (We show in Section 6.2 how to implement this predicate efficiently.) This additional effect is also not observable in a sequential execution, and therefore can be applied preventively.\nAfter both solutions are presented to the programmer, he or she selects one of them, and the loop proceeds to find another conflicting pair. The conflict detection step now returns the pair (enroll(p, t), rem player(p)). The same invariant as before is violated, leading to the same pool of predicates for generating new operations.\nAgain, independently of the resolution selected for the first conflicting pair, two repairs are possible (as the conflict resolution policies do not restrict them). The first repair consists of extending the enroll(p, t) operation by setting the predicate player(p) to true and using the conflict resolution policy (player,Add-wins). The second repair consists of extending the rem player(p) to force the disenrollment of the player p in every tournament and using the conflict resolution policy (enrolled,Rem-wins).\nAlthough the most logical solution would appear to be selecting the first or second repair in both cases, it is important to note that any other combination also preserves the invariants. E.g., the programmer might decide that in case of a conflict between enroll(p, t) and rem tourn(t), the enroll will win, thus restoring the tournament (first repair), whereas in a conflict between enroll(p, t) and rem player(p), the removal of the player will win, leading to the disenrollment of the player in all tournaments (second repair).\nA complete analysis is provided in a technical report [15].\n5.2.4 Correctness of referential integrity maintenance We now show that the IPA approach preserves the referential\nintegrity invariant on a generic relational database. Consider the following definition of referential integrity: I = \u2200xi \u2208 X, \u2203yi \u2208 Y : xi.r = v \u21d2 yi.s = v, which says that for every row of table X that has value v for column r, there must be a row in table Y with value v for column s.\nWithout loss of generality, we consider the case where table Y has a single column and table X has two columns, where the second one refers to a row in table Y . Operation Cx creates a new row (x, y) in a table X , if and only if there is a row in table Y with value y. Operation Dy deletes row (y) in table Y , if and only if there is no row in table X , where the second column has the value y.\nLet SCD be the set of admissible states where the preconditions of both Cx and Dy hold. Consider the state s where table X is empty and table Y contains a single row with value (y). State s is an admissible state for both Cx and Dy and thus it is possible to concurrently execute Cx and Dy . However, as I(Cx(Dy(s))) = false , the set of operations {Cx, Dy} is not I-Confluent.\nNow consider the modified operation C\u2032x with the same effects as the original operation, plus an additional effect to touch every row (y) of table Y . Further consider the use of Add-wins for table Y , where deletion of a row loses when executed concurrently with an insert or touch. With these modifications in place, the set of operations O = {C\u2032x, Dy} is now I-Confluent. To prove that, we are going to show that I holds for every possible execution of operations in O, even if we extend O with other operations that might affect I .\nWe note that C\u2032x can only execute initially in states where a row (y) exists in table Y . In these states, the concurrent execution of C\u2032x and any number of Dy operations always leads to a state where row (y) is present in table Y , since the use of Add-wins semantics for table Y guarantees that the touch of (y) in C\u2032x masks the deletion of (y) in Dy . This guarantees that the invariant I holds for O.\nThe invariant I continues to hold for the row added by C\u2032x even if more operations are added to O. Since Add-wins semantics are used for table Y , row (y) remains in table Y when C\u2032x is executed concurrently with any other operation, thus guaranteeing that referential integrity is maintained."
        },
        {
            "heading": "5.3 Numerical invariants",
            "text": "Numerical invariants are more difficult to maintain by modifying operations. For example, consider the invariant in line 4 of Figure 2, which defines a maximum capacity for a tournament. When the current number of enrolled players is Capacity \u2212 1, two concurrent enrolls with different players lead to an invariant violation. To avoid this problem, a possible preventive modification is to disenroll some enrolled player when executing an enroll(p, t). (To be correct, different enrolls additionally need to disenroll different players.) Obviously, this is not reasonable in this application.\nTo circumvent this issue, we provide support for compensations [27, 42, 50]. With compensations, the idea is to check that the precondition holds when executing the operation in the initial replica, and to check that the invariants hold when operations are integrated remotely or when the state is read. Implementations of compensation mechanisms typically require re-executing operations multiple times, or using a leader to order operations [50], to ensure that replicas converge after applying a compensation. We implement compensations without any of these limitations by relying on CRDT convergence rules.\n5.3.1 Extending the analysis To generate a compensation, instead of modifying the existing\noperations, the algorithm flags those operations as conflicting and generates a new operation with the additional effects to be executed when a conflict is detected. Since the new operation may conflict with other pre-existing operations, the analysis must check the execution of this operation against other operations.\nThe analysis can detect numerical invariant violations that involve comparison operations and arithmetic operators between multiple predicates. For example, an invariant Stock(x) \u2265 0 can be used to state that the stock of a product must be non-negative and the invariant CheckAccount(x) + Savings(x) \u2265 0 to specify that the overall balance of a client in a bank must be non-negative.\nAfter detecting a conflict, the analysis suggests effects to repair the conflict. For instance, after identifying a conflict that violates the invariant of line 4, the compensation simply says that the value of that predicate must be decreased, i.e., that the number of players enrolled must decrease. It is up to the programmer to decide how to implement such compensation. In our example, a possible compensation is to disenroll the player and send him a notification.\nThe logic of compensations is application-dependent. Our tool identifies invariant violations to be fixed using compensations and lets the programmer decide how to fix the violation.\n5.3.2 Extending applications Replicas might detect the invariant violation at any time by in-\nspecting the local state and applying a compensation without coordinating with other replicas. The compensation operation is replicated, as any other operation, thus guaranteeing that all replicas converge to the same state. We explain how this works with an example.\nConsider the invariant violation of exceeding the maximum number of allowed players in a tournament. When a violation is detected, some player will have to be disenrolled from the tournament. To fix this violation, the analysis suggests that the programmer decreases the number of players enrolled in the tournament.\nReanalyzing the new specification with this compensation raises new conflicts in the application. The compensation operation conflicts with operation do match(), as the players in a match must be part of the tournament. Therefore, the compensation must also cancel any match of the player that will be disenrolled. It is up to the programmer to decide which additional effects have to be applied as a consequence of the compensation (e.g., notify the player).\nIf multiple replicas concurrently detect the invariant violation, they might independently apply the compensation code. As a consequence, different players might be disenrolled in different replicas. In any case, as the effects of the compensation operations are propagated to all replicas, the system converges to a state where invariants are valid. The downside is that we might remove more players from the tournament than necessary. In our application, we use a deterministic rule to decide which player to disenroll to increase the likelihood of disenrolling the same player in all replicas."
        },
        {
            "heading": "5.4 Code modification",
            "text": "After the IPA analysis returns the new specification of the application, the programmer must apply the proposed changes to the code of the application. In our prototype, the programmer is responsible for ensuring that the modified code follows the new specification, although code checking techniques could be used to ensure that the code matches the specification [26].\nFigure 4 shows an excerpt of the code necessary to modify the tournament application in our prototype.\nThe first aspect to consider is how to store information and how to implement the conflict resolution policies. In our prototype, each predicate is represented with one or more set CRDTs: predicates player(p) and tournament(t) are represented by a set, where each element is a member of that set; predicate enrolled(p, t) is represented by a set for each tournament t and each element p is a member of that set. Setting a predicate to true corresponds to adding that element to the set and setting it to false removes it. The set CRDT used for each predicate depends on the conflict resolution policy in the new specification of the application.\nIn our prototype, using a given conflict resolution policy for a predicate is achieved by using the appropriate CRDT \u2013 in function ensureEnroll (line 1), the Add-wins set CRDT is used for both predicates player(p) and tournament(t).\nThe second aspect to consider is how to modify the original operations for implementing the new specification, with the additional effects. Instead of adding the code to the original functions, we used auxiliary functions that execute the additional effects and are called by the original operation. For example, function ensureEnroll is used to extend the enroll operation to guarantee that player p\nand tournament t are not concurrently removed (this corresponds to the first repair for both conflicts in the example of Section 5.2). The code simply uses the touch operation in the CRDTs for both players and tournaments, in combination with the Add-wins policy, to guarantee that player p and tournament t are not removed.\nWhen using compensations, it is necessary to write a compensation function that runs if the invariant violation is detected at runtime. Function compensateEnrolled (line 7) shows the code for compensating an enroll when it is found that the capacity of the tournament has been exceeded. Besides canceling the enrollment (line 10), it is necessary to cancel any match that involves the player, both the matches that are already known at the replica (line 11) and those that might have been created concurrently (line 12)."
        },
        {
            "heading": "5.5 Limitations",
            "text": "No repair found. A limitation of our approach is that the algorithm might not find any valid solution for a conflict between two operations, due to some previous decision by the programmer. Consider, e.g., an application with four predicates, A, B , C and D , connected by the following invariant A\u21d2 B \u21d2 C \u21d2 D . For each predicate there are two operations defined, one that makes the predicate true (e.g., At) and another that makes it false (e.g., Af ) .\nWhen running the IPA analysis for solving the conflict between operations Ct and Df , the programmer may decide to repair the conflict by setting both predicates to false. To this end, operation Df is extended to make C = false, and the conflict resolution policy for C is Rem-wins.\nNext, the conflict detection may identify the conflict between operations At and Bf . If the programmer decides to solve the conflict by making both predicates true, operation At is extended with B = true and the conflict resolution policy for B is Add-wins.\nThe extended operation At now conflicts with operation Cf . However, there is no solution for solving this conflict. First, it is impossible to make predicates A, B and C true, as the conflict resolution for C is Rem-wins. Second, it is impossible to extend operation Cf to make the predicate B false, as the conflict resolution for B is Add-wins.\nIn such cases, our tool checks if it would have been possible to solve the conflict by considering only the conflict resolution policies initially established by the programmer. If such a solution exists, it is presented to the programmer. If the programmer wants to use such a solution, because it makes sense for the semantics of the application being developed, he or she must run the analysis again, and use its output to make different decisions on the alternative repairs that are proposed. Otherwise, the pair is flagged as unsolvable and the algorithm continues, ignoring that pair in subsequent iterations. In that case, the execution of those operations must be controlled using an alternative mechanism [14, 37]. Supporting multiple applications and application evolution. Our approach can support multiple applications accessing the same database if the programmer provides a complete specification for all applications that use the database.\nFor a running system, one can consider several scenarios of evolution: add new operations to an application; add new invariants to the database; add a new application that accesses the same database. In all cases, it is necessary to execute the IPA analysis again. If the operations and conflict resolution rules used in the original system remain unchanged, it is possible to evolve the system without having to stop it. Otherwise, it is necessary to stop the system.\nA possible approach to tackle the system evolution more easily is to consider that, for every predicate defined in the system, there exists an operation to make the predicate true and an operation to make it false, even if those operations do not exist in the current\napplication. Considering these operations, the IPA analysis will identify conflicts between the operations that exist in the application and these additional operations, and proposes alternative repairs to the programmer. With this approach, when evolving the system, if the database does not change and no additional invariant is added, as it is often the case when supporting a new application that uses the same database, the original operations will remain unchanged (as they already prevent any conflict that may occur). This approach has two main disadvantages. First, the operation may include additional effects that are of no use in the current application (as the conflicts they are solving do not occur). Second, the programmer may decide to use a repair approach that is not appropriate for the new operations, making this effort useless. Specification effort. The effort of writing specifications is arguably comparable to the effort of writing the code itself [43]. We do not address this problem in this work. Previous research attempted to address this problem, proposing automatic feature extraction and code synthesis to aid the programmer in writing correct applications [44, 36, 24, 25, 7]. Our approach could benefit from these complementary research efforts, not only for extracting the specification of the application from the code but also for making sure that the code of the modified version of the application matches the specification output by the IPA analysis."
        },
        {
            "heading": "6. IMPLEMENTATION",
            "text": "This section briefly describes the IPA prototype."
        },
        {
            "heading": "6.1 IPA tool and database support",
            "text": "The IPA tool assists programmers to write invariant preserving applications. The tool receives as input an annotated Java interface with the operations and the invariants, as in the example of Figure 2, and an initial set of convergence rules. The tool runs the static analysis algorithm and outputs the modified specification of operations and auxiliary compensations, the conflict resolution rules for each predicate, and the set of unresolved conflicting pairs.\nThe tool uses the Z3 SMT solver [21] to identify conflicting operations and propose modifications to operations. Boolean satisfiability is an NP-Complete problem, but modern SMT solvers can handle many instances of this problem efficiently, as shown by our performance evaluation. The algorithms and the tool are implemented using standard Java and the Java bindings for Z3.\nOur prototype was implemented in Java, using Switfcloud [57, 3] as the underlying storage system. SwiftCloud provides highly available transactions, causal consistency and per-object conflict resolution based on CRDTs, allowing to easily add new data types.\nWe implemented several applications for the evaluation, derived from the specifications generated by our analysis. We use set CRDTs for storing the data represented by the predicates."
        },
        {
            "heading": "6.2 New CRDT designs",
            "text": "We now discuss the CRDTs used for supporting the resolutions proposed by IPA. A detailed specification of the data types is available in a separate document [48].\n6.2.1 CRDTs with touch operations When a modification requires that some predicate value is set to true, we need to ensure that the element that we are restoring is equal to the one that was observed.\nTo this end, we extended the Add-wins set CRDT with a touch operation. This operation simply updates the meta-data for the element in the set, with a new timestamp as if the object was created at that moment. If a concurrent remove of the same element is executed, the Add-wins policy ensures that the element will survive.\nFurthermore, all information associated with the element is preserved \u2013 for example, for a tournament, the element includes not only a simple identifier but a record with multiple fields.\n6.2.2 Remove with Wildcards Some repairs require preventing the addition of any element that\nmatches some condition \u2013 e.g., in the example of Section 5.2, there is a repair requiring to make enrolled(\u2217, t) = false , for any player and a given tournament. To implement this effect using a standard Rem-wins set CRDT, it would be necessary to execute a remove for all elements that could be concurrently added.\nDoing this would be impractical because the set of possible elements is large. Instead, we created CRDTs that support wildcard values for the remove operation. For instance, the wildcard \u201c*\u201d represents all possible elements in the domain.\n6.2.3 Compensation CRDTs For some invariants, it is possible to encapsulate the logic for\ndetecting conflicts and applying the compensations automatically. Consider the invariant #enrolled(p, t) \u2264 Capacity . We use a set to store the information about players enrolled in a tournament. To ensure that the application is always consistent, whenever the application accesses the set, the object automatically verifies if its state is consistent, and applies the compensation if necessary.\nWe implemented Limited Size Set CRDTs that allow the programmer to define the constraint that must be maintained, and the compensation to execute when the constraint is violated. Whenever the object is read, the code is executed automatically, ensuring that any observed state is consistent. The effects of the compensation, in case it is executed, are committed in the enclosing transaction.\nTo select the elements to be removed in the compensation it is possible to leverage the history information of the set to remove the last elements added to the set. This does not prevent more elements than necessary from being removed, because the state of replicas might diverge, but it reduces the chance of that happening."
        },
        {
            "heading": "7. EVALUATION",
            "text": "Our evaluation intends to answer the following questions: (i) What classes of invariants and applications can be handled by our approach? (ii) What is the scalability of the static analysis process? (iii) How does the performance of modified applications compare to other solutions?"
        },
        {
            "heading": "7.1 Invariants covered by IPA",
            "text": "This section surveys the invariants covered by our approach.\n7.1.1 Classes of invariants Prior work has analyzed invariants used in real applications [10, 9,\n37]. Table 1 summarizes whether these invariants are I-Confluent [9] or can be made I-Confluent by using IPA.\nSequential identifiers: Sequential identifiers are useful to enforce a total order of elements. In general, generating these identifiers requires coordination to avoid collisions. No solution based on\nweak consistency can maintain this invariant. However, it has been shown that, in most cases, applications could easily replace the use of sequential identifiers by unique identifiers [8, 51].\nUnique identifiers: Unique identifiers can be preserved without coordination, and as such are I-Confluent. Unique identifiers do not provide a sequential order, but can still provide a total order of identifiers compatible with the happens-before relation.\nNumerical invariants: Numerical invariants assert conditions involving numerical predicates (e.g., p(x) < k). In general, preserving these invariants requires coordination. However, as it has been shown, it is possible to enforce some constraints on top of weak consistency by relying on escrow techniques [16, 32, 41]. IPA allows to maintain these invariants using compensations as long as the application is compatible with using this approach. In TPC-C/W we can use compensations to replenish the stock, for instance.\nAggregation constraint: Imposing a bound on the size of a collection, e.g., limiting the players enrolled in a tournament, can be addressed using a numerical invariant over a predicate that represents the size of the collection, thus sharing its properties.\nAggregation inclusion: Ensuring that an element is eventually added or removed from a collection is I-Confluent, provided no dependencies to other objects exist. If that is not the case, referential integrity might be required.\nReferential integrity: Preserving relations and dependencies among objects, such as foreign keys in relational databases and references to keys in key-value stores, is not I-Confluent. IPA fully supports this invariant, as exemplified throughout the paper.\nDisjunctions: Applications often specify that one of several conditions must be met by using a disjunction. IPA can address this type of invariant by extending an operation to ensure that the disjunction is always true. This is an extension of the mechanism for supporting referential integrity, as in this case there might be several alternative conditions that restore the validity of the invariant.\n7.1.2 Invariants in applications We now analyze how IPA can address the invariants of some\nselected applications (summarized in Table 1). These application are representative of general OLTP workloads.\nTournament: This application manages the information for an on-line game and showcases most of the invariants that our solution can address. It is based on an application used in prior work [29, 14] with a few new constraints. For this application, IPA is capable of proposing multiple alternative resolutions that either reconstruct broken dependencies, or clear them, to avoid inconsistencies due to concurrent executions, as discussed throughout this paper.\nTwitter: We implemented a simple Twitter clone that relies heavily on referential integrity to implement user timelines and maintain subscription information. When some user tweets, we write those tweets to the timelines of the followers. This leads to consistency issues when tweets and users are removed concurrently with tweeting. We implemented two versions, using the Add-wins and the Rem-wins policy to solve conflicts, respectively. For example, if a user tweets and his or her account is concurrently removed, for the Add-wins version the user and tweets are restored, whereas for Rem-wins the user and tweets are removed. Other conflicts are solved similarly.\nTicket: This application, based on FusionTicket [1, 32, 56], manages ticket reservations. The main invariant is that tickets for events cannot be oversold. We use the Limited Size Set CRDT to cancel a ticket sale and reimburse the customer when tickets are oversold. The transfer of money to the account of the customer crosses the boundaries of the system and therefore must use a different mechanism (e.g., a message queue).\nTPC-W and TPC-C: These standard database benchmarks overlook some aspects of real-world applications, such as having operations to manage product listings. In our specification, we extended these applications to include such operations, which introduced referential integrity constraints. To implement the inventory size threshold we used compensations to increase the stock (in accordance with the specification). An alternative would be to cancel the oversold purchases, as in the previous example.\n7.1.3 Summary The types of invariants we support (Table 1) are common in many\napplications, as previously shown [10]. The examples we discussed show that our language is expressive enough to address complex applications, including typical relational database applications."
        },
        {
            "heading": "7.2 Off-line analysis performance",
            "text": "We evaluate the scalability of the proposed approach, by analyzing the execution time of the IPA analysis as the size and complexity of the application increases using a micro-benchmark.\nTo vary the size of the application, we vary the number of predicates. For each predicate, there are two operations, one that makes the predicate true and another that makes the predicate false. Thus, for 10 predicates, we have 20 operations. For all predicates, we use the Add-wins conflict resolution policy.\nAll predicates belong to some invariant clause. To vary the complexity, we vary the number of predicates that are connected by invariants. For a chain size of one, the invariants defined connect only pairs of predicates: P1\u21d2P2, P3\u21d2P4, P5\u21d2P6, etc. For a chain size of two, the invariants connect groups of three predicates: P1 \u21d2 P2 and P2 \u21d2 P3, P4 \u21d2 P5 and P5 \u21d2 P6, etc. Increasing the size of the chain, increases both the number of clauses in the invariant and the average number of effects in each operation for a specification without conflicts \u2013 e.g., with a chain of size one, the operation that makes P1 true only needs to make P2 also true, while with a chain of size two it also needs to make P3 true.\nThe results were obtained in a laptop, running MacOS 10.13.6, with an Intel i7 2.8 GHz Quad-Core processor and 16GB of RAM.\n7.2.1 Conflict detection We start by evaluating the time to detect a conflict. The worst\ncase scenario is when the analysis finds the conflict in the last pair that is checked. To approximate this, we run our tool with a correct specification, so that the algorithm analyzes all pairs of operations. Figure 5 shows the execution time (in seconds) for different configurations of the benchmark, with different lines corresponding to increasing the number of operations in the chain.\nWe first observe that, as expected, the execution time of the algorithm grows quadratically, due to testing all pairs of operations. Second, we observe that the cost of testing all pairs dominates the cost of the algorithm, since changing the size of the chain does not impact the results significantly. The results show that the overall\nexecution time is reasonable for an offline process, as testing all combinations of pairs of 100 operations takes less than 100 seconds.\n7.2.2 Conflict repair Our second experiment evaluates the time to repair conflicts. To\nthis end, from a specification that is invariant-preserving, we have removed the additional effects that avoid conflicts in a single operation, selecting one of the operations with more additional effects (e.g., in the chain of size two, from the operation that makes P1 true, we removed the changes to P2 and P3). Figure 6 presents the sum of the time spent in proposing repairs until a correct solution is generated (this excludes the time to detect conflicts). As expected, when the chain is longer, our tool takes more time to find a correct solution, as it repairs the conflicts one at a time. Still, in our configurations, this time is low.\nThese results show that the running time of our tool is dominated by the time to detect conflicts and that this time is reasonable for an offline process, making our approach practical."
        },
        {
            "heading": "7.3 Runtime performance",
            "text": "In this section, we compare the performance of applications modified using our approach against alternative solutions.\n7.3.1 System configurations Our evaluation was performed in a geo-replicated setting on Ama-\nzon EC2. The database deployment consists of three servers running in three geographical regions (US-WEST, US-EAST and EU-IE). The table below shows the latency between each region.\nRTT (ms) US-East US-West US-West 81 \u2013 EU-IE 93 161\nThe application server is co-located with the storage system of each region. We use SwiftCloud to implement all different approaches that we evaluate. Clients are installed in other machines in the same availability zones as the corresponding closest servers.\nPerformance of applications is compared with the following alternative approaches:\nCausal Consistency (Causal): This configuration uses the original applications running with causal consistency, which does not maintain invariants for conflicting operations.\nStrong Consistency (Strong): All updates are forwarded to the US-EAST replica to enforce serialization. This minimizes the average latency for updates.\nInvariant violation avoidance (Indigo [14]): Applications modified to use the efficient coordination mechanisms proposed in Indigo [2] to prevent invariant violations. Conflicting operations need to acquire reservations to safely execute operations. Each set of conflicting operations coordinated using different reservations, and each reservation can be shared by multiple replicas, allowing a high level of concurrency.\nInvariant Preserving Applications (IPA): Applications are modified using our IPA approach, which maintains invariants without coordination, on top of Causal.\n7.3.2 Throughput and latency We evaluate the scalability of each configuration by measuring\nthe latency and throughput with different loads on the system, using the Tournament application. The workload comprises 35% of write operations, and the initial database contains 1000 players and 100 tournaments. All operations are conflicting in the original application. In the IPA modified version, all operations are I-Confluent\nusing a mix of conflict resolution policies. In Indigo, every pair of operations is protected by a different reservation.\nTo test the scalability of the system, we increase the number of clients contacting each server by running extra client threads until peak throughput is achieved.\nFigure 7 shows that Strong presents the highest average latency, which is a consequence of having 2\n3 of operations being forwarded\nto a remote server. Even if it would be possible to improve the scalability of our implementation, this figure highlights that even when contention is low, the average latency is already much higher than with weak consistency approaches. Causal shows the best scalability with the lowest latency. Our approach, IPA, performs slightly worse than Causal, as additional updates need to be executed to preserve application invariants. In the Causal version, concurrent updates may lead to invariant violation.\nWhen compared to Indigo, our approach performs slightly better. The reason for this is that updates in Indigo need to acquire reservations for coordinating the execution of concurrent updates, which is more costly than the additional updates in the IPA version. The advantage is small because reservations are exchanged among replicas infrequently after they are acquired. Additionally, as many reservations can be shared, they allow a high degree of concurrency.\nFigure 8 presents the latency for the write operations and highlights more clearly the differences between the configurations. We omit the Strong column. The average latency of operations in Indigo is higher than the latency for IPA or Causal and also exhibits a higher standard deviation. Both are explained by the occasional need for Indigo replicas to trade reservations. Compared to Causal, the latency of write operations is only slightly higher in IPA, which is due to the extra updates executed. We further study the overhead associated with executing extra effects in Section 7.3.5.\n7.3.3 Comparing different conflict resolution schemes We implemented Twitter using Add-wins and Rem-wins strategies\nto compare the costs of each approach. The initial database contains 1000 users, and 96% of the operations are writes.\nFigure 9 shows the latency of each operation for the different version. The Add-wins version has a higher latency for operations that create tweets (tweet and retweet). This overhead is due to the additional effect of touching the user, to ensure that when a user tweets, or retweets, he or she will not be removed concurrently.\nThe Rem-wins version has a higher latency for remove operations, due to the additional effects. The delete tweet operation needs to remove the tweet from all timelines that have the tweet. The remove user has a small overhead, as it only has to issue a remove with a wildcard in the followers and to set a compensation for removing tweets in the user object \u2013 when user u1 reads a timeline, the application checks, for each tweet, that its author, u2, was removed, triggering a compensation to remove the tweets from the timeline of u1 in this case. This also leads to a slight overhead in the read timeline operation.\n7.3.4 Scalability of compensations We evaluate the scalability of the compensation mechanism im-\nplemented in the Limited Size Set CRDT with the Ticket application, by increasing contention. The initial database has 500 flights and 10000 customers, and all operations in the workload read and update the database, with reads triggering the execution of compensations when a flight is overbooked.\nFigure 10 presents the performance with an increasing load. The red dots in the figure indicate the average number of invariant violations that were observed at that throughput, when using Causal. This confirms the intuition that as contention rises, the divergence\nwindow grows larger, increasing the chance for invariant violation. In Causal, this exposes the application to consistency anomalies, while in IPA executing compensations preserves invariants at all times. As expected, compensations incur on some overhead, but still provide latency comparable to Causal.\n7.3.5 Microbenchmarks IPA avoids invariant violations by executing extra updates in\none or more objects. In this section, we evaluate the overhead of adding additional effects to operations. We analyze the impact of executing increasingly more updates in comparison to the costs of executing the original operation in strong consistency and Indigo. These microbenchmark use a Set CRDT to store information.\nOperations on a single object: We measure the speedup of an application modified with IPA versus the original operation running on Strong. Figure 11 (top) shows that the original operation is about 28\u00d7 faster in IPA than in Strong. Adding more updates to this operation makes the speedup decrease. When we execute 2048 updates to a single object, the average latency is still about 40ms.\nOperations over multiple objects: Executing updates on a single object imposes a low overhead on the system, because the object is read and written to storage only once and subsequent updates only impose processing costs. Now we evaluate the overhead when the additional effects of modified operations update multiple objects.\nThe original application reads a varying number of objects to check some condition and then executes a single write operation to an object. The modified application checks the same condition, but executes a write for each object. Figure 11 (bottom) shows performance dropping faster than when executing updates over single objects. At 64 objects, it starts to pay off to switch to Strong.\nIn practice, in the evaluated applications, we require only a few extra updates per object over a small number of objects. In Twitter, which needs to execute more writes due to our implementation of the timeline, we were able to execute them lazily via compensations.\nComparison with Indigo: In Indigo [14], operations might execute locally if the replica holds some specific reservation. Multiple operations might be able to execute concurrently at different replicas if all of them can share the same reservation. If a replica requires some reservation that is being used exclusively, the replica must request remote replicas to release the reservation, before acquiring it. This approach only avoids coordination when a replica holds the necessary reservations to execute the operation. Thus, the latency of an application depends on the contention for obtaining reservations.\nIn this experiment, we evaluate the impact of varying the percentage of operations that compete to acquire opposing reservations. We compare the performance of this solution against executing the same operation in IPA. Figure 12 shows that the performance of IPA is equivalent to Indigo with no contention for reservations, and that the latency of Indigo rises steadily as contention increases.\nDespite the overhead for executing the additional effects, IPA provides a predictable latency of operations, which is not the case for Indigo, whose operations latency depend on the current distribution of reservations. Furthermore, our approach is fault-tolerant as a client can execute operations as long as it can access a single server. In Indigo, if a server that holds the reservation needed to execute some operation becomes unavailable, the operation cannot execute."
        },
        {
            "heading": "8. RELATED WORK",
            "text": "Achieving low latency, high availability and data consistency in distributed systems is difficult, as postulated in the CAP theorem [28]. In recent years, researchers and practitioners have studied the trade-offs in distributed systems to provide the best consistency guarantees for different types of applications [20, 22, 39, 8, 37, 14].\nSystems that ensure strong consistency [20, 58, 23, 33] require coordination across replicas, which is expensive in geo-replicated scenarios. In Megastore [13], data is partitioned at a fine granularity to achieve low latency, while MDCC [33] exploits commutativity and protocol optimizations to improve performance. Spanner [20] and Farm [23] harness custom hardware to improve performance.\nSystems that use weak consistency are widely deployed in the real-world [47, 34], but can be difficult to use [10]. Many systems provide causal consistency coupled with object convergence and transactions [39, 57, 40, 8], which all can be implemented efficiently without hindering the availability of the system.\nConvergent data types [45] provide automatic replica convergence, which lessens the programming effort in these systems. However, data type convergence alone cannot prevent invariant violations involving multiple objects. To mitigate the problem, RedBlue [37] and Walter [49] provide support for executing operations under weak or strong consistency to allow fast operations when invariants are not at risk, and consistent operations otherwise. Sieve [36] and Blazes [7] address the problem of automating the use of the most appropriate consistency alternative, while Indigo [14], Olisipo [38], Lucy [54], and the Homeostasis protocol [44] try to minimize the use of the strong consistency path. Despite improving the latency of operations in the general case, systems that depend on coordination to execute some operations may still become unavailable and exhibit high latency. IPA completely avoids the drawbacks of coordination, while being able to preserve a wide range of invariants.\nHelland and Campbell have suggested that applications should handle invariant violations as part of the application logic, as an alternative to executing operations under strong consistency to prevent violations [31]. The idea of compensations [27] is to execute operations optimistically and explicitly rollback the effects when conflicts are detected. A few systems have explored this model. In PLANET [42], transactions execute speculatively, allowing the system to provide the control back to the client before the transaction commit confirmation arrives. In Bayou [50], transactions commit\nlocally and remain in a tentative state, until all replicas agree on the ordering of operations. Existing systems that use compensations still use some form of coordination to commit transactions. Our approach departs from this model by modifying the operations to ensure they can always commit locally, while preserving invariants. We show that our approach does not modify the semantics of operations when no conflicting concurrent operations execute.\nRecent papers focused on proving correctness of distributed systems [30, 55]. These proposals complement ours, as they focus on attesting if implementations conform to some specification, whereas we aim to provide a methodology for implementing correct applications on top of the assumptions of our chosen consistency model."
        },
        {
            "heading": "9. CONCLUSION",
            "text": "In this paper, we proposed a novel approach for supporting correct and highly available applications on top of weak consistency. By extending operations with additional effects, we can ensure invariant preservation at all times with sensible semantics. Our IPA analysis and tool assist the programmer via static analysis to identify which operations might lead to an invariant violation, when executed concurrently, and by suggesting modifications to the operations.\nOur experimental evaluation shows that the static analysis can handle large applications in reasonable time for an offline process, and that the modified applications have similar performance to their unmodified counterparts that do not preserve invariants."
        },
        {
            "heading": "Acknowledgments",
            "text": "We thank the anonymous reviewers for their comments that helped improving the paper. This work was partially supported by EU H2020 LightKone project (732505), and FCT/MCTES grants SFRH/ BD/87540/2012, UID/CEC/04516/2013, UID/CEC/50021/2013, Lisboa-01-0145-FEDER-032662 /PTDC/CCI-INF/32662/2017, and PTDC/CCI-INF/32081/2017. Computing resources were provided by an Amazon Web Services (AWS) in Education Research Grant."
        },
        {
            "heading": "10. REFERENCES",
            "text": "[1] Fusion Ticket. http://www.fusionticket.org/.\nAccessed May-2018. [2] Indigo source code.\nhttps://github.com/SyncFree/Indigo. Accessed May-2018.\n[3] SwiftCloud source code. https://github.com/SyncFree/SwiftCloud. Accessed May-2018.\n[4] Akka. Distributed Data. https://doc.akka.io/docs/ akka/current/distributed-data.html. Accessed May-2018.\n[5] D. D. Akkoorath, A. Z. Tomsic, M. Bravo, Z. Li, T. Crain, A. Bieniusa, N. Preguic\u0327a, and M. Shapiro. Cure: Strong semantics meets high availability and low latency. In Proceedings of the 36th IEEE International Conference on Distributed Computing Systems (ICDCS 2016), pages 405\u2013414, Nara, Japan, June 2016.\n[6] S. Almeida, J. Leita\u0303o, and L. Rodrigues. ChainReaction: A Causal+ Consistent Datastore Based on Chain Replication. In Proceedings 8th ACM European Conference on Computer Systems, EuroSys \u201913, pages 85\u201398, Prague, Czech Republic, 2013. ACM.\n[7] P. Alvaro, N. Conway, J. M. Hellerstein, and D. Maier. Blazes: Coordination analysis for distributed programs. In Proceedings of the IEEE 30th International Conference on Data Engineering March 31 - April 4, 2014, pages 52\u201363, Chicago, Illinois, USA, Apr. 2014.\n[8] P. Bailis, A. Davidson, A. Fekete, A. Ghodsi, J. M. Hellerstein, and I. Stoica. Highly available transactions: Virtues and limitations. PVLDB, 7(3):181\u2013192, 2013.\n[9] P. Bailis, A. Fekete, M. J. Franklin, A. Ghodsi, J. M. Hellerstein, and I. Stoica. Coordination avoidance in database systems. PVLDB, 8(3):185\u2013196, 2014.\n[10] P. Bailis, A. Fekete, M. J. Franklin, A. Ghodsi, J. M. Hellerstein, and I. Stoica. Feral Concurrency Control: An Empirical Investigation of Modern Application Integrity. In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201915, pages 1327\u20131342, Melbourne, Victoria, Australia, 2015. ACM.\n[11] P. Bailis, A. Fekete, J. M. Hellerstein, A. Ghodsi, and I. Stoica. Scalable Atomic Visibility with RAMP Transactions. In Proceedings 2014 ACM SIGMOD Conference Conference on Management of Data, SIGMOD \u201914, pages 27\u201338, New York, NY, USA, 2014. ACM.\n[12] P. Bailis, A. Ghodsi, J. M. Hellerstein, and I. Stoica. Bolt-on Causal Consistency. In Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201913, pages 761\u2013772, New York, New York, USA, 2013. ACM.\n[13] J. Baker, C. Bond, J. C. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. Megastore: Providing Scalable, Highly Available Storage for Interactive Services. In Proceedings of the Conference on Innovative Data system Research (CIDR), pages 223\u2013234, 2011.\n[14] V. Balegas, S. Duarte, C. Ferreira, R. Rodrigues, N. Preguic\u0327a, M. Najafzadeh, and M. Shapiro. Putting Consistency Back into Eventual Consistency. In Proceedings of the Tenth European Conference on Computer Systems, EuroSys \u201915, pages 6:1\u20136:16, Bordeaux, France, 2015. ACM. [15] V. Balegas, N. Preguic\u0327a, S. Duarte, C. Ferreira, and\nR. Rodrigues. IPA: Invariant-preserving Applications for Weakly-consistent Replicated Databases. CoRR, abs/1802.08474, 2018.\n[16] V. Balegas, D. Serra, S. Duarte, C. Ferreira, M. Shapiro, R. Rodrigues, and N. Preguic\u0327a. Extending Eventually Consistent Cloud Databases for Enforcing Numeric Invariants. In Proceedings of the 34th IEEE Symposium on Reliable Distributed Systems (SRDS), pages 31\u201336, Montreal, Canada, Sept 2015.\n[17] Basho. Riak. http://basho.com/, 2017. Accessed May-2018.\n[18] C. Biyikoglu. Under the Hood: Redis CRDTs. https://goo.gl/tGqU7h. Accessed May-2018.\n[19] N. Conway, W. R. Marczak, P. Alvaro, J. M. Hellerstein, and D. Maier. Logic and Lattices for Distributed Programming. In Proceedings of the 3rd ACM Symposium on Cloud Computing, SoCC \u201912, pages 1:1\u20131:14, San Jose, California, 2012. ACM.\n[20] J. C. Corbett, J. Dean, M. Epstein, A. Fikes, C. Frost, J. J. Furman, S. Ghemawat, A. Gubarev, C. Heiser, P. Hochschild, W. Hsieh, S. Kanthak, E. Kogan, H. Li, A. Lloyd, S. Melnik, D. Mwaura, D. Nagle, S. Quinlan, R. Rao, L. Rolig, Y. Saito, M. Szymaniak, C. Taylor, R. Wang, and D. Woodford. Spanner: Google\u2019s Globally-distributed Database. In Proceedings 10th USENIX Conference on Operating Systems Design and Implementation, OSDI\u201912, pages 251\u2013264, Hollywood, USA, 2012. USENIX Association.\n[21] L. De Moura and N. Bj\u00f8rner. Z3: An Efficient SMT Solver. In Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS\u201908/ETAPS\u201908, pages 337\u2013340. Springer-Verlag, Budapest, Hungary, 2008.\n[22] G. DeCandia, D. Hastorun, M. Jampani, G. Kakulapati, A. Lakshman, A. Pilchin, S. Sivasubramanian, P. Vosshall, and W. Vogels. Dynamo: Amazon\u2019s Highly Available Key-value Store. In Proceedings of the 21st ACM SIGOPS Symposium on Operating Systems Principles, SOSP \u201907, pages 205\u2013220, Stevenson, Washington, USA, 2007. ACM.\n[23] A. Dragojevic\u0301, D. Narayanan, E. B. Nightingale, M. Renzelmann, A. Shamis, A. Badam, and M. Castro. No Compromises: Distributed Transactions with Consistency, Availability, and Performance. In Proceedings of the 25th Symposium on Operating Systems Principles, SOSP \u201915, pages 54\u201370, Monterey, California, 2015. ACM.\n[24] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant, C. Pacheco, M. S. Tschantz, and C. Xiao. The Daikon System for Dynamic Detection of Likely Invariants. Science of Computer Programming, 69(1-3):35\u201345, Dec. 2007.\n[25] C. Flanagan and K. R. M. Leino. Houdini, an Annotation Assistant for ESC/Java. In Proceedings of the International Symposium of Formal Methods Europe on Formal Methods for Increasing Software Productivity, FME \u201901, pages 500\u2013517, Berlin, Germany, 2001. Springer-Verlag.\n[26] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended Static Checking for Java. In Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, PLDI \u201902, pages 234\u2013245, Berlin, Germany, 2002. ACM.\n[27] H. Garcia-Molina and K. Salem. Sagas. In Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201987, pages 249\u2013259, San Francisco, USA, 1987. ACM.\n[28] S. Gilbert and N. Lynch. Brewer\u2019s Conjecture and the\nFeasibility of Consistent, Available, Partition-tolerant Web Services. SIGACT News, 33(2):51\u201359, June 2002.\n[29] A. Gotsman, H. Yang, C. Ferreira, M. Najafzadeh, and M. Shapiro. \u2019Cause I\u2019m Strong Enough: Reasoning About Consistency Choices in Distributed Systems. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL \u201916, pages 371\u2013384, St. Petersburg, USA, 2016. ACM.\n[30] C. Hawblitzel, J. Howell, M. Kapritsos, J. R. Lorch, B. Parno, M. L. Roberts, S. Setty, and B. Zill. IronFleet: Proving Practical Distributed Systems Correct. In Proceedings of the 25th Symposium on Operating Systems Principles, SOSP \u201915, pages 1\u201317, Monterey, USA, 2015. ACM.\n[31] P. Helland and D. Campbell. Building on quicksand. In Online Proceedings of CIDR 2009 Fourth Biennial Conference on Innovative Data Systems Research, Asilomar, USA, Jan. 2009.\n[32] B. Holt, J. Bornholt, I. Zhang, D. Ports, M. Oskin, and L. Ceze. Disciplined Inconsistency with Consistency Types. In Proceedings of the 7th ACM Symposium on Cloud Computing, SoCC \u201916, pages 279\u2013293, Santa Clara, USA, 2016. ACM.\n[33] T. Kraska, G. Pang, M. J. Franklin, S. Madden, and A. Fekete. MDCC: Multi-data Center Consistency. In Proceedings 8th ACM European Conference on Computer Systems, EuroSys \u201913, pages 113\u2013126, Prague, Czech Republic, 2013. ACM.\n[34] A. Lakshman and P. Malik. Cassandra: A Decentralized Structured Storage System. SIGOPS Oper. Syst. Rev., 44(2):35\u201340, Apr. 2010.\n[35] L. Lamport. Time, Clocks, and the Ordering of Events in a Distributed System. Communications of the ACM, 21(7):558\u2013565, July 1978.\n[36] C. Li, J. Leita\u0303o, A. Clement, N. Preguic\u0327a, R. Rodrigues, and V. Vafeiadis. Automating the Choice of Consistency Levels in Replicated Systems. In Proceedings of the 2014 USENIX Annual Technical Conference (USENIX ATC 14), pages 281\u2013292, Philadelphia, PA, June 2014. USENIX Association.\n[37] C. Li, D. Porto, A. Clement, J. Gehrke, N. Preguic\u0327a, and R. Rodrigues. Making Geo-replicated Systems Fast As Possible, Consistent when Necessary. In Proceedings 10th USENIX Conference on Operating Systems Design and Implementation, OSDI\u201912, pages 265\u2013278, Hollywood, USA, 2012. USENIX Association.\n[38] C. Li, N. Preguic\u0327a, and R. Rodrigues. Fine-grained consistency for geo-replicated systems. In Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC 18), pages 359\u2013372, Boston, MA, 2018. USENIX Association.\n[39] W. Lloyd, M. J. Freedman, M. Kaminsky, and D. G. Andersen. Don\u2019t Settle for Eventual: Scalable Causal Consistency for Wide-area Storage with COPS. In Proceedings of the 23rd ACM Symposium on Operating Systems Principles, SOSP \u201911, pages 401\u2013416, Cascais, Portugal, 2011. ACM.\n[40] W. Lloyd, M. J. Freedman, M. Kaminsky, and D. G. Andersen. Stronger Semantics for Low-latency Geo-replicated Storage. In Proceedings 10th USENIX Conference on Networked Systems Design and Implementation, NSDI\u201913, pages 313\u2013328, Lombard, USA, 2013. USENIX Association.\n[41] P. E. O\u2019Neil. The Escrow Transactional Method. ACM Trans. Database Syst., 11(4):405\u2013430, Dec. 1986.\n[42] G. Pang, T. Kraska, M. J. Franklin, and A. Fekete. PLANET: Making Progress with Commit Processing in Unpredictable Environments. In Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data, SIGMOD\n\u201914, pages 3\u201314, Snowbird, Utah, USA, 2014. ACM. [43] D. L. Parnas. Precise Documentation: The Key to Better\nSoftware. In S. Nanz, editor, The Future of Software Engineering, pages 125\u2013148. Springer, 2010.\n[44] S. Roy, L. Kot, G. Bender, B. Ding, H. Hojjat, C. Koch, N. Foster, and J. Gehrke. The Homeostasis Protocol: Avoiding Transaction Coordination Through Program Analysis. In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201915, pages 1311\u20131326, Melbourne, Victoria, Australia, 2015. ACM.\n[45] M. Shapiro, N. Preguic\u0327a, C. Baquero, and M. Zawirski. A comprehensive Study of Convergent and Commutative Replicated Data Types. Research Report RR-7506, INRIA, Jan. 2011.\n[46] M. Shapiro, N. Preguic\u0327a, C. Baquero, and M. Zawirski. Conflict-free Replicated Data Types. In Proceedings of the 13th Conference Conference on Stabilization, Safety, and Security of Distributed Systems, SSS\u201911, pages 386\u2013400, Grenoble, France, 2011. Springer-Verlag.\n[47] S. Sivasubramanian. Amazon DynamoDB: A Seamlessly Scalable Non-relational Database Service. In Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD \u201912, pages 729\u2013730, Scottsdale, Arizona, USA, 2012. ACM.\n[48] V. B. Sousa. Invariant Preservation in Geo-replicated Data Stores. PhD thesis, Faculdade de Cie\u0302ncias e Tecnologia, Universidade NOVA de Lisboa, 12 2017.\n[49] Y. Sovran, R. Power, M. K. Aguilera, and J. Li. Transactional Storage for Geo-replicated Systems. In Proceedings of the 23rd ACM Symposium on Operating Systems Principles, SOSP \u201911, pages 385\u2013400, Cascais, Portugal, 2011. ACM.\n[50] D. B. Terry, M. M. Theimer, K. Petersen, A. J. Demers, M. J. Spreitzer, and C. H. Hauser. Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System. In Proceedings of the 15th ACM Symposium on Operating Systems Principles, SOSP \u201995, pages 172\u2013182, Copper Mountain, Colorado, USA, 1995. ACM.\n[51] S. Tu, W. Zheng, E. Kohler, B. Liskov, and S. Madden. Speedy Transactions in Multicore In-memory Databases. In Proceedings of the 24th ACM Symposium on Operating Systems Principles, SOSP \u201913, pages 18\u201332, Farminton, Pennsylvania, USA, 2013. ACM.\n[52] W. Vogels. Eventually consistent. Communications of the ACM, 52(1):40\u201344, Jan. 2009.\n[53] T. Warszawski and P. Bailis. ACIDRain: Concurrency-Related Attacks on Database-Backed Web Applications. In Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD \u201917, pages 5\u201320, Chicago, Illinois, USA, 2017. ACM.\n[54] M. Whittaker and J. M. Hellerstein. Interactive checks for coordination avoidance. PVLDB, 2(1):14\u201327, 2018.\n[55] J. R. Wilcox, D. Woos, P. Panchekha, Z. Tatlock, X. Wang, M. D. Ernst, and T. Anderson. Verdi: A Framework for Implementing and Formally Verifying Distributed Systems. In Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI \u201915, pages 357\u2013368, Portland, OR, USA, 2015. ACM.\n[56] C. Xie, C. Su, M. Kapritsos, Y. Wang, N. Yaghmazadeh, L. Alvisi, and P. Mahajan. Salt: Combining acid and base in a distributed database. In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation, OSDI\u201914, pages 495\u2013509, Broomfield, CO,\nUSA, 2014. USENIX Association. [57] M. Zawirski, N. Preguic\u0327a, S. Duarte, A. Bieniusa, V. Balegas,\nand M. Shapiro. Write Fast, Read in the Past: Causal Consistency for Client-Side Applications. In Proceedings of the 16th Annual Middleware Conference, Middleware \u201915, pages 75\u201387, Vancouver, BC, Canada, 2015. ACM.\n[58] Y. Zhang, R. Power, S. Zhou, Y. Sovran, M. K. Aguilera, and J. Li. Transaction Chains: Achieving Serializability with Low Latency in Geo-distributed Storage Systems. In Proceedings of the 24th ACM Symposium on Operating Systems Principles, SOSP \u201913, pages 276\u2013291, Farminton, Pennsylvania, USA, 2013. ACM."
        }
    ],
    "title": "IPA: Invariant-Preserving Applications for Weakly Consistent Replicated Databases",
    "year": 2018
}