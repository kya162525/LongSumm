{
    "abstractText": "We identify obfuscated gradients, a kind of gradient masking, as a phenomenon that leads to a false sense of security in defenses against adversarial examples. While defenses that cause obfuscated gradients appear to defeat iterative optimizationbased attacks, we find defenses relying on this effect can be circumvented. We describe characteristic behaviors of defenses exhibiting the effect, and for each of the three types of obfuscated gradients we discover, we develop attack techniques to overcome it. In a case study, examining noncertified white-box-secure defenses at ICLR 2018, we find obfuscated gradients are a common occurrence, with 7 of 9 defenses relying on obfuscated gradients. Our new attacks successfully circumvent 6 completely, and 1 partially, in the original threat model each paper considers.",
    "authors": [
        {
            "affiliations": [],
            "name": "Anish Athalye"
        },
        {
            "affiliations": [],
            "name": "Nicholas Carlini"
        },
        {
            "affiliations": [],
            "name": "David Wagner"
        }
    ],
    "id": "SP:9b451b772349d9805b4da89fc5caba1d38196c6a",
    "references": [
        {
            "authors": [
                "L. Amsaleg",
                "O. Chelly",
                "T. Furon",
                "S. Girard",
                "M.E. Houle",
                "Kawarabayashi",
                "K.-i",
                "M. Nett"
            ],
            "title": "Estimating local intrinsic dimensionality",
            "venue": "In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,",
            "year": 2015
        },
        {
            "authors": [
                "A. Athalye",
                "L. Engstrom",
                "A. Ilyas",
                "K. Kwok"
            ],
            "title": "Synthesizing robust adversarial examples",
            "venue": "arXiv preprint arXiv:1707.07397,",
            "year": 2017
        },
        {
            "authors": [
                "Y. Bengio",
                "N. L\u00e9onard",
                "A. Courville"
            ],
            "title": "Estimating or propagating gradients through stochastic neurons for conditional computation",
            "venue": "arXiv preprint arXiv:1308.3432,",
            "year": 2013
        },
        {
            "authors": [
                "B. Biggio",
                "I. Corona",
                "D. Maiorca",
                "B. Nelson",
                "N. \u0160rndi\u0107",
                "P. Laskov",
                "G. Giacinto",
                "F. Roli"
            ],
            "title": "Evasion attacks against machine learning at test time",
            "venue": "In Joint European Conference on Machine Learning and Knowledge Discovery in Databases,",
            "year": 2013
        },
        {
            "authors": [
                "J. Buckman",
                "A. Roy",
                "C. Raffel",
                "I. Goodfellow"
            ],
            "title": "Thermometer encoding: One hot way to resist adversarial examples",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "N. Carlini",
                "D. Wagner"
            ],
            "title": "Adversarial examples are not easily detected: Bypassing ten detection methods",
            "venue": "AISec,",
            "year": 2017
        },
        {
            "authors": [
                "N. Carlini",
                "D. Wagner"
            ],
            "title": "Magnet and \u201cefficient defenses against adversarial attacks\u201d are not robust to adversarial examples",
            "venue": "arXiv preprint arXiv:1711.08478,",
            "year": 2017
        },
        {
            "authors": [
                "N. Carlini",
                "D. Wagner"
            ],
            "title": "Towards evaluating the robustness of neural networks",
            "venue": "In IEEE Symposium on Security & Privacy,",
            "year": 2017
        },
        {
            "authors": [
                "G.S. Dhillon",
                "K. Azizzadenesheli",
                "J.D. Bernstein",
                "J. Kossaifi",
                "A. Khanna",
                "Z.C. Lipton",
                "A. Anandkumar"
            ],
            "title": "Stochastic activation pruning for robust adversarial defense",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "I. Goodfellow",
                "J. Pouget-Abadie",
                "M. Mirza",
                "B. Xu",
                "D. Warde-Farley",
                "S. Ozair",
                "A. Courville",
                "Y. Bengio"
            ],
            "title": "Generative adversarial nets",
            "venue": "In Advances in neural information processing systems,",
            "year": 2014
        },
        {
            "authors": [
                "I.J. Goodfellow",
                "J. Shlens",
                "C. Szegedy"
            ],
            "title": "Explaining and harnessing adversarial examples",
            "venue": "arXiv preprint arXiv:1412.6572,",
            "year": 2014
        },
        {
            "authors": [
                "I. Gulrajani",
                "F. Ahmed",
                "M. Arjovsky",
                "V. Dumoulin",
                "A. Courville"
            ],
            "title": "Improved training of wasserstein gans",
            "venue": "arXiv preprint arXiv:1704.00028,",
            "year": 2017
        },
        {
            "authors": [
                "C. Guo",
                "M. Rana",
                "M. Cisse",
                "L. van der Maaten"
            ],
            "title": "Countering adversarial images using input transformations",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "K. He",
                "X. Zhang",
                "S. Ren",
                "J. Sun"
            ],
            "title": "Deep residual learning for image recognition",
            "venue": "In Proceedings of the IEEE conference on computer vision and pattern recognition,",
            "year": 2016
        },
        {
            "authors": [
                "W. He",
                "J. Wei",
                "X. Chen",
                "N. Carlini",
                "D. Song"
            ],
            "title": "Adversarial example defenses: Ensembles of weak defenses are not strong",
            "venue": "arXiv preprint arXiv:1706.04701,",
            "year": 2017
        },
        {
            "authors": [
                "A. Ilyas",
                "A. Jalal",
                "E. Asteri",
                "C. Daskalakis",
                "A.G. Dimakis"
            ],
            "title": "The robust manifold defense: Adversarial training using generative models",
            "venue": "arXiv preprint arXiv:1712.09196,",
            "year": 2017
        },
        {
            "authors": [
                "A. Kurakin",
                "I. Goodfellow",
                "S. Bengio"
            ],
            "title": "Adversarial examples in the physical world",
            "venue": "arXiv preprint arXiv:1607.02533,",
            "year": 2016
        },
        {
            "authors": [
                "A. Kurakin",
                "I.J. Goodfellow",
                "S. Bengio"
            ],
            "title": "Adversarial machine learning at scale",
            "venue": "arXiv preprint arXiv:1611.01236,",
            "year": 2016
        },
        {
            "authors": [
                "X. Ma",
                "B. Li",
                "Y. Wang",
                "S.M. Erfani",
                "S. Wijewickrema",
                "G. Schoenebeck",
                "M.E. Houle",
                "D. Song",
                "J. Bailey"
            ],
            "title": "Characterizing adversarial subspaces using local intrinsic dimensionality",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "A. Madry",
                "A. Makelov",
                "L. Schmidt",
                "D. Tsipras",
                "A. Vladu"
            ],
            "title": "Towards deep learning models resistant to adversarial attacks",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "T. Na",
                "J.H. Ko",
                "S. Mukhopadhyay"
            ],
            "title": "Cascade adversarial machine learning regularized with a unified embedding",
            "venue": "In International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "N. Papernot",
                "P. McDaniel",
                "I. Goodfellow",
                "S. Jha",
                "Z.B. Celik",
                "A. Swami"
            ],
            "title": "Practical black-box attacks against machine learning",
            "venue": "In Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security, ASIA CCS",
            "year": 2017
        },
        {
            "authors": [
                "A. Raghunathan",
                "J. Steinhardt",
                "P. Liang"
            ],
            "title": "Certified defenses against adversarial examples",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "T. Salimans",
                "A. Karpathy",
                "X. Chen",
                "D.P. Kingma"
            ],
            "title": "Pixelcnn++: A pixelcnn implementation with discretized logistic mixture likelihood and other modifications",
            "venue": "In ICLR,",
            "year": 2017
        },
        {
            "authors": [
                "P. Samangouei",
                "M. Kabkab",
                "R. Chellappa"
            ],
            "title": "Defensegan: Protecting classifiers against adversarial attacks using generative models",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "Y. Sharma",
                "Chen",
                "P.-Y"
            ],
            "title": "Attacking the madry defense model with L1-based adversarial examples",
            "venue": "arXiv preprint arXiv:1710.10733,",
            "year": 2017
        },
        {
            "authors": [
                "A. Sinha",
                "H. Namkoong",
                "J. Duchi"
            ],
            "title": "Certifiable distributional robustness with principled adversarial training",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "Y. Song",
                "T. Kim",
                "S. Nowozin",
                "S. Ermon",
                "N. Kushman"
            ],
            "title": "Pixeldefend: Leveraging generative models to understand and defend against adversarial examples",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "C. Szegedy",
                "W. Zaremba",
                "I. Sutskever",
                "J. Bruna",
                "D. Erhan",
                "I. Goodfellow",
                "R. Fergus"
            ],
            "title": "Intriguing properties of neural networks",
            "year": 2013
        },
        {
            "authors": [
                "C. Szegedy",
                "V. Vanhoucke",
                "S. Ioffe",
                "J. Shlens",
                "Z. Wojna"
            ],
            "title": "Rethinking the inception architecture for computer vision",
            "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
            "year": 2016
        },
        {
            "authors": [
                "F. Tram\u00e8r",
                "A. Kurakin",
                "N. Papernot",
                "I. Goodfellow",
                "D. Boneh",
                "P. McDaniel"
            ],
            "title": "Ensemble adversarial training: Attacks and defenses",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "C. Xie",
                "J. Wang",
                "Z. Zhang",
                "Z. Ren",
                "A. Yuille"
            ],
            "title": "Mitigating adversarial effects through randomization",
            "venue": "International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "Samangouei"
            ],
            "title": "2018), the authors construct a white-box attack by unrolling the gradient descent used during classification. Despite an unbounded `2 perturbation size, Carlini and Wagner\u2019s attack only reaches 30% misclassification rate on the most vulnerable model",
            "year": 2018
        }
    ],
    "sections": [
        {
            "heading": "1. Introduction",
            "text": "In response to the susceptibility of neural networks to adversarial examples (Szegedy et al., 2013; Biggio et al., 2013), there has been significant interest recently in constructing defenses to increase the robustness of neural networks. While progress has been made in understanding and defending against adversarial examples in the white-box setting, where the adversary has full access to the network, a complete solution has not yet been found.\nAs benchmarking against iterative optimization-based attacks (e.g., Kurakin et al. (2016a); Madry et al. (2018); Carlini & Wagner (2017c)) has become standard practice in evaluating defenses, new defenses have arisen that appear to be robust against these powerful optimization-based attacks.\nWe identify one common reason why many defenses provide\n*Equal contribution 1Massachusetts Institute of Technology 2University of California, Berkeley. Correspondence to: Anish Athalye <aathalye@mit.edu>, Nicholas Carlini <npc@berkeley.edu>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\napparent robustness against iterative optimization attacks: obfuscated gradients, a term we define as a special case of gradient masking (Papernot et al., 2017). Without a good gradient, where following the gradient does not successfully optimize the loss, iterative optimization-based methods cannot succeed. We identify three types of obfuscated gradients: shattered gradients are nonexistent or incorrect gradients caused either intentionally through non-differentiable operations or unintentionally through numerical instability; stochastic gradients depend on test-time randomness; and vanishing/exploding gradients in very deep computation result in an unusable gradient.\nWe propose new techniques to overcome obfuscated gradients caused by these three phenomena. We address gradient shattering with a new attack technique we call Backward Pass Differentiable Approximation, where we approximate derivatives by computing the forward pass normally and computing the backward pass using a differentiable approximation of the function. We compute gradients of randomized defenses by applying Expectation Over Transformation (Athalye et al., 2017). We solve vanishing/exploding gradients through reparameterization and optimize over a space where gradients do not explode/vanish.\nTo investigate the prevalence of obfuscated gradients and understand the applicability of these attack techniques, we use as a case study the ICLR 2018 non-certified defenses that claim white-box robustness. We find that obfuscated gradients are a common occurrence, with 7 of 9 defenses relying on this phenomenon. Applying the new attack techniques we develop, we overcome obfuscated gradients and circumvent 6 of them completely, and 1 partially, under the original threat model of each paper. Along with this, we offer an analysis of the evaluations performed in the papers.\nAdditionally, we hope to provide researchers with a common baseline of knowledge, description of attack techniques, and common evaluation pitfalls, so that future defenses can avoid falling vulnerable to these same attack approaches.\nTo promote reproducible research, we release our reimplementation of each of these defenses, along with implementations of our attacks for each. 1\n1 https://github.com/anishathalye/obfuscated-gradients\nar X\niv :1\n80 2.\n00 42\n0v 4\n[ cs\n.L G\n] 3\n1 Ju\nl 2 01\n8"
        },
        {
            "heading": "2. Preliminaries",
            "text": ""
        },
        {
            "heading": "2.1. Notation",
            "text": "We consider a neural network f(\u00b7) used for classification where f(x)i represents the probability that image x corresponds to label i. We classify images, represented as x \u2208 [0, 1]w\u00b7h\u00b7c for a c-channel image of width w and height h. We use f j(\u00b7) to refer to layer j of the neural network, and f1..j(\u00b7) the composition of layers 1 through j. We denote the classification of the network as c(x) = arg maxif(x)i, and c\u2217(x) denotes the true label."
        },
        {
            "heading": "2.2. Adversarial Examples",
            "text": "Given an image x and classifier f(\u00b7), an adversarial example (Szegedy et al., 2013) x\u2032 satisfies two properties: D(x, x\u2032) is small for some distance metric D, and c(x\u2032) 6= c\u2217(x). That is, for images, x and x\u2032 appear visually similar but x\u2032 is classified incorrectly.\nIn this paper, we use the `\u221e and `2 distortion metrics to measure similarity. Two images which have a small distortion under either of these metrics will appear visually identical. We report `\u221e distance in the normalized [0, 1] space, so that a distortion of 0.031 corresponds to 8/256, and `2 distance as the total root-mean-square distortion normalized by the total number of pixels (as is done in prior work)."
        },
        {
            "heading": "2.3. Datasets & Models",
            "text": "We evaluate these defenses on the same datasets on which they claim robustness.\nIf a defense argues security on MNIST and any other dataset, we only evaluate the defense on the larger dataset. On MNIST and CIFAR-10, we evaluate defenses over the entire test set and generate untargeted adversarial examples. On ImageNet, we evaluate over 1000 randomly selected images in the test set, construct targeted adversarial examples with randomly selected target classes, and report attack success rate in addition to model accuracy. Generating targeted adversarial examples is a strictly harder problem that we believe is a more meaningful metric for evaluating attacks. 2 Conversely, for a defender, the harder task is to argue robustness to untargeted attacks.\nWe use standard models for each dataset. For MNIST we use a standard 5-layer convolutional neural network which reaches 99.3% accuracy. On CIFAR-10 we train a wide ResNet (Zagoruyko & Komodakis, 2016; He et al., 2016) to 95% accuracy. For ImageNet we use the InceptionV3 (Szegedy et al., 2016) network which reaches 78.0% top-1 and 93.9% top-5 accuracy.\n2Misclassification is a less meaningful metric on ImageNet, where a misclassification of closely related classes (e.g., a German shepherd classified as a Doberman) may not be meaningful."
        },
        {
            "heading": "2.4. Threat Models",
            "text": "Prior work considers adversarial examples in white-box and black-box threat models. In this paper, we consider defenses designed for the white-box setting, where the adversary has full access to the neural network classifier (architecture and weights) and defense, but not test-time randomness (only the distribution). We evaluate each defense under the threat model under which it claims to be secure (e.g., bounded `\u221e distortion of = 0.031). It often easy to find imperceptibly perturbed adversarial examples by violating the threat model, but by doing so under the original threat model, we show that the original evaluations were inadequate and the claims of defenses\u2019 security were incorrect."
        },
        {
            "heading": "2.5. Attack Methods",
            "text": "We construct adversarial examples with iterative optimization-based methods. For a given instance x, these attacks attempt to search for a \u03b4 such that c(x + \u03b4) 6= c\u2217(x) either minimizing \u2016\u03b4\u2016, or maximizing the classification loss on f(x+ \u03b4). To generate `\u221e bounded adversarial examples we use Projected Gradient Descent (PGD) confined to a specified `\u221e ball; for `2, we use the Lagrangian relaxation of Carlini & Wagner (2017c). We use between 100 and 10,000 iterations of gradient descent, as needed to obtain convergance. The specific choice of optimizer is far less important than choosing to use iterative optimization-based methods (Madry et al., 2018)."
        },
        {
            "heading": "3. Obfuscated Gradients",
            "text": "A defense is said to cause gradient masking if it \u201cdoes not have useful gradients\u201d for generating adversarial examples (Papernot et al., 2017); gradient masking is known to be an incomplete defense to adversarial examples (Papernot et al., 2017; Trame\u0300r et al., 2018). Despite this, we observe that 7 of the ICLR 2018 defenses rely on this effect.\nTo contrast from previous defenses which cause gradient masking by learning to break gradient descent (e.g., by learning to make the gradients point the wrong direction (Trame\u0300r et al., 2018)), we refer to the case where defenses are designed in such a way that the constructed defense necessarily causes gradient masking as obfuscated gradients. We discover three ways in which defenses obfuscate gradients (we use this word because in these cases, it is the defense creator who has obfuscated the gradient information); we briefly define and discuss each of them.\nShattered Gradients are caused when a defense is nondifferentiable, introduces numeric instability, or otherwise causes a gradient to be nonexistent or incorrect. Defenses that cause gradient shattering can do so unintentionally, by using differentiable operations but where following the gradient does not maximize classification loss globally.\nStochastic Gradients are caused by randomized defenses, where either the network itself is randomized or the input is randomly transformed before being fed to the classifier, causing the gradients to become randomized. This causes methods using a single sample of the randomness to incorrectly estimate the true gradient.\nExploding & Vanishing Gradients are often caused by defenses that consist of multiple iterations of neural network evaluation, feeding the output of one computation as the input of the next. This type of computation, when unrolled, can be viewed as an extremely deep neural network evaluation, which can cause vanishing/exploding gradients."
        },
        {
            "heading": "3.1. Identifying Obfuscated & Masked Gradients",
            "text": "Some defenses intentionally break gradient descent and cause obfuscated gradients. However, others defenses unintentionally break gradient descent, but the cause of gradient descent being broken is a direct result of the design of the neural network. We discuss below characteristic behaviors of defenses which cause this to occur. These behaviors may not perfectly characterize all cases of masked gradients.\nOne-step attacks perform better than iterative attacks. Iterative optimization-based attacks applied in a white-box setting are strictly stronger than single-step attacks and should give strictly superior performance. If single-step methods give performance superior to iterative methods, it is likely that the iterative attack is becoming stuck in its optimization search at a local minimum.\nBlack-box attacks are better than white-box attacks. The black-box threat model is a strict subset of the whitebox threat model, so attacks in the white-box setting should perform better; if a defense is obfuscating gradients, then black-box attacks (which do not use the gradient) often perform better than white-box attacks (Papernot et al., 2017).\nUnbounded attacks do not reach 100% success. With unbounded distortion, any classifier should have 0% robustness to attack. If an attack does not reach 100% success with sufficiently large distortion bound, this indicates the attack is not performing optimally against the defense, and the attack should be improved.\nRandom sampling finds adversarial examples. Bruteforce random search (e.g., randomly sampling 105 or more points) within some -ball should not find adversarial examples when gradient-based attacks do not.\nIncreasing distortion bound does not increase success. A larger distortion bound should monotonically increase attack success rate; significantly increasing distortion bound should result in significantly higher attack success rate."
        },
        {
            "heading": "4. Attack Techniques",
            "text": "Generating adversarial examples through optimizationbased methods requires useful gradients obtained through backpropagation (Rumelhart et al., 1986). Many defenses therefore either intentionally or unintentionally cause gradient descent to fail because of obfuscated gradients caused by gradient shattering, stochastic gradients, or vanishing/exploding gradients. We discuss a number of techniques that we develop to overcome obfuscated gradients."
        },
        {
            "heading": "4.1. Backward Pass Differentiable Approximation",
            "text": "Shattered gradients, caused either unintentionally, e.g. by numerical instability, or intentionally, e.g. by using nondifferentiable operations, result in nonexistent or incorrect gradients. To attack defenses where gradients are not readily available, we introduce a technique we call Backward Pass Differentiable Approximation (BPDA) 3."
        },
        {
            "heading": "4.1.1. A SPECIAL CASE:",
            "text": "THE STRAIGHT-THROUGH ESTIMATOR\nAs a special case, we first discuss what amounts to the straight-through estimator (Bengio et al., 2013) applied to constructing adversarial examples.\nMany non-differentiable defenses can be expressed as follows: given a pre-trained classifier f(\u00b7), construct a preprocessor g(\u00b7) and let the secured classifier f\u0302(x) = f(g(x)) where the preprocessor g(\u00b7) satisfies g(x) \u2248 x (e.g., such a g(\u00b7) may perform image denoising to remove the adversarial perturbation, as in Guo et al. (2018)). If g(\u00b7) is smooth and differentiable, then computing gradients through the combined network f\u0302 is often sufficient to circumvent the defense (Carlini & Wagner, 2017b). However, recent work has constructed functions g(\u00b7) which are neither smooth nor differentiable, and therefore can not be backpropagated through to generate adversarial examples with a white-box attack that requires gradient signal.\nBecause g is constructed with the property that g(x) \u2248 x, we can approximate its derivative as the derivative of the identity function: \u2207xg(x) \u2248 \u2207xx = 1. Therefore, we can approximate the derivative of f(g(x)) at the point x\u0302 as:\n\u2207xf(g(x))|x=x\u0302 \u2248 \u2207xf(x)|x=g(x\u0302) This allows us to compute gradients and therefore mount a white-box attack. Conceptually, this attack is simple. We perform forward propagation through the neural network as usual, but on the backward pass, we replace g(\u00b7) with the identity function. In practice, the implementation can be expressed in an even simpler way: we approximate\u2207xf(g(x)) by evaluating \u2207xf(x) at the point g(x). This gives us an\n3The BPDA approach can be used on an arbitrary network, even if it is already differentiable, to obtain a more useful gradient.\napproximation of the true gradient, and while not perfect, is sufficiently useful that when averaged over many iterations of gradient descent still generates an adversarial example. The math behind the validity of this approach is similar to the special case."
        },
        {
            "heading": "4.1.2. GENERALIZED ATTACK: BPDA",
            "text": "While the above attack is effective for a simple class of networks expressible as f(g(x)) when g(x) \u2248 x, it is not fully general. We now generalize the above approach into our full attack, which we call Backward Pass Differentiable Approximation (BPDA).\nLet f(\u00b7) = f1...j(\u00b7) be a neural network, and let f i(\u00b7) be a non-differentiable (or not usefully-differentiable) layer. To approximate\u2207xf(x), we first find a differentiable approximation g(x) such that g(x) \u2248 f i(x). Then, we can approximate\u2207xf(x) by performing the forward pass through f(\u00b7) (and in particular, computing a forward pass through f i(x)), but on the backward pass, replacing f i(x) with g(x). Note that we perform this replacement only on the backward pass.\nAs long as the two functions are similar, we find that the slightly inaccurate gradients still prove useful in constructing an adversarial example. Applying BPDA often requires more iterations of gradient descent than without because each individual gradient descent step is not exactly correct.\nWe have found applying BPDA is often necessary: replacing f i(\u00b7) with g(\u00b7) on both the forward and backward pass is either completely ineffective (e.g. with Song et al. (2018)) or many times less effective (e.g. with Buckman et al. (2018))."
        },
        {
            "heading": "4.2. Attacking Randomized Classifiers",
            "text": "Stochastic gradients arise when using randomized transformations to the input before feeding it to the classifier or when using a stochastic classifier. When using optimizationbased attacks on defenses that employ these techniques, it is necessary to estimate the gradient of the stochastic function.\nExpectation over Transformation. For defenses that employ randomized transformations to the input, we apply Expectation over Transformation (EOT) (Athalye et al., 2017) to correctly compute the gradient over the expected transformation to the input.\nWhen attacking a classifier f(\u00b7) that first randomly transforms its input according to a function t(\u00b7) sampled from a distribution of transformations T , EOT optimizes the expectation over the transformation Et\u223cT f(t(x)). The optimization problem can be solved by gradient descent, noting that \u2207Et\u223cT f(t(x)) = Et\u223cT\u2207f(t(x)), differentiating through the classifier and transformation, and approximating the expectation with samples at each gradient descent step."
        },
        {
            "heading": "4.3. Reparameterization",
            "text": "We solve vanishing/exploding gradients by reparameterization. Assume we are given a classifier f(g(x)) where g(\u00b7) performs some optimization loop to transform the input x to a new input x\u0302. Often times, this optimization loop means that differentiating through g(\u00b7), while possible, yields exploding or vanishing gradients.\nTo resolve this, we make a change-of-variable x = h(z) for some function h(\u00b7) such that g(h(z)) = h(z) for all z, but h(\u00b7) is differentiable. For example, if g(\u00b7) projects samples to some manifold in a specific manner, we might construct h(z) to return points exclusively on the manifold. This allows us to compute gradients through f(h(z)) and thereby circumvent the defense."
        },
        {
            "heading": "5. Case Study: ICLR 2018 Defenses",
            "text": "As a case study for evaluating the prevalence of obfuscated gradients, we study the ICLR 2018 non-certified defenses that argue robustness in a white-box threat model. Each of these defenses argues a high robustness to adaptive, whitebox attacks. We find that seven of these nine defenses rely on this phenomenon, and we demonstrate that our techniques can completely circumvent six of those (and partially circumvent one) that rely on obfuscated gradients. We omit two defenses with provable security claims (Raghunathan et al., 2018; Sinha et al., 2018) and one that only argues black-box security (Trame\u0300r et al., 2018). We include one paper, Ma et al. (2018), that was not proposed as a defense per se, but suggests a method to detect adversarial examples.\nThere is an asymmetry in attacking defenses versus constructing robust defenses: to show a defense can be bypassed, it is only necessary to demonstrate one way to do so; in contrast, a defender must show no attack can succeed.\nTable 1 summarizes our results. Of the 9 accepted papers, 7 rely on obfuscated gradients. Two of these defenses argue robustness on ImageNet, a much harder task than CIFAR-10; and one argues robustness on MNIST, a much easier task than CIFAR-10. As such, comparing defenses across datasets is difficult."
        },
        {
            "heading": "5.1. Non-obfuscated Gradients",
            "text": ""
        },
        {
            "heading": "5.1.1. ADVERSARIAL TRAINING",
            "text": "Defense Details. Originally proposed by Goodfellow et al. (2014b), adversarial training solves a min-max game through a conceptually simple process: train on adversarial examples until the model learns to classify them correctly. Given training data X and loss function `(\u00b7), standard training chooses network weights \u03b8 as\n\u03b8\u2217 = arg min \u03b8 E (x,y)\u2208X `(x; y;F\u03b8).\nWe study the adversarial training approach of Madry et al. (2018) which for a given -ball solves\n\u03b8\u2217 = arg min \u03b8 E (x,y)\u2208X\n[ max\n\u03b4\u2208[\u2212 , ]N `(x+ \u03b4; y;F\u03b8)\n] .\nTo approximately solve this formulation, the authors solve the inner maximization problem by generating adversarial examples using projected gradient descent.\nDiscussion. We believe this approach does not cause obfuscated gradients: our experiments with optimizationbased attacks do succeed with some probability (but do not invalidate the claims in the paper). Further, the authors\u2019 evaluation of this defense performs all of the tests for characteristic behaviors of obfuscated gradients that we list. However, we note that (1) adversarial retraining has been shown to be difficult at ImageNet scale (Kurakin et al., 2016b), and (2) training exclusively on `\u221e adversarial examples provides only limited robustness to adversarial examples under other distortion metrics (Sharma & Chen, 2017)."
        },
        {
            "heading": "5.1.2. CASCADE ADVERSARIAL TRAINING",
            "text": "Cascade adversarial machine learning (Na et al., 2018) is closely related to the above defense. The main difference is that instead of using iterative methods to generate adversarial examples at each mini-batch, the authors train a first model, generate adversarial examples (with iterative methods) on that model, add these to the training set, and then train a second model on the augmented dataset only single-step methods for efficiency. Additionally, the authors construct a \u201cunified embedding\u201d and enforce that the clean and adversarial logits are close under some metric.\nDiscussion. Again, as above, we are unable to reduce the claims made by the authors. However, these claims are weaker than other defenses (because the authors correctly performed a strong optimization-based attack (Carlini & Wagner, 2017c)): 16% accuracy with = .015, compared to over 70% at the same perturbation budget with adversarial training as in Madry et al. (2018)."
        },
        {
            "heading": "5.2. Gradient Shattering",
            "text": ""
        },
        {
            "heading": "5.2.1. THERMOMETER ENCODING",
            "text": "Defense Details. In contrast to prior work (Szegedy et al., 2013) which viewed adversarial examples as \u201cblind spots\u201d in neural networks, Goodfellow et al. (2014b) argue that the reason adversarial examples exist is that neural networks behave in a largely linear manner. The purpose of thermometer encoding is to break this linearity.\nGiven an image x, for each pixel color xi,j,c, the l-level thermometer encoding \u03c4(xi,j,c) is a l-dimensional vector where \u03c4(xi,j,c)k = 1 if if xi,j,c > k/l, and 0 otherwise (e.g., for a 10-level thermometer encoding, \u03c4(0.66) = 1111110000).\nDue to the discrete nature of thermometer encoded values, it is not possible to directly perform gradient descent on a thermometer encoded neural network. The authors therefore construct Logit-Space Projected Gradient Ascent (LS-PGA) as an attack over the discrete thermometer encoded inputs. Using this attack, the authors perform the adversarial training of Madry et al. (2018) on thermometer encoded networks.\nOn CIFAR-10, just performing thermometer encoding was found to give 50% accuracy within = 0.031 under `\u221e distortion. By performing adversarial training with 7 steps of LS-PGA, robustness increased to 80%.\nDiscussion. While the intention behind this defense is to break the local linearity of neural networks, we find that this defense in fact causes gradient shattering. This can be observed through their black-box attack evaluation: adversarial examples generated on a standard adversarially trained model transfer to a thermometer encoded model reducing the accuracy to 67%, well below the 80% robustness to the white-box iterative attack.\nEvaluation. We use the BPDA approach from \u00a74.1.2, where we let f(x) = \u03c4(x). Observe that if we define\n\u03c4\u0302(xi,j,c)k = min(max(xi,j,c \u2212 k/l, 0), 1)\nthen \u03c4(xi,j,c)k = floor(\u03c4\u0302(xi,j,c)k)\nso we can let g(x) = \u03c4\u0302(x) and replace the backwards pass with the function g(\u00b7).\nLS-PGA only reduces model accuracy to 50% on a thermometer-encoded model trained without adversarial training (bounded by = 0.031). In contrast, we achieve 1% model accuracy with the lower = 0.015 (and 0% with = 0.031). This shows no measurable improvement from standard models, trained without thermometer encoding.\nWhen we attack a thermometer-encoded adversarially trained model 4, we are able to reproduce the 80% accuracy at = 0.031 claim against LS-PGA. However, our attack reduces model accuracy to 30%. This is significantly weaker than the original Madry et al. (2018) model that does not use thermometer encoding. Because this model is trained against the (comparatively weak) LS-PGA attack, it is unable to adapt to the stronger attack we present above. Figure 1 shows a comparison of thermometer encoding, with and without adversarial training, against the baseline classifier, over a range of perturbation magnitudes, demonstrating that thermometer encoding provides limited value."
        },
        {
            "heading": "5.2.2. INPUT TRANSFORMATIONS",
            "text": "Defense Details. Guo et al. (2018) propose five input transformations to counter adversarial examples.\nAs a baseline, the authors evaluate image cropping and rescaling, bit-depth reduction, and JPEG compression. Then the authors suggest two new transformations: (a) randomly drop pixels and restore them by performing total variance minimization; and (b) image quilting: reconstruct images by replacing small patches with patches from \u201cclean\u201d images, using minimum graph cuts in overlapping boundary regions to remove edge artifacts.\n4That is, a thermometer encoded model that is trained using the approach of (Madry et al., 2018).\nThe authors explore different combinations of input transformations along with different underlying ImageNet classifiers, including adversarially trained models. They find that input transformations provide protection even with a vanilla classifier.\nDiscussion. The authors find that a ResNet-50 classifier provides a varying degree of accuracy for each of the five proposed input transformations under the strongest attack with a normalized `2 dissimilarity of 0.01, with the strongest defenses achieving over 60% top-1 accuracy. We reproduce these results when evaluating an InceptionV3 classifier.\nThe authors do not succeed in white-box attacks, crediting lack of access to test-time randomness as \u201cparticularly crucial in developing strong defenses\u201d (Guo et al., 2018). 5\nEvaluation. It is possible to bypass each defense independently (and ensembles of defenses usually are not much stronger than the strongest sub-component (He et al., 2017)). We circumvent image cropping and rescaling with a direct application of EOT. To circumvent bit-depth reduction and JPEG compression, we use BPDA and approximate the backward pass with the identity function. To circumvent total variance minimization and image quilting, which are both non-differentiable and randomized, we apply EOT and use BPDA to approximate the gradient through the transformation. With our attack, we achieve 100% targeted attack success rate and accuracy drops to 0% for the strongest defense under the smallest perturbation budget considered in Guo et al. (2018), a root-mean-square perturbation of 0.05 (and a \u201cnormalized\u201d `2 perturbation as defined in Guo et al. (2018) of 0.01)."
        },
        {
            "heading": "5.2.3. LOCAL INTRINSIC DIMENSIONALITY (LID)",
            "text": "LID is a general-purpose metric that measures the distance from an input to its neighbors. Ma et al. (2018) propose using LID to characterize properties of adversarial examples. The authors emphasize that this classifier is not intended as a defense against adversarial examples 6, however the authors argue that it is a robust method for detecting adversarial examples that is not easy to evade by attempting their own adaptive attack and showing it fails.\nAnalysis Overview. Instead of actively attacking the detection method, we find that LID is not able to detect high confidence adversarial examples (Carlini & Wagner, 2017a), even in the unrealistic threat model where the adversary is entirely oblivious to the defense and generates adversarial examples on the original classifier. A full discussion of this\n5This defense may be stronger in a threat model where the adversary does not have complete information about the exact quilting process used (personal communication with authors).\n6Personal communication with authors.\nattack is given in Appendix A."
        },
        {
            "heading": "5.3. Stochastic Gradients",
            "text": ""
        },
        {
            "heading": "5.3.1. STOCHASTIC ACTIVATION PRUNING (SAP)",
            "text": "Defense Details. SAP (Dhillon et al., 2018) introduces randomness into the evaluation of a neural network to defend against adversarial examples. SAP randomly drops some neurons of each layer f i to 0 with probability proportional to their absolute value. That is, SAP essentially applies dropout at each layer where instead of dropping with uniform probability, nodes are dropped with a weighted distribution. Values which are retained are scaled up (as is done in dropout) to retain accuracy. Applying SAP decreases clean classification accuracy slightly, with a higher drop probability decreasing accuracy, but increasing robustness. We study various levels of drop probability and find they lead to similar robustness numbers.\nDiscussion. The authors only evaluate SAP by taking a single step in the gradient direction (Dhillon et al., 2018). While taking a single step in the direction of the gradient can be effective on non-randomized neural networks, when randomization is used, computing the gradient with respect to one sample of the randomness is ineffective.\nEvaluation. To resolve this difficulty, we estimate the gradients by computing the expectation over instantiations of randomness. At each iteration of gradient descent, instead of taking a step in the direction of \u2207xf(x) we move in the direction of \u2211k i=1\u2207xf(x) where each invocation is randomized with SAP. We have found that choosing k = 10 provides useful gradients. We additionally had to resolve a numerical instability when computing gradients: this defense caused computing a backward pass to cause exploding gradients due to division by numbers very close to 0.\nWith these approaches, we are able to reduce SAP model accuracy to 9% at = .015, and 0% at = 0.031. If we consider an attack successful only when an example is classified incorrectly 10 times out of 10 (and consider it correctly classified if it is ever classified as the correct label), model accuracy is below 10% with = 0.031."
        },
        {
            "heading": "5.3.2. MITIGATING THROUGH RANDOMIZATION",
            "text": "Defense Details. Xie et al. (2018) propose to defend against adversarial examples by adding a randomization layer before the input to the classifier. For a classifier that takes a 299\u00d7 299 input, the defense first randomly rescales the image to a r \u00d7 r image, with r \u2208 [299, 331), and then randomly zero-pads the image so that the result is 331\u00d7331. The output is then fed to the classifier.\nDiscussion. The authors consider three attack scenarios: vanilla attack (an attack on the original classifier), singlepattern attack (an attack assuming some fixed randomization pattern), and ensemble-pattern attack (an attack over a small ensemble of fixed randomization patterns). The authors strongest attack reduces InceptionV3 model accuracy to 32.8% top-1 accuracy (over images that were originally classified correctly).\nThe authors dismiss a stronger attack over larger choices of randomness, stating that it would be \u201ccomputationally impossible\u201d (emphasis ours) and that such an attack \u201cmay not even converge\u201d (Xie et al., 2018).\nEvaluation. We find the authors\u2019 ensemble attack overfits to the ensemble with fixed randomization. We bypass this defense by applying EOT, optimizing over the (in this case, discrete) distribution of transformations.\nUsing this attack, even if we consider the attack successful only when an example is classified incorrectly 10 times out of 10, we achieve 100% targeted attack success rate and reduce the accuracy of the classifier from 32.8% to 0.0% with a maximum `\u221e perturbation of = 0.031."
        },
        {
            "heading": "5.4. Vanishing & Exploding Gradients",
            "text": ""
        },
        {
            "heading": "5.4.1. PIXELDEFEND",
            "text": "Defense Details. Song et al. (2018) propose using a PixelCNN generative model to project a potential adversarial example back onto the data manifold before feeding it into a classifier. The authors argue that adversarial examples mainly lie in the low-probability region of the data distribution. PixelDefend \u201cpurifies\u201d adversarially perturbed images prior to classification by using a greedy decoding procedure to approximate finding the highest probability example within an -ball of the input image.\nDiscussion. The authors evaluate PixelDefend on CIFAR-10 over various classifiers and perturbation budgets. With a maximum `\u221e perturbation of = 0.031, PixelDefend claims 46% accuracy (with a vanilla ResNet classifier). The authors dismiss the possibility of end-to-end attacks on PixelDefend due to the difficulty of differentiating through an unrolled version of PixelDefend due to vanishing gradients and computation cost.\nEvaluation. We sidestep the problem of computing gradients through an unrolled version of PixelDefend by approximating gradients with BPDA, and we successfully mount an end-to-end attack using this technique 7. With this attack,\n7In place of a PixelCNN, due to the availability of a pre-trained model, we use a PixelCNN++ (Salimans et al., 2017) and discretize the mixture of logistics to produce a 256-way softmax.\nwe can reduce the accuracy of a naturally trained classifier which achieves 95% accuracy to 9% with a maximum `\u221e perturbation of = 0.031. We find that combining adversarial training (Madry et al., 2018) with PixelDefend provides no additional robustness over just using the adversarially trained classifier."
        },
        {
            "heading": "5.4.2. DEFENSE-GAN",
            "text": "Defense-GAN (Samangouei et al., 2018) uses a Generative Adversarial Network (Goodfellow et al., 2014a) to project samples onto the manifold of the generator before classifying them. That is, the intuition behind this defense is nearly identical to PixelDefend, but using a GAN instead of a PixelCNN. We therefore summarize results here and present the full details in Appendix B.\nAnalysis Overview. Defense-GAN is not argued secure on CIFAR-10, so we use MNIST. We find that adversarial examples exist on the manifold defined by the generator. That is, we show that we are able to construct an adversarial example x\u2032 = G(z) so that x\u2032 \u2248 x but c(x) 6= c(x\u2032). As such, a perfect projector would not modify this example x\u2032 because it exists on the manifold described by the generator. However, while this attack would defeat a perfect projector mapping x to its nearest point on G(z), the imperfect gradient descent based approach taken by Defense-GAN does not perfectly preserve points on the manifold. We therefore construct a second attack using BPDA to evade Defense-GAN, although at only a 45% success rate."
        },
        {
            "heading": "6. Discussion",
            "text": "Having demonstrated attacks on these seven defenses, we now take a step back and discuss the method of evaluating a defense against adversarial examples.\nThe papers we study use a variety of approaches in evaluating robustness of the proposed defenses. We list what we believe to be the most important points to keep in mind while building and evaluating defenses. Much of what we describe below has been discussed in prior work (Carlini & Wagner, 2017a; Madry et al., 2018); we repeat these points here and offer our own perspective for completeness."
        },
        {
            "heading": "6.1. Define a (realistic) threat model",
            "text": "A threat model specifies the conditions under which a defense argues security: a precise threat model allows for an exact understanding of the setting under which the defense is meant to work. Prior work has used words including whitebox, grey-box, black-box, and no-box to describe slightly different threat models, often overloading the same word.\nInstead of attempting to, yet again, redefine the vocabulary, we enumerate the various aspects of a defense that might\nbe revealed to the adversary or held secret to the defender: model architecture and model weights; training algorithm and training data; test time randomness (either the values chosen or the distribution); and, if the model weights are held secret, whether query access is allowed (and if so, the type of output, e.g. logits or only the top label).\nWhile there are some aspects of a defense that might be held secret, threat models should not contain unrealistic constraints. We believe any compelling threat model should at the very least grant knowledge of the model architecture, training algorithm, and allow query access.\nIt is not meaningful to restrict the computational power of an adversary artificially (e.g., to fewer than several thousand attack iterations). If two defenses are equally robust but generating adversarial examples on one takes one second and another takes ten seconds, the robustness has not increased."
        },
        {
            "heading": "6.2. Make specific, testable claims",
            "text": "Specific, testable claims in a clear threat model precisely convey the claimed robustness of a defense. For example, a complete claim might be: \u201cWe achieve 90% accuracy when bounded by `\u221e distortion with = 0.031, when the attacker has full white-box access.\u201d\nIn this paper, we study all papers under the threat model the authors define. However, if a paper is evaluated under a different threat model, explicitly stating so makes it clear that the original paper\u2019s claims are not being violated.\nA defense being specified completely, with all hyperparameters given, is a prerequisite for claims to be testable. Releasing source code and a pre-trained model along with the paper describing a specific threat model and robustness claims is perhaps the most useful method of making testable claims. At the time of writing this paper, four of the defenses we study made complete source code available (Madry et al., 2018; Ma et al., 2018; Guo et al., 2018; Xie et al., 2018)."
        },
        {
            "heading": "6.3. Evaluate against adaptive attacks",
            "text": "A strong defense is robust not only against existing attacks, but also against future attacks within the specified threat model. A necessary component of any defense proposal is therefore an attempt at an adaptive attack.\nAn adaptive attack is one that is constructed after a defense has been completely specified, where the adversary takes advantage of knowledge of the defense and is only restricted by the threat model. One useful attack approach is to perform many attacks and report the mean over the best attack per image. That is, for a set of attacks a \u2208 A instead of reporting the value min\na\u2208A mean x\u2208A f(a(x)) report mean x\u2208A min a\u2208A f(a(x)).\nIf a defense is modified after an evaluation, an adaptive\nattack is one that considers knowledge of the new defense. In this way, concluding an evaluation with a final adaptive attack can be seen as analogous to evaluating a model on the test data."
        },
        {
            "heading": "7. Conclusion",
            "text": "Constructing defenses to adversarial examples requires defending against not only existing attacks but also future attacks that may be developed. In this paper, we identify obfuscated gradients, a phenomenon exhibited by certain defenses that makes standard gradient-based methods fail to generate adversarial examples. We develop three attack techniques to bypass three different types of obfuscated gradients. To evaluate the applicability of our techniques, we use the ICLR 2018 defenses as a case study, circumventing seven of nine accepted defenses.\nMore generally, we hope that future work will be able to avoid relying on obfuscated gradients (and other methods that only prevent gradient descent-based attacks) for perceived robustness, and use our evaluation approach to detect when this occurs. Defending against adversarial examples is an important area of research and we believe performing a careful, thorough evaluation is a critical step that can not be overlooked when designing defenses."
        },
        {
            "heading": "Acknowledgements",
            "text": "We are grateful to Aleksander Madry, Andrew Ilyas, and Aditi Raghunathan for helpful comments on an early draft of this paper. We thank Bo Li, Xingjun Ma, Laurens van der Maaten, Aurko Roy, Yang Song, and Cihang Xie for useful discussion and insights on their defenses.\nThis work was partially supported by the National Science Foundation through award CNS-1514457, Qualcomm, and the Hewlett Foundation through the Center for Long-Term Cybersecurity."
        },
        {
            "heading": "A. Local Intrinsic Dimensionality",
            "text": "Defense Details. The Local Intrinsic Dimensionality (Amsaleg et al., 2015) \u201cassesses the space-filling capability of the region surrounding a reference example, based on the distance distribution of the example to its neighbors\u201d (Ma et al., 2018). The authors present evidence that the LID is significantly larger for adversarial examples generated by existing attacks than for normal images, and they construct a classifier that can distinguish these adversarial images from normal images. Again, the authors indicate that LID is not intended as a defense and only should be used to explore properties of adversarial examples. However, it would be natural to wonder whether it would be effective as a defense, so we study its robustness; our results confirm that it is not adequate as a defense. The method used to compute the LID relies on finding the k nearest neighbors, a nondifferentiable operation, rendering gradient descent based methods ineffective.\nLet S be a mini-batch of N clean examples. Let ri(x) denote the distance (under metric d(x, y)) between sample x and its i-th nearest neighbor in S (under metric d). Then LID can be approximated by\nLIDd(x) = \u2212\n( 1\nk k\u2211 i=1 log ri(x) rk(x) )\u22121 where k is a defense hyperparameter the controls the number of nearest neighbors to consider. The authors use the distance function\ndj(x, y) = \u2225\u2225f1..j(x)\u2212 f1..j(y)\u2225\u2225 2\nto measure the distance between the jth activation layers. The authors compute a vector of LID values for each sample:\n\u2212\u2212\u2192 LID(x) = {LIDdj (x)}nj=1.\nFinally, they compute the \u2212\u2212\u2192 LID(x) over the training data and adversarial examples generated on the training data, and train a logistic regression classifier to detect adversarial examples. We are grateful to the authors for releasing their complete source code.\nDiscussion. While LID is not a defense itself, the authors assess the ability of LID to detect different types of attacks.\nThrough solving the formulation\nmin. |x\u2212 x\u2032|22 + \u03b1 (`(x\u2032) + LID-loss(x\u2032))\nthe authors attempt to determine if the LID metric is a good metric for detecting adversarial examples. Here, LID-loss(\u00b7) is a function that can be minimized to reduce the LID score. However, the authors report that this modified attack still\nachieves 0% success. Because Carlini and Wagner\u2019s `2 attack is unbounded, any time the attack does not reach 100% success indicates that the attack became stuck in a local minima. When this happens, it is often possible to slightly modify the loss function and return to 100% attack success (Carlini & Wagner, 2017b).\nIn this case, we observe the reason that performing this type of adaptive attack fails is that gradient descent does not succeed in optimizing the LID loss, even though the LID computation is differentiable. Computing the LID term involves computing the k-nearest neighbors when computing ri(x). Minimizing the gradient of the distance to the current k-nearest neighbors is not representative of the true direction to travel in for the optimal set of k-nearest neighbors. As a consequence, we find that adversarial examples generated with gradient methods when penalizing for a high LID either (a) are not adversarial; or (b) are detected as adversarial, despite penalizing for the LID loss.\nEvaluation. We now evaluate what would happen if a defense would directly apply LID to detect adversarial examples. Instead of performing gradient descent over a term that is difficult to differentiate through, we have found that generating high confidence adversarial examples (Carlini & Wagner, 2017a) (completely oblivious to to the detector) is sufficient to fool this detector. We obtain from the authors their detector trained on both the Carlini and Wagner\u2019s `2 attack and train our own on the Fast Gradient Sign attack, both of which were found to be effective at detecting adversarial examples generated by other methods. By generating high-confidence adversarial examples minimizing `\u221e distortion, we are able to reduce model accuracy to 2% success within = 0.015. LID reports these adversarial examples are benign at a 97% rate (unmodified test data is flagged as benign with a 98% rate).\nThis evaluation demonstrates that the LID metric can be circumvented, and future work should carefully evaluate if building a detector relying on LID is robust to adversarial examples explicitly targeting such a detector. This work also raises questions whether a large LID is a fundamental characteristic of all adversarial examples, or whether it is a by-product of certain attacks."
        },
        {
            "heading": "B. Defense-GAN",
            "text": "Defense Details. The defender first trains a Generative Adversarial Network with a generator G(z) that maps samples from a latent space (typically z \u223c N (0, 1)) to images that look like training data. Defense-GAN takes a trained classifier f(\u00b7), and to classify an input x, instead of returning f(x), returns f(arg minz |G(z)\u2212 x|). To perform this projection to the manifold, the authors take many steps of gradient descent starting from different random initializa-\ntions.\nDefense-GAN was not shown to be effective on CIFAR-10. We therefore evaluate it on MNIST (where it was argued to be secure).\nDiscussion. In Samangouei et al. (2018), the authors construct a white-box attack by unrolling the gradient descent used during classification. Despite an unbounded `2 perturbation size, Carlini and Wagner\u2019s attack only reaches 30% misclassification rate on the most vulnerable model and under 5% on the strongest. This leads us to believe that unrolling gradient descent breaks gradients.\nEvaluation. We find that adversarial examples do exist on the data manifold as described by the generator G(\u00b7). However, Defense-GAN does not completely project to the projection of the generator, and therefore often does not identify these adversarial examples actually on the manifold.\nWe therefore present two evaluations. In the first, we assume that Defense-GAN were to able to perfectly project to the data manifold, and give a construction for generating adversarial examples. In the second, we take the actual implementation of Defense-GAN as it is, and perform BPDA to generate adversarial examples with 50% success under reasonable `2 bounds.\nEvaluation A. Performing the manifold projection is nontrivial as an inner optimization step when generating adversarial examples. To sidestep this difficulty, we show that adversarial examples exist directly on the projection of the generator. That is, we construct an adversarial example x\u2032 = G(z\u2217) so that |x\u2212 x\u2032| is small and c(x) 6= c(x\u2032).\nTo do this, we solve the re-parameterized formulation\nmin. \u2016G(z)\u2212 x\u201622 + c \u00b7 `(G(z)).\nWe initialize z = arg minz |G(z)\u2212x| (also found via gradient descent). We train a WGAN using the code the authors provide (Gulrajani et al., 2017), and a MNIST CNN to 99.3% accuracy.\nWe run for 50k iterations of gradient descent for generating each adversarial example; this takes under one minute per instance. The unsecured classifier requires a mean `2 distortion of 0.0019 (per-pixel normalized, 1.45 un-normalized) to fool. When we mount our attack, we require a mean distortion of 0.0027, an increase in distortion of 1.46\u00d7; see Figure 2 for examples of adversarial examples. The reason our attacks succeed with 100% success without suffering from vanishing or exploding gradients is that our gradient computation only needs to differentiate through the generator G(\u00b7) once.\nConcurrent to our work, Ilyas et al. (2017) also develop a nearly identical approach to Defense-GAN; they also find it is vulnerable to the attack we outline above, but increase the robustness further with adversarial training. We do not evaluate this extended approach.\nEvaluation B. The above attack does not succeed on Defense-GAN. While the adversarial examples are directly on the projection of the Generator, the projection process will actually move it off the projection.\nTo mount an attack on the approximate projection process, we use the BPDA attack regularized for `2 distortion. Our attack approach is identical to that of PixelDefend, except we replace the manifold projection with a PixelCNN with the manifold projection by gradient descent on the GAN. Under these settings, we succeed at reducing model accuracy to 55% with a maximum normalized distortion of .0051 for successful attacks."
        }
    ],
    "title": "Obfuscated Gradients Give a False Sense of Security: Circumventing Defenses to Adversarial Examples",
    "year": 2018
}