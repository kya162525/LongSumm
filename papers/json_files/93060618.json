{
    "abstractText": "We present a highly accurate single-image superresolution (SR) method. Our method uses a very deep convolutional network inspired by VGG-net used for ImageNet classification [19]. We find increasing our network depth shows a significant improvement in accuracy. Our final model uses 20 weight layers. By cascading small filters many times in a deep network structure, contextual information over large image regions is exploited in an efficient way. With very deep networks, however, convergence speed becomes a critical issue during training. We propose a simple yet effective training procedure. We learn residuals only and use extremely high learning rates (10 times higher than SRCNN [6]) enabled by adjustable gradient clipping. Our proposed method performs better than existing methods in accuracy and visual improvements in our results are easily noticeable.",
    "authors": [
        {
            "affiliations": [],
            "name": "Jiwon Kim"
        },
        {
            "affiliations": [],
            "name": "Jung Kwon Lee"
        },
        {
            "affiliations": [],
            "name": "Kyoung Mu Lee"
        }
    ],
    "id": "SP:39c3ba33f6ec8f9de36f0a8461c5f78e4f911d98",
    "references": [
        {
            "authors": [
                "Y. Bengio",
                "I.J. Goodfellow",
                "A. Courville"
            ],
            "title": "Deep learning",
            "venue": "Book in preparation for MIT Press",
            "year": 2015
        },
        {
            "authors": [
                "Y. Bengio",
                "P. Simard",
                "P. Frasconi"
            ],
            "title": "Learning long-term dependencies with gradient descent is difficult",
            "venue": "Neural Networks, IEEE Transactions on, 5(2):157\u2013166",
            "year": 1994
        },
        {
            "authors": [
                "M. Bevilacqua",
                "A. Roumy",
                "C. Guillemot",
                "M.-L. Morel"
            ],
            "title": "Super-resolution using neighbor embedding of backprojection residuals",
            "venue": "Digital Signal Processing (DSP), 2013 18th International Conference on, pages 1\u20138. IEEE",
            "year": 2013
        },
        {
            "authors": [
                "H. Chang",
                "D.-Y. Yeung",
                "Y. Xiong"
            ],
            "title": "Super-resolution through neighbor embedding",
            "venue": "CVPR",
            "year": 2004
        },
        {
            "authors": [
                "C. Dong",
                "C.C. Loy",
                "K. He",
                "X. Tang"
            ],
            "title": "Learning a deep convolutional network for image super-resolution",
            "venue": "In ECCV",
            "year": 2014
        },
        {
            "authors": [
                "C. Dong",
                "C.C. Loy",
                "K. He",
                "X. Tang"
            ],
            "title": "Image superresolution using deep convolutional networks",
            "venue": "TPAMI",
            "year": 2015
        },
        {
            "authors": [
                "C.E. Duchon"
            ],
            "title": "Lanczos filtering in one and two dimensions",
            "venue": "Journal of Applied Meteorology, 18(8):1016\u20131022",
            "year": 1979
        },
        {
            "authors": [
                "W.T. Freeman",
                "E.C. Pasztor",
                "O.T. Carmichael"
            ],
            "title": "Learning low-level vision",
            "venue": "International journal of computer vision, 40(1):25\u201347",
            "year": 2000
        },
        {
            "authors": [
                "D. Glasner",
                "S. Bagon",
                "M. Irani"
            ],
            "title": "Super-resolution from a single image",
            "venue": "ICCV",
            "year": 2009
        },
        {
            "authors": [
                "K. He",
                "X. Zhang",
                "S. Ren",
                "J. Sun"
            ],
            "title": "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification",
            "venue": "CoRR, abs/1502.01852",
            "year": 2015
        },
        {
            "authors": [
                "J.-B. Huang",
                "A. Singh",
                "N. Ahuja"
            ],
            "title": "Single image superresolution using transformed self-exemplars",
            "venue": "CVPR",
            "year": 2015
        },
        {
            "authors": [
                "M. Irani",
                "S. Peleg"
            ],
            "title": "Improving resolution by image registration",
            "venue": "CVGIP: Graphical models and image processing, 53(3):231\u2013239",
            "year": 1991
        },
        {
            "authors": [
                "K.I. Kim",
                "Y. Kwon"
            ],
            "title": "Single-image super-resolution using sparse regression and natural image prior",
            "venue": "TPAMI",
            "year": 2010
        },
        {
            "authors": [
                "Y. LeCun",
                "L. Bottou",
                "Y. Bengio",
                "P. Haffner"
            ],
            "title": "Gradientbased learning applied to document recognition",
            "venue": "Proceedings of the IEEE, 86(11):2278\u20132324",
            "year": 1998
        },
        {
            "authors": [
                "C.G. Marco Bevilacqua",
                "Aline Roumy",
                "M.-L.A. Morel"
            ],
            "title": "Low-complexity single-image super-resolution based on nonnegative neighbor embedding",
            "venue": "In BMVC,",
            "year": 2012
        },
        {
            "authors": [
                "D. Martin",
                "C. Fowlkes",
                "D. Tal",
                "J. Malik"
            ],
            "title": "A database of human segmented natural images and its application to evaluating segmentation algorithms and measuring ecological statistics",
            "venue": "ICCV",
            "year": 2001
        },
        {
            "authors": [
                "R. Pascanu",
                "T. Mikolov",
                "Y. Bengio"
            ],
            "title": "On the difficulty of training recurrent neural networks",
            "venue": "ICML",
            "year": 2013
        },
        {
            "authors": [
                "S. Schulter",
                "C. Leistner",
                "H. Bischof"
            ],
            "title": "Fast and accurate image upscaling with super-resolution forests",
            "venue": "CVPR",
            "year": 2015
        },
        {
            "authors": [
                "K. Simonyan",
                "A. Zisserman"
            ],
            "title": "Very deep convolutional networks for large-scale image recognition",
            "venue": "ICLR",
            "year": 2015
        },
        {
            "authors": [
                "J. Sun",
                "Z. Xu",
                "H.-Y. Shum"
            ],
            "title": "Image super-resolution using gradient profile prior",
            "venue": "CVPR",
            "year": 2008
        },
        {
            "authors": [
                "R. Timofte",
                "V. De",
                "L.V. Gool"
            ],
            "title": "Anchored neighborhood regression for fast example-based super-resolution",
            "venue": "ICCV",
            "year": 2013
        },
        {
            "authors": [
                "R. Timofte",
                "V. De Smet",
                "L. Van Gool"
            ],
            "title": "A+: Adjusted anchored neighborhood regression for fast super-resolution",
            "venue": "ACCV",
            "year": 2014
        },
        {
            "authors": [
                "A. Vedaldi",
                "K. Lenc"
            ],
            "title": "Matconvnet \u2013 convolutional neural networks for matlab",
            "venue": "CoRR, abs/1412.4564",
            "year": 2014
        },
        {
            "authors": [
                "C.-Y. Yang",
                "M.-H. Yang"
            ],
            "title": "Fast direct super-resolution by simple functions",
            "venue": "ICCV",
            "year": 2013
        },
        {
            "authors": [
                "J. Yang",
                "J. Wright",
                "T.S. Huang",
                "Y. Ma"
            ],
            "title": "Image superresolution via sparse representation",
            "venue": "TIP",
            "year": 2010
        },
        {
            "authors": [
                "R. Zeyde",
                "M. Elad",
                "M. Protter"
            ],
            "title": "On single image scale-up using sparse-representations",
            "venue": "Curves and Surfaces, pages 711\u2013730. Springer",
            "year": 2012
        }
    ],
    "sections": [
        {
            "heading": "1. Introduction",
            "text": "We address the problem of generating a high-resolution (HR) image given a low-resolution (LR) image, commonly referred as single image super-resolution (SISR) [12], [8], [9]. SISR is widely used in computer vision applications ranging from security and surveillance imaging to medical imaging where more image details are required on demand.\nMany SISR methods have been studied in the computer vision community. Early methods include interpolation such as bicubic interpolation and Lanczos resampling [7] more powerful methods utilizing statistical image priors [20, 13] or internal patch recurrence [9].\nCurrently, learning methods are widely used to model a mapping from LR to HR patches. Neighbor embedding [4, 15] methods interpolate the patch subspace. Sparse coding [25, 26, 21, 22] methods use a learned compact dictionary based on sparse signal representation. Lately, random forest [18] and convolutional neural network (CNN) [6] have also been used with large improvements in accuracy.\nAmong them, Dong et al. [6] has demonstrated that a CNN can be used to learn a mapping from LR to HR in an\nend-to-end manner. Their method, termed SRCNN, does not require any engineered features that are typically necessary in other methods [25, 26, 21, 22] and shows the stateof-the-art performance.\nWhile SRCNN successfully introduced a deep learning technique into the super-resolution (SR) problem, we find its limitations in three aspects: first, it relies on the context of small image regions; second, training converges too slowly; third, the network only works for a single scale.\nIn this work, we propose a new method to practically resolve the issues.\nContext We utilize contextual information spread over very large image regions. For a large scale factor, it is often the case that information contained in a small patch is not sufficient for detail recovery (ill-posed). Our very deep network using large receptive field takes a large image context into account.\nConvergence We suggest a way to speed-up the training: residual-learning CNN and extremely high learning rates. As LR image and HR image share the same information to a large extent, explicitly modelling the residual image, which is the difference between HR and LR images, is advantageous. We propose a network structure for effi-\n1\nar X\niv :1\n51 1.\n04 58\n7v 2\n[ cs\n.C V\n] 1\n1 N\nov 2\n01 6\ncient learning when input and output are highly correlated. Moreover, our initial learning rate is 104 times higher than that of SRCNN [6]. This is enabled by residual-learning and gradient clipping.\nScale Factor We propose a single-model SR approach. Scales are typically user-specified and can be arbitrary including fractions. For example, one might need smooth zoom-in in an image viewer or resizing to a specific dimension. Training and storing many scale-dependent models in preparation for all possible scenarios is impractical. We find a single convolutional network is sufficient for multi-scalefactor super-resolution.\nContribution In summary, in this work, we propose a highly accurate SR method based on a very deep convolutional network. Very deep networks converge too slowly if small learning rates are used. Boosting convergence rate with high learning rates lead to exploding gradients and we resolve the issue with residual-learning and gradient clipping. In addition, we extend our work to cope with multiscale SR problem in a single network. Our method is relatively accurate and fast in comparison to state-of-the-art methods as illustrated in Figure 1."
        },
        {
            "heading": "2. Related Work",
            "text": "SRCNN is a representative state-of-art method for deep learning-based SR approach. So, let us analyze and compare it with our proposed method."
        },
        {
            "heading": "2.1. Convolutional Network for Image SuperResolution",
            "text": "Model SRCNN consists of three layers: patch extraction/representation, non-linear mapping and reconstruction. Filters of spatial sizes 9 \u00d7 9, 1 \u00d7 1, and 5 \u00d7 5 were used respectively.\nIn [6], Dong et al. attempted to prepare deeper models, but failed to observe superior performance after a week of training. In some cases, deeper models gave inferior performance. They conclude that deeper networks do not result in better performance (Figure 9).\nHowever, we argue that increasing depth significantly boosts performance. We successfully use 20 weight layers (3 \u00d7 3 for each layer). Our network is very deep (20 vs. 3 [6]) and information used for reconstruction (receptive field) is much larger (41\u00d7 41 vs. 13\u00d7 13).\nTraining For training, SRCNN directly models highresolution images. A high-resolution image can be decomposed into a low frequency information (corresponding to low-resolution image) and high frequency information (residual image or image details). Input and output images share the same low-frequency information. This indicates that SRCNN serves two purposes: carrying the input to the end layer and reconstructing residuals. Carrying the input to the end is conceptually similar to what an auto-encoder\ndoes. Training time might be spent on learning this autoencoder so that the convergence rate of learning the other part (image details) is significantly decreased. In contrast, since our network models the residual images directly, we can have much faster convergence with even better accuracy.\nScale As in most existing SR methods, SRCNN is trained for a single scale factor and is supposed to work only with the specified scale. Thus, if a new scale is on demand, a new model has to be trained. To cope with multiple scale SR (possibly including fractional factors), we need to construct individual single scale SR system for each scale of interest.\nHowever, preparing many individual machines for all possible scenarios to cope with multiple scales is inefficient and impractical. In this work, we design and train a single network to handle multiple scale SR problem efficiently. This turns out to work very well. Our single machine is compared favorably to a single-scale expert for the given sub-task. For three scales factors (\u00d72, 3, 4), we can reduce the number of parameters by three-fold.\nIn addition to the aforementioned issues, there are some minor differences. Our output image has the same size as the input image by padding zeros every layer during training whereas output from SRCNN is smaller than the input. Finally, we simply use the same learning rates for all layers while SRCNN uses different learning rates for different layers in order to achieve stable convergence."
        },
        {
            "heading": "3. Proposed Method",
            "text": ""
        },
        {
            "heading": "3.1. Proposed Network",
            "text": "For SR image reconstruction, we use a very deep convolutional network inspired by Simonyan and Zisserman [19]. The configuration is outlined in Figure 2. We use d layers where layers except the first and the last are of the same type: 64 filter of the size 3\u00d7 3\u00d7 64, where a filter operates on 3 \u00d7 3 spatial region across 64 channels (feature maps). The first layer operates on the input image. The last layer, used for image reconstruction, consists of a single filter of size 3\u00d7 3\u00d7 64.\nThe network takes an interpolated low-resolution image (to the desired size) as input and predicts image details. Modelling image details is often used in super-resolution methods [21, 22, 15, 3] and we find that CNN-based methods can benefit from this domain-specific knowledge.\nIn this work, we demonstrate that explicitly modelling image details (residuals) has several advantages. These are further discussed later in Section 4.2.\nOne problem with using a very deep network to predict dense outputs is that the size of the feature map gets reduced every time convolution operations are applied. For example, when an input of size (n+1)\u00d7(n+1) is applied to a network\nwith receptive field size n\u00d7 n, the output image is 1\u00d7 1. This is in accordance with other super-resolution methods since many require surrounding pixels to infer center pixels correctly. This center-surround relation is useful since the surrounding region provides more constraints to this ill-posed problem (SR). For pixels near the image boundary, this relation cannot be exploited to the full extent and many SR methods crop the result image.\nThis methodology, however, is not valid if the required surround region is very big. After cropping, the final image is too small to be visually pleasing.\nTo resolve this issue, we pad zeros before convolutions to keep the sizes of all feature maps (including the output image) the same. It turns out that zero-padding works surprisingly well. For this reason, our method differs from most other methods in the sense that pixels near the image boundary are also correctly predicted.\nOnce image details are predicted, they are added back to the input ILR image to give the final image (HR). We use this structure for all experiments in our work."
        },
        {
            "heading": "3.2. Training",
            "text": "We now describe the objective to minimize in order to find optimal parameters of our model. Let x denote an interpolated low-resolution image and y a high-resolution image. Given a training dataset {x(i),y(i)}Ni=1, our goal is to learn a model f that predicts values y\u0302 = f(x), where y\u0302 is an estimate of the target HR image. We minimize the mean\nsquared error 12 ||y \u2212 f(x)|| 2 averaged over the training set is minimized. Residual-Learning In SRCNN, the exact copy of the input has to go through all layers until it reaches the output layer. With many weight layers, this becomes an end-toend relation requiring very long-term memory. For this reason, the vanishing/exploding gradients problem [2] can be critical. We can solve this problem simply with residuallearning.\nAs the input and output images are largely similar, we define a residual image r = y \u2212 x, where most values are likely to be zero or small. We want to predict this residual image. The loss function now becomes 12 ||r \u2212 f(x)||\n2, where f(x) is the network prediction.\nIn networks, this is reflected in the loss layer as follows. Our loss layer takes three inputs: residual estimate, network input (ILR image) and ground truth HR image. The loss is computed as the Euclidean distance between the reconstructed image (the sum of network input and output) and ground truth.\nTraining is carried out by optimizing the regression objective using mini-batch gradient descent based on backpropagation (LeCun et al. [14]). We set the momentum parameter to 0.9. The training is regularized by weight decay (L2 penalty multiplied by 0.0001).\nHigh Learning Rates for Very Deep Networks Training deep models can fail to converge in realistic limit of time. SRCNN [6] fails to show superior performance with\nmore than three weight layers. While there can be various reasons, one possibility is that they stopped their training procedure before networks converged. Their learning rate 10\u22125 is too small for a network to converge within a week on a common GPU. Looking at Fig. 9 of [6], it is not easy to say their deeper networks have converged and their performances were saturated. While more training will eventually resolve the issue, but increasing depth to 20 does not seems practical with SRCNN.\nIt is a basic rule of thumb to make learning rate high to boost training. But simply setting learning rate high can also lead to vanishing/exploding gradients [2]. For the reason, we suggest an adjustable gradient clipping for maximal boost in speed while suppressing exploding gradients.\nAdjustable Gradient Clipping Gradient clipping is a technique that is often used in training recurrent neural networks [17]. But, to our knowledge, its usage is limited in training CNNs. While there exist many ways to limit gradients, one of the common strategies is to clip individual gradients to the predefined range [\u2212\u03b8, \u03b8].\nWith clipping, gradients are in a certain range. With stochastic gradient descent commonly used for training, learning rate is multiplied to adjust the step size. If high learning rate is used, it is likely that \u03b8 is tuned to be small to avoid exploding gradients in a high learning rate regime. But as learning rate is annealed to get smaller, the effective gradient (gradient multiplied by learning rate) approaches zero and training can take exponentially many iterations to converge if learning rate is decreased geometrically.\nFor maximal speed of convergence, we clip the gradients to [\u2212 \u03b8\u03b3 , \u03b8 \u03b3 ], where \u03b3 denotes the current learning rate. We find the adjustable gradient clipping makes our convergence procedure extremely fast. Our 20-layer network training is done within 4 hours whereas 3-layer SRCNN takes several days to train.\nMulti-Scale While very deep models can boost performance, more parameters are now needed to define a network. Typically, one network is created for each scale factor. Considering that fractional scale factors are often used, we need an economical way to store and retrieve networks.\nFor this reason, we also train a multi-scale model. With this approach, parameters are shared across all predefined scale factors. Training a multi-scale model is straightforward. Training datasets for several specified scales are combined into one big dataset.\nData preparation is similar to SRCNN [5] with some differences. Input patch size is now equal to the size of the receptive field and images are divided into sub-images with no overlap. A mini-batch consists of 64 sub-images, where sub-images from different scales can be in the same batch.\nWe implement our model using the MatConvNet1 package [23].\n1http://www.vlfeat.org/matconvnet/"
        },
        {
            "heading": "4. Understanding Properties",
            "text": "In this section, we study three properties of our proposed method. First, we show that large depth is necessary for the task of SR. A very deep network utilizes more contextual information in an image and models complex functions with many nonlinear layers. We experimentally verify that deeper networks give better performances than shallow ones.\nSecond, we show that our residual-learning network converges much faster than the standard CNN. Moreover, our network gives a significant boost in performance.\nThird, we show that our method with a single network performs as well as a method using multiple networks trained for each scale. We can effectively reduce model capacity (the number of parameters) of multi-network approaches."
        },
        {
            "heading": "4.1. The Deeper, the Better",
            "text": "Convolutional neural networks exploit spatially-local correlation by enforcing a local connectivity pattern between neurons of adjacent layers [1]. In other words, hidden units in layerm take as input a subset of units in layerm\u22121. They form spatially contiguous receptive fields.\nEach hidden unit is unresponsive to variations outside of the receptive field with respect to the input. The architecture thus ensures that the learned filters produce the strongest response to a spatially local input pattern.\nHowever, stacking many such layers leads to filters that become increasingly global (i.e. responsive to a larger region of pixel space). In other words, a filter of very large support can be effectively decomposed into a series of small\nfilters. In this work, we use filters of the same size, 3\u00d73, for all layers. For the first layer, the receptive field is of size 3\u00d73. For the next layers, the size of the receptive field increases by 2 in both height and width. For depth D network, the receptive field has size (2D + 1) \u00d7 (2D + 1). Its size is proportional to the depth.\nIn the task of SR, this corresponds to the amount of contextual information that can be exploited to infer highfrequency components. A large receptive field means the network can use more context to predict image details. As SR is an ill-posed inverse problem, collecting and analyzing more neighbor pixels give more clues. For example, if there are some image patterns entirely contained in a receptive field, it is plausible that this pattern is recognized and used to super-resolve the image.\nIn addition, very deep networks can exploit high nonlinearities. We use 19 rectified linear units and our networks can model very complex functions with moderate number of channels (neurons). The advantages of making a thin deep network is well explained in Simonyan and Zisserman\n[19]. We now experimentally show that very deep networks significantly improve SR performance. We train and test networks of depth ranging from 5 to 20 (only counting weight layers excluding nonlinearity layers). In Figure 3, we show the results. In most cases, performance increases as depth increases. As depth increases, performance improves rapidly."
        },
        {
            "heading": "4.2. Residual-Learning",
            "text": "As we already have a low-resolution image as the input, predicting high-frequency components is enough for the purpose of SR. Although the concept of predicting residuals has been used in previous methods [21, 22, 26], it has not been studied in the context of deep-learning-based SR framework.\nIn this work, we have proposed a network structure that learns residual images. We now study the effect of this modification to a standard CNN structure in detail.\nFirst, we find that this residual network converges much faster. Two networks are compared experimentally: the\nresidual network and the standard non-residual network. We use depth 10 (weight layers) and scale factor 2. Performance curves for various learning rates are shown in Figure 4. All use the same learning rate scheduling mechanism that has been mentioned above.\nSecond, at convergence, the residual network shows superior performance. In Figure 4, residual networks give higher PSNR when training is done.\nAnother remark is that if small learning rates are used, networks do not converge in the given number of epochs. If initial learning rate 0.1 is used, PSNR of a residual-learning network reaches 36.90 within 10 epochs. But if 0.001 is used instead, the network never reaches the same level of performance (its performance is 36.52 after 80 epochs). In a similar manner, residual and non-residual networks show dramatic performance gaps after 10 epochs (36.90 vs. 27.42 for rate 0.1).\nIn short, this simple modification to a standard nonresidual network structure is very powerful and one can explore the validity of the idea in other image restoration problems where input and output images are highly correlated."
        },
        {
            "heading": "4.3. Single Model for Multiple Scales",
            "text": "Scale augmentation during training is a key technique to equip a network with super-resolution machines of multi-\nple scales. Many SR processes for different scales can be executed with our multi-scale machine with much smaller capacity than that of single-scale machines combined.\nWe start with an interesting experiment as follows: we train our network with a single scale factor strain and it is tested under another scale factor stest. Here, factors 2,3 and 4 that are widely used in SR comparisons are considered. Possible pairs (strain,stest) are tried for the dataset \u2018Set5\u2019 [15]. Experimental results are summarized in Table 2.\nPerformance is degraded if strain 6= stest. For scale factor 2, the model trained with factor 2 gives PSNR of 37.10 (in dB), whereas models trained with factor 3 and 4 give 30.05 and 28.13, respectively. A network trained over single-scale data is not capable of handling other scales. In many tests, it is even worse than bicubic interpolation, the method used for generating the input image.\nWe now test if a model trained with scale augmentation is capable of performing SR at multiple scale factors. The same network used above is trained with multiple scale factors strain = {2, 3, 4}. In addition, we experiment with the cases strain = {2, 3}, {2, 4}, {3, 4} for more comparisons.\nWe observe that the network copes with any scale used during training. When strain = {2, 3, 4} (\u00d72, 3, 4 in Table 2), its PSNR for each scale is comparable to those achieved from the corresponding result of single-scale net-\nwork: 37.06 vs. 37.10 (\u00d72), 33.27 vs. 32.89 (\u00d73), 30.95 vs. 30.86 (\u00d74).\nAnother pattern is that for large scales (\u00d73, 4), our multiscale network outperforms single-scale network: our model (\u00d72, 3), (\u00d73, 4) and (\u00d72, 3, 4) give PSNRs 33.22, 33.24 and 33.27 for test scale 3, respectively, whereas (\u00d73) gives 32.89. Similarly, (\u00d72, 4), (\u00d73, 4) and (\u00d72, 3, 4) give 30.86, 30.94 and 30.95 (vs. 30.84 by \u00d74 model), respectively. From this, we observe that training multiple scales boosts the performance for large scales."
        },
        {
            "heading": "5. Experimental Results",
            "text": "In this section, we evaluate the performance of our method on several datasets. We first describe datasets used for training and testing our method. Next, parameters necessary for training are given.\nAfter outlining our experimental setup, we compare our method with several state-of-the-art SISR methods."
        },
        {
            "heading": "5.1. Datasets for Training and Testing",
            "text": "Training dataset Different learning-based methods use different training images. For example, RFL [18] has two methods, where the first one uses 91 images from Yang et al. [25] and the second one uses 291 images with the addition of 200 images from Berkeley Segmentation Dataset [16]. SRCNN [6] uses a very large ImageNet dataset.\nWe use 291 images as in [18] for benchmark with other methods in this section. In addition, data augmentation (rotation or flip) is used. For results in previous sections, we used 91 images to train network fast, so performances can be slightly different.\nTest dataset For benchmark, we use four datasets. Datasets \u2018Set5\u2019 [15] and \u2018Set14\u2019 [26] are often used for benchmark in other works [22, 21, 5]. Dataset \u2018Urban100\u2019, a dataset of urban images recently provided by Huang et al. [11], is very interesting as it contains many challenging images failed by many of the existing methods. Finally, dataset \u2018B100\u2019, natural images in the Berkeley Segmentation Dataset used in Timofte et al. [22] and Yang and Yang [24] for benchmark, is also employed."
        },
        {
            "heading": "5.2. Training Parameters",
            "text": "We provide parameters used to train our final model. We use a network of depth 20. Training uses batches of size 64. Momentum and weight decay parameters are set to 0.9 and 0.0001, respectively.\nFor weight initialization, we use the method described in He et al. [10]. This is a theoretically sound procedure for networks utilizing rectified linear units (ReLu).\nWe train all experiments over 80 epochs (9960 iterations with batch size 64). Learning rate was initially set to 0.1 and then decreased by a factor of 10 every 20 epochs. In total,\nthe learning rate was decreased 3 times, and the learning is stopped after 80 epochs. Training takes roughly 4 hours on GPU Titan Z."
        },
        {
            "heading": "5.3. Benchmark",
            "text": "For benchmark, we follow the publicly available framework of Huang et al. [21]. It enables the comparison of many state-of-the-art results with the same evaluation procedure.\nThe framework applies bicubic interpolation to color components of an image and sophisticated models to luminance components as in other methods [4], [9], [26]. This is because human vision is more sensitive to details in intensity than in color.\nThis framework crops pixels near image boundary. For our method, this procedure is unnecessary as our network outputs the full-sized image. For fair comparison, however, we also crop pixels to the same amount."
        },
        {
            "heading": "5.4. Comparisons with State-of-the-Art Methods",
            "text": "We provide quantitative and qualitative comparisons. Compared methods are A+ [22], RFL[18], SelfEx [11] and SRCNN [5]. In Table 3, we provide a summary of quantitative evaluation on several datasets. Our methods outperform all previous methods in these datasets. Moreover, our methods are relatively fast. The public code of SRCNN based on a CPU implementation is slower than the code used by Dong et. al [6] in their paper based on a GPU implementation.\nIn Figures 6 and 7, we compare our method with topperforming methods. In Figure 6, only our method perfectly reconstructs the line in the middle. Similarly, in Figure 7, contours are clean and vivid in our method whereas they are severely blurred or distorted in other methods."
        },
        {
            "heading": "6. Conclusion",
            "text": "In this work, we have presented a super-resolution method using very deep networks. Training a very deep network is hard due to a slow convergence rate. We use residual-learning and extremely high learning rates to optimize a very deep network fast. Convergence speed is maximized and we use gradient clipping to ensure the training stability. We have demonstrated that our method outperforms the existing method by a large margin on benchmarked images. We believe our approach is readily applicable to other image restoration problems such as denoising and compression artifact removal."
        }
    ],
    "title": "Accurate Image Super-Resolution Using Very Deep Convolutional Networks",
    "year": 2016
}