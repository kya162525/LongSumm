{
    "abstractText": "Early detection is the key to minimizing failure damage induced by configuration errors, especially those errors in configurations that control failure handling and fault tolerance. Since such configurations are not needed for initialization, many systems do not check their settings early (e.g., at startup time). Consequently, the errors become latent until their manifestations cause severe damage, such as breaking the failure handling. Such latent errors are likely to escape from sysadmins\u2019 observation and testing, and be deployed to production at scale. Our study shows that many of today\u2019s mature, widelyused software systems are subject to latent configuration errors (referred to as LC errors) in their critically important configurations\u2014those related to the system\u2019s reliability, availability, and serviceability. One root cause is that many (14.0%\u201393.2%) of these configurations do not have any special code for checking the correctness of their settings at the system\u2019s initialization time. To help software systems detect LC errors early, we present a tool named PCHECK that analyzes the source code and automatically generates configuration checking code (called checkers). The checkers emulate the late execution that uses configuration values, and detect LC errors if the error manifestations are captured during the emulated execution. Our results show that PCHECK can help systems detect 75+% of real-world LC errors at the initialization phase, including 37 new LC errors that have not been exposed before. Compared with existing detection tools, it can detect 31% more LC errors.",
    "authors": [
        {
            "affiliations": [],
            "name": "Tianyin Xu"
        },
        {
            "affiliations": [],
            "name": "Xinxin Jin"
        },
        {
            "affiliations": [],
            "name": "Peng Huang"
        },
        {
            "affiliations": [],
            "name": "Yuanyuan Zhou"
        },
        {
            "affiliations": [],
            "name": "Shan Lu"
        },
        {
            "affiliations": [],
            "name": "Long Jin"
        },
        {
            "affiliations": [],
            "name": "Shankar Pasupathy"
        }
    ],
    "id": "SP:ef4dcdfb805374e8c44568eb7f3d451341f47863",
    "references": [
        {
            "authors": [
                "M. ATTARIYAN",
                "M. CHOW",
                "J. FLINN"
            ],
            "title": "X-ray: Automating Root-Cause Diagnosis of Performance Anomalies in Production Software",
            "venue": "In Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2012
        },
        {
            "authors": [
                "M. ATTARIYAN",
                "J. FLINN"
            ],
            "title": "Automating Configuration Troubleshooting with Dynamic Information Flow Analysis",
            "venue": "In Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2010
        },
        {
            "authors": [
                "L.A. BARROSO",
                "U. H\u00d6LZLE"
            ],
            "title": "The Datacenter as a Computer: An Introduction to the Design of Warehousescale Machines",
            "year": 2009
        },
        {
            "authors": [
                "F. BEHRANG",
                "M.B. COHEN",
                "A. ORSO"
            ],
            "title": "Users Beware: Preference Inconsistencies Ahead",
            "venue": "In Proceedings of the 10th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering (ES- EC/FSE\u201915) (Bergamo,",
            "year": 2015
        },
        {
            "authors": [
                "J. BRODKIN"
            ],
            "title": "Why Gmail went down: Google misconfigured load balancing servers. http://arstechnica",
            "year": 2012
        },
        {
            "authors": [
                "L. FANG",
                "K. NGUYEN",
                "G. XU",
                "B. DEMSKY",
                "LU"
            ],
            "title": "Interruptible Tasks: Treating Memory Pressure As Interrupts for Highly Scalable Data-Parallel Programs",
            "venue": "In Proceedings of the 25th Symposium on Operating System Principles",
            "year": 2015
        },
        {
            "authors": [
                "H.S. GUNAWI",
                "M. HAO",
                "T. LEESATAPORNWONGSA",
                "T. PATANA-ANAKE",
                "T. DO",
                "J. ADITYATAMA",
                "K.J. ELI- AZAR",
                "A. LAKSONO",
                "J.F. LUKMAN",
                "V. MAR- TIN",
                "A.D. SATRIA"
            ],
            "title": "What Bugs Live in the Cloud? A Study of 3000+ Issues in Cloud Systems",
            "venue": "In Proceedings of the 5th ACM Symposium on Cloud Computing",
            "year": 2014
        },
        {
            "authors": [
                "P. HUANG"
            ],
            "title": "Understanding and Dealing with Failures in Cloud-Scale Systems",
            "venue": "PhD thesis, University of California San Diego, Computer Science and Engineering,",
            "year": 2016
        },
        {
            "authors": [
                "W. JIANG",
                "C. HU",
                "S. PASUPATHY",
                "A. KANEVSKY",
                "Z. LI",
                "Y. ZHOU"
            ],
            "title": "Understanding Customer Problem Troubleshooting from Storage System Logs",
            "venue": "In Proceedings of the 7th USENIX Conference on File and Storage Technologies",
            "year": 2009
        },
        {
            "authors": [
                "D. JIN",
                "M.B. COHEN",
                "X. QU",
                "B. ROBINSON"
            ],
            "title": "PrefFinder: Getting the Right Preference in Configurable Software Systems",
            "venue": "In Proceedings of the 29th IEEE/ACM International Conference on Automated Software Engineering (ASE\u201914) (Va\u0308stera\u030as,",
            "year": 2014
        },
        {
            "authors": [
                "L. KELLER",
                "P. UPADHYAYA",
                "G. CANDEA"
            ],
            "title": "ConfErr: A Tool for Assessing Resilience to Human Configuration Errors",
            "venue": "In Proceedings of the 38th Annual IEEE/IFIP International Conference on Dependable Systems and Networks",
            "year": 2008
        },
        {
            "authors": [
                "B. MAURER"
            ],
            "title": "Fail at Scale: Reliability in the Face of Rapid Change",
            "venue": "Communications of the ACM 58,",
            "year": 2015
        },
        {
            "authors": [
                "A. MOSKOWITZ"
            ],
            "title": "Software Testing for Sysadmin Programs",
            "venue": "USENIX ;login: 40,",
            "year": 2015
        },
        {
            "authors": [
                "D. OPPENHEIMER",
                "A. GANAPATHI",
                "D.A. PATTER- SON"
            ],
            "title": "Why Do Internet Services Fail, and What Can Be Done About It",
            "venue": "In Proceedings of the 4th USENIX Symposium on Internet Technologies and Systems",
            "year": 2003
        },
        {
            "authors": [
                "N. PALATIN",
                "A. LEIZAROWITZ",
                "A. SCHUSTER",
                "R. WOLFF"
            ],
            "title": "Mining for Misconfigured Machines in Grid Systems",
            "venue": "In Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining",
            "year": 2006
        },
        {
            "authors": [
                "D. PATTERSON",
                "A. BROWN",
                "P. BROADWELL",
                "G. CAN- DEA",
                "M. CHEN",
                "J. CUTLER",
                "P. ENRIQUEZ",
                "A. FOX",
                "E. KICIMAN",
                "M. MERZBACHER",
                "D. OPPENHEIMER",
                "N. SASTRY",
                "W. TETZLAFF",
                "J. TRAUPMAN",
                "N. TREUHAFT"
            ],
            "title": "Recovery-Oriented Computing (ROC): Motivation, Definition, Techniques, and Case Studies",
            "venue": "Tech. Rep. UCB//CSD-02-1175,",
            "year": 2002
        },
        {
            "authors": [
                "R. POTHARAJU",
                "J. CHAN",
                "L. HU",
                "C. NITA-ROTARU",
                "M. WANG",
                "L. ZHANG",
                "N. JAIN"
            ],
            "title": "ConfSeer: Leveraging Customer Support Knowledge Bases for Automated Misconfiguration Detection",
            "venue": "In Proceedings of the 35th International Conference on Very Large Data Bases",
            "year": 2015
        },
        {
            "authors": [
                "A. RABKIN",
                "R. KATZ"
            ],
            "title": "Precomputing Possible Configuration Error Diagnosis",
            "venue": "In Proceedings of the 26th IEEE/ACM International Conference on Automated Software Engineering",
            "year": 2011
        },
        {
            "authors": [
                "A. RABKIN",
                "R. KATZ"
            ],
            "title": "Static Extraction of Program Configuration Options",
            "venue": "In Proceedings of the 33th International Conference on Software Engineering",
            "year": 2011
        },
        {
            "authors": [
                "A. RABKIN",
                "R. KATZ"
            ],
            "title": "How Hadoop Clusters Break",
            "venue": "IEEE Software Magazine 30,",
            "year": 2013
        },
        {
            "authors": [
                "A.S. RABKIN"
            ],
            "title": "Using Program Analysis to Reduce Misconfiguration in Open Source Systems Software",
            "venue": "PhD thesis,",
            "year": 2012
        },
        {
            "authors": [
                "M. SANTOLUCITO",
                "E. ZHAI",
                "R. PISKAC"
            ],
            "title": "Probabilistic Automated Language Learning for Configuration Files",
            "venue": "In 28th International Conference on Computer Aided Verification (CAV\u201916) (Toronto,",
            "year": 2016
        },
        {
            "authors": [
                "M. SRIDHARAN",
                "S.J. FINK",
                "R. BOD\u00cdK"
            ],
            "title": "Thin Slicing",
            "venue": "In Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation",
            "year": 2007
        },
        {
            "authors": [
                "Y. SVERDLIK"
            ],
            "title": "Microsoft: Misconfigured Network Device Led to Azure Outage",
            "venue": "http://www. datacenterdynamics.com/focus/archive/2012/ 07/microsoft-misconfigured-network-deviceled-azure-outage,",
            "year": 2012
        },
        {
            "authors": [
                "C. TANG",
                "T. KOOBURAT",
                "P. VENKATACHALAM",
                "A. CHANDER",
                "Z. WEN",
                "A. NARAYANAN",
                "P. DOWELL",
                "R. KARL"
            ],
            "title": "Holistic Configuration Management at Facebook",
            "venue": "In Proceedings of the 25th Symposium on Operating System Principles",
            "year": 2015
        },
        {
            "authors": [
                "H.J. WANG",
                "J.C. PLATT",
                "Y. CHEN",
                "R. ZHANG",
                "WANG",
                "Y.-M"
            ],
            "title": "Automatic Misconfiguration Troubleshooting with PeerPressure",
            "venue": "In Proceedings of the 6th USENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 633 USENIX Conference on Operating Systems Design and Implementation",
            "year": 2004
        },
        {
            "authors": [
                "X. WANG",
                "N. ZELDOVICH",
                "M.F. KAASHOEK",
                "A. SOLAR-LEZAMA"
            ],
            "title": "Towards optimization-safe systems: Analyzing the impact of undefined behavior",
            "venue": "In Proceedings of the 24th Symposium on Operating System Principles",
            "year": 2013
        },
        {
            "authors": [
                "WANG",
                "Y.-M",
                "C. VERBOWSKI",
                "J. DUNAGAN",
                "Y. CHEN",
                "H.J. WANG",
                "C. YUAN",
                "Z. ZHANG"
            ],
            "title": "STRIDER: A Black-box, State-based Approach to Change and Configuration Management and Support",
            "venue": "In Proceedings of the 17th Large Installation Systems Administration Conference",
            "year": 2003
        },
        {
            "authors": [
                "A. WHITAKER",
                "R.S. COX",
                "S.D. GRIBBLE"
            ],
            "title": "Configuration Debugging as Search: Finding the Needle in the Haystack",
            "venue": "In Proceedings of the 6th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2004
        },
        {
            "authors": [
                "WIKIPEDIA. Reliability"
            ],
            "title": "availability and serviceability (computing)",
            "venue": "https://en.wikipedia. org/wiki/Reliability,_availability_and_ serviceability_(computing)",
            "year": 2010
        },
        {
            "authors": [
                "T. XU",
                "J. ZHANG",
                "P. HUANG",
                "J. ZHENG",
                "T. SHENG",
                "D. YUAN",
                "Y. ZHOU",
                "S. PASUPATHY"
            ],
            "title": "Do Not Blame Users for Misconfigurations",
            "venue": "In Proceedings of the 24th Symposium on Operating System Principles",
            "year": 2013
        },
        {
            "authors": [
                "T. XU",
                "Y. ZHOU"
            ],
            "title": "Systems Approaches to Tackling Configuration Errors: A Survey",
            "venue": "ACM Computing Surveys (CSUR) 47,",
            "year": 2015
        },
        {
            "authors": [
                "Z. YIN",
                "X. MA",
                "J. ZHENG",
                "Y. ZHOU",
                "L.N. BAIRAVA- SUNDARAM",
                "S. PASUPATHY"
            ],
            "title": "An Empirical Study on Configuration Errors in Commercial and Open Source Systems",
            "venue": "In Proceedings of the 23rd ACM Symposium on Operating Systems Principles",
            "year": 2011
        },
        {
            "authors": [
                "C. YUAN",
                "N. LAO",
                "WEN",
                "LI J.-R",
                "Z. ZHANG",
                "WANG",
                "Y.-M",
                "MA",
                "W.-Y"
            ],
            "title": "Automated Known Problem Diagnosis with Event Traces",
            "venue": "In Proceedings of the 1st EuroSys Conference",
            "year": 2006
        },
        {
            "authors": [
                "D. YUAN",
                "Y. XIE",
                "R. PANIGRAHY",
                "J. YANG",
                "C. VER- BOWSKI",
                "A. KUMAR"
            ],
            "title": "Context-based Online Configuration Error Detection",
            "venue": "In Proceedings of 2011 USENIX Annual Technical Conference (USENIX ATC\u201911) (Portland, OR,",
            "year": 2011
        },
        {
            "authors": [
                "E. ZHAI",
                "R. CHEN",
                "D.I. WOLINSKY",
                "B. FORD"
            ],
            "title": "Heading Off Correlated Failures through Independenceas-a-Service",
            "venue": "In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation",
            "year": 2014
        },
        {
            "authors": [
                "J. ZHANG",
                "L. RENGANARAYANA",
                "X. ZHANG",
                "N. GE",
                "V. BALA",
                "T. XU",
                "Y. ZHOU"
            ],
            "title": "EnCore: Exploiting System Environment and Correlation Information for Misconfiguration Detection",
            "venue": "In Proceedings of the 19th International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS\u201914)",
            "year": 2014
        },
        {
            "authors": [
                "S. ZHANG",
                "M.D. ERNST"
            ],
            "title": "Automated Diagnosis of Software Conguration Errors",
            "venue": "In Proceedings of the 35th International Conference on Software Engineering",
            "year": 2013
        },
        {
            "authors": [
                "S. ZHANG",
                "M.D. ERNST"
            ],
            "title": "Which Configuration Option Should I Change",
            "venue": "In Proceedings of the 36th International Conference on Software Engineering",
            "year": 2014
        },
        {
            "authors": [
                "S. ZHANG",
                "M.D. ERNST"
            ],
            "title": "Proactive Detection of Inadequate Diagnostic Messages for Software Configuration Errors",
            "venue": "In Proceedings of the 2015 International Symposium on Software Testing and Analysis",
            "year": 2015
        }
    ],
    "sections": [
        {
            "text": "induced by configuration errors, especially those errors in configurations that control failure handling and fault tolerance. Since such configurations are not needed for initialization, many systems do not check their settings early (e.g., at startup time). Consequently, the errors become latent until their manifestations cause severe damage, such as breaking the failure handling. Such latent errors are likely to escape from sysadmins\u2019 observation and testing, and be deployed to production at scale.\nOur study shows that many of today\u2019s mature, widelyused software systems are subject to latent configuration errors (referred to as LC errors) in their critically important configurations\u2014those related to the system\u2019s reliability, availability, and serviceability. One root cause is that many (14.0%\u201393.2%) of these configurations do not have any special code for checking the correctness of their settings at the system\u2019s initialization time.\nTo help software systems detect LC errors early, we present a tool named PCHECK that analyzes the source code and automatically generates configuration checking code (called checkers). The checkers emulate the late execution that uses configuration values, and detect LC errors if the error manifestations are captured during the emulated execution. Our results show that PCHECK can help systems detect 75+% of real-world LC errors at the initialization phase, including 37 new LC errors that have not been exposed before. Compared with existing detection tools, it can detect 31% more LC errors."
        },
        {
            "heading": "1 Introduction",
            "text": ""
        },
        {
            "heading": "1.1 Motivation",
            "text": "Failures are a fact of life in today\u2019s large-scale, rapidchanging systems in cloud and data centers [7,24,30,58]. To mitigate the impact of failures, tolerance and recovery mechanisms have been widely adopted, such as employing data and node redundancy, as well as supporting fast rebooting and rollback. While these mechanisms are successful in handling individual machine failures (e.g., hardware faults and memory bugs), they are less effective in handling configuration errors [20, 24, 28], especially the errors in configurations that control the failure han-\ndling itself. For example, an erroneous fail-over configuration resulted in a 2.5 hour outage of Google App Engine in 2010, affecting millions of end users [44]. Moreover, very often, the same configuration error is deployed onto thousands of nodes and resides in persistent files on each node, making it hard to tolerate by redundancy or server rebooting. As a result, configuration errors have become one of the major causes of failures in large-scale cloud and Internet systems, as reported by many system vendors [21, 34, 55] and service providers [7, 24, 28, 43].\nSince it is hard to completely avoid configuration errors (after all, everyone makes mistakes; as do system administrators), similar to fatal diseases like cancer, a more practical approach is to detect such errors as early as possible in order to minimize their failure damage:\n\u2022 Early detection before configuration roll-out can pre-\nvent the same error from being replicated to thousands of nodes, especially in the data-center environment.\n\u2022 Unlike software bugs, configuration errors, once de-\ntected, can be fixed by sysadmins themselves with no need to go through developers. Therefore, if detected earlier, the errors can be corrected immediately before the configurations are put online for production.\n\u2022 For many configurations that control the system\u2019s fail-\nure handling, early detection of errors in their settings can prevent the system from entering an unrecoverable state (before any failures happen). Often, the combination of multiple errors (e.g., a configuration error plus a software bug) can bring down the entire service, as shown in many newsworthy outages [9, 42, 43, 45].\nUnlike software bugs that typically go through various kinds of testing before releases (such as unit testing, regression testing, stress testing, system testing, etc.), system administrators often do not perform extensive testing on configurations before rolling them out to other nodes and putting the systems online [25]. Besides the lack of skills [25] and the temptation of convenience [24], the more fundamental reason is that system administrators do not have the same level of understanding on how and when the system uses each configuration value internally. Thus, they are limited to simple black-box testing such as starting the system and applying a few small workloads to see how the system behaves. Due to time and knowledge limitations, system administrators typically do not\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 619\nperform a comprehensive suite of test cases against configuration settings, especially for those hard-to-test ones (e.g., failure/error-handling related configurations) that may require complex setups and even fault injections.\nTherefore, early detection should inevitably fall onto the shoulder of the system itself\u2014the system should automatically check as many configurations as possible at its early stages (the startup time). Unfortunately, many of today\u2019s systems either skip the checking or only check configurations right before the configuration values are used, as shown in our study (\u00a72). Typically, at the startup time, only those configuration parameters needed for initialization are checked (or directly used), while many other parameters\u2019 checking is delayed much later until when they are used in special tasks. Since such configuration parameters are neither used nor checked during normal operations, errors in their settings go undetected until their late manifestation, e.g., under circumstances like error handling and fail-over. For simplicity, we refer to such errors as latent configuration (LC) errors.\nLC errors can result in severe failures, as they are often associated with configurations used to control critical situations such as fail-over [44], error handling [42], backup [37], load balancing [9], mirroring [45], etc. As explained above, their detection or exposure is often too late to limit the failure damage. Take a real-world case as an example (c.f., \u00a72: Figure 3a), an LC error in the fail-over configuration settings is detected only when the system encounters a failure (e.g., due to hardware faults or software bugs) and tries to fail-over to another component. In this case, the fail-over attempt also fails, making the entire system unavailable to all the clients.\nTables 1 and 2 compare the severity level and diagnosis time of real-world configuration issues caused by LC errors versus non-latent configuration errors (detected at the system\u2019s startup time) of COMP-A1, a major storage company in the US. Although there have been fewer LC errors than non-latent ones, LC errors contribute to 75% of the high-severity issues and take much longer to diagnose, indicating their high impact and damage.\n1We are required to keep the company and its products anonymous.\nFigure 1 shows a real-world LC error from Squid, a widely used open-source Web proxy server. The LC error resided in diskd program, a configuration parameter used only during log rotation. Squid did not check the configuration during initialization; thus, this error was exposed much later after days of execution. It caused 7+ hours of system downtime and cost 48 hours of diagnosis efforts. After the error was finally discerned, the Squid developers added a patch to proactively check the setting at system startup time to prevent such latent failures.\nFigure 2 shows another real-world example in which an LC error failed a large-scale MapReduce job processing. This LC error was replicated to multiple nodes and crashed the TaskTrackers on those nodes. Specifically, the error caused a runtime exception on each node. The TaskTracker caught the exception and restarted the job. Unfortunately, as the error is persistent in the configuration file, restarting the job failed to get rid of the error but induced infinite loops. Note that when the exception handler caught the error, it was already too late to avoid downtime (the best choice is to terminate the jobs).\nPreventing above LC-error issues would require software systems to check configurations early during the initialization time, even though the configuration values are only needed in much later execution or during special\n620 12th USENIX Symposium on Operating Systems Design and Implementation USENIX Association\ncircumstances. This is indeed demonstrated by the developers\u2019 postmortem patches. As revealed in Facebook\u2019s recent study [43], 42% of the configuration errors that caused high-impact incidents are \u201cobvious\u201d errors (e.g., typos), indicating the limitations of code review and system testing in preventing LC errors. These errors might be detected by early checks (only if developers are willing to and remember to write the checking code)."
        },
        {
            "heading": "1.2 State of the Art",
            "text": "Most prior work on handling configuration errors focuses on troubleshooting and diagnosis [5, 6, 32, 46, 48, 49, 52, 53,56,60,61,62]. The techniques proposed in these work are helpful for system administrators to identify the failure root causes faster to shorten the repair time. However, they cannot prevent failures and downtime.\nMost of the existing detection tools check configuration settings against apriori correctness rules (known as constraints). However, as large software systems usually have hundreds to thousands of configuration parameters, it is time-consuming and error-prone to ask developers to manually specify every single constraint, not to mention that constraints change with software evolution [61].\nSo far, only a few automatic configuration-error detection tools have been proposed. Most of them detect errors by learning the \u201cnormal\u201d values from large collections of configuration settings in the field [29,36,57,59]. While these techniques are effective in certain scenarios, they have the following limitations, especially when being applied to cloud and data centers.\nFirst, most of these works require a large collection of independent configuration settings from hundreds of machines. This is a rather strong requirement, as most cloud and data centers typically propagate the same configurations from one node to all the other nodes. Thereby, the settings from these nodes are not independent, and thus not useful for \u201clearning\u201d. Second, they do not work well with configurations that are inherently different from one system to another (e.g., domain names, file paths, IP addresses) or incorrect settings that fall in normal ranges. They also cannot differentiate customized settings from erroneous ones. Furthermore, most of these tools target on specific error types (encoded by their predefined constraint templates) and are hard to generalize to detect other types of errors. A recent work learns constraints from KB (Knowledge Base) articles [31]. However, this approach has the same limitations discussed above. Specially, KB articles are mainly served for postmortem diagnosis and thus may not cover every single constraint.\nThere are very few configuration-error detection approaches that do not rely on constraints specified manually by developers or learned from large collections of independent settings (or KB articles). The only exception\n(to the best of our knowledge) is conf spellchecker [35] which detects simple errors based on type inference from source code. While this technique is very practical, it is limited in the types of configuration errors that can be detected, as shown in our experimental evaluation (\u00a74)."
        },
        {
            "heading": "1.3 Our Contributions",
            "text": "This paper makes two main contributions. First, to understand the root causes and characteristics of latent configuration (LC) errors, we study the practices of configuration checking in six mature, widely-deployed software systems (HDFS, YARN, HBase, Apache, MySQL, and Squid). Our study reveals: (1) In today\u2019s software systems, many (14.0%\u201393.2%) of the critically important configuration parameters (those related to the system\u2019s reliability, availability, and serviceability) do not have any special code for checking the correctness of their settings. Instead, the correctness is verified (implicitly) when the configuration values are being actually used in operations such as a file open call. (2) Many (12.0%\u2013 38.6%) of these configuration parameters are not used at all during system initialization. (3) Resulting from (1) and (2), 4.7%\u201338.6% of these critically important configuration parameters do not have any early checks and are thereby subject to LC errors that can cause severe impact on the system\u2019s dependability.\nSecond, to help systems detect LC errors early, we present a tool named PCHECK that analyzes the source code and automatically generates configuration checking code (called checkers) to validate the system\u2019s configuration settings at the initialization phase. PCHECK takes a unique and intuitive method to check each configuration setting\u2014emulating the late execution that uses the configuration value; meanwhile capturing any anomalies exposed during the execution as the evidence of configuration errors. PCHECK does not require developers to manually implement checking logic, nor rely on learning a large volume of configuration data. The checkers generated by PCHECK are generic: they are not limited to any specific, predefined rule patterns, but are derived from how the program uses the parameters.\nPCHECK shows that it is feasible to accurately and safely emulate late execution that uses configurations. It statically extracts the instructions that transform, propagate, and use the configuration values from the system program. To execute these instructions, PCHECK makes a best effort to produce the necessary execution context (values of dependent variables) that can be determined statically. PCHECK also \u201csandboxes\u201d the emulated execution by instruction rewriting to prevent side effects on the running system or its environment.\nMore importantly, emulating the execution can expose many configuration errors as runtime anomalies (e.g., ex-\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 621\nceptions and error code) and the emulated execution runs in a short period. PCHECK inserts instructions to capture the anomalies that may occur during the emulated execution, as the evidence to report configuration errors.\nAs an enforcement, PCHECK encapsulates the emulated execution and error capturing code into checkers for every configuration parameter, and invokes the checkers at the system\u2019s initialization phase. This can minimize potential LC errors, and compensate for the missing and incomplete configuration checks in real-world systems.\nWe implement PCHECK for C and Java programs on top of the LLVM [4] and Soot [3] compiler frameworks. We apply PCHECK to 58 real-world LC errors of various error types occurred in widely-used systems (each leads to severe failure damage), including 37 new LC errors that have not been exposed before. Our results show that PCHECK can detect 75+% of these real-world LC errors at the system\u2019s startup time. Compared with the existing detection tools, it can detect 31% more LC errors."
        },
        {
            "heading": "2 Understanding Root Causes of Latent Configuration Errors",
            "text": "To understand the root causes and characteristics of LC errors, we study the practices of the configuration checking and error detection in six mature, widely-deployed open-source software systems (c.f., Table 3). They cover multiple functionalities and languages, and include both single-machine and distributed systems.\nWe focus on configuration parameters used in components related to the system\u2019s Reliability, Availability, and Serviceability (known as RAS for short [50]). For each system considered, we select all the configuration parameters of RAS-related features based on the software\u2019s official documents, including error handling, fail-over, data backup, recovery, error logging and notification, etc. The last column of Table 3 shows the number of the studied RAS parameters. Compared with configurations of other system components, configurations used by RAS components are more likely to be subject to LC errors due to their inherently latent nature; moreover, the impact of errors in RAS configurations is usually more severe.\nNote: LC errors are not limited to RAS components. Thus, the reported numbers may not represent the overall statistics of all the LC errors in the studied systems. In addition, PCHECK, the tool presented in \u00a73, applies to all the configuration parameters; it does not require manual efforts to select out RAS parameters."
        },
        {
            "heading": "2.1 Methodology",
            "text": "We manually inspect the source code related to RAS configuration parameters of the studied systems. First, for each RAS parameter, we study the code that checks the\nparameter setting at the system\u2019s initialization phase2 (if any) and the code that later uses the parameter\u2019s value. Then, we compare these two sets of code (checking versus usage) and examine if the initial checking is sufficient to detect configuration errors. If an error can escape from the initialization phase and break the usage code, it is a potential LC error.\nWe verify each LC error discovered from source code by exposing and observing the impact of the error. We first inject the errors into the system\u2019s configuration files and launch the system; then we trigger the manifestation conditions to expose the error impact. For example, to verify the LC errors in the HDFS auto-failover feature, we start HDFS with the erroneous fail-over settings, trigger the fail-over procedure by killing the active NameNode, and examine if the fail-over can succeed. As all the LC errors are verified through their manifestation, there is no false positive in the reported numbers."
        },
        {
            "heading": "2.2 Findings",
            "text": "Finding 1: Many (14.0%\u201393.2%) of the studied RAS parameters do not have any special code for checking the correctness of their settings. Instead, the correctness is verified (implicitly) when the parameters\u2019 values are actually used in operations such as a file open call.\nTable 4 shows the number of the studied RAS parameters that rely on the usage code for verifying correctness, because their initial checks are either missing or incomplete. Most of the studied RAS parameters in HDFS, YARN, and HBase do not have any special code for checking the correctness of their settings. These systems\n2A system\u2019s initialization phase is defined from its entry point to the\npoint it starts to serve user requests or workloads.\n622 12th USENIX Symposium on Operating Systems Design and Implementation USENIX Association\nadopt the lazy practice of using configuration values3\u2014 parsing and consuming configuration settings only when the values are immediately needed for the operations, without any systematic configuration checking at the system\u2019s initialization phase.\nWith such a practice, even trivial errors could result in big impact on the system\u2019s dependability. Figure 3a exemplifies such cases using the new LC errors we discovered in our study. In HDFS, any LC errors (such as a na\u0131\u0308ve type error) in the auto-failover configurations could\n3This is a bad but commonly adopted practice in Java and Python programs which rely on libraries (e.g., java.util.Properties and configparser) to directly retrieve and use configuration values from configuration files on demand, without systematic early checks.\nbreak the fail-over procedure upon the NameNode failures (as the values are not checked or used early), making the entire HDFS service become unavailable.\nApache, MySQL, and Squid all apply specific configuration checking procedures at initialization, mainly for checking data types and data ranges. However, for more complicated parameters, some checking is incomplete. Figure 3b shows another new LC error we discovered. In this case, though the initial checking code covers file existence and types, it misses other constraints such as file permissions. This leaves Apache subject to permissionrelated LC errors (which is reported as one common cause of core-dump failures upon server crash [41]).\nAs shown by Figure 3b, one configuration parameter could have multiple subtle constraints depending on how the system uses its value. For example, a configured file path used by chdir has different constraints from files accessed by open; even for files accessed by the same open call, different flags (e.g., O RDONLY versus O CREAT) would result in different constraints. Implementing code to check such constraints is tedious and error-prone.\nFinding 2: Many (12.0%\u201338.6%) of the studied RAS configuration parameters are not used at all during the system\u2019s initialization phase.\nTable 5 counts the studied configuration parameters that are not used at the system\u2019s initialization phase, but are consumed directly in late execution (e.g., when dealing with failures). Figure 3a is such an example. Since all these parameters are from RAS features, it is natural for their usage to come late on demand.\nSome Java programs put the checking or usage code of the parameters in the class constructors, so that the errors can be exposed when the class objects are created (specially, this is used as the practice for quickly fixing LC errors [18,19,54]). However, this may not fundamentally avoid LC errors if the class objects are not created during the system\u2019s initialization phase.\nNote: RAS configurations can be implemented with early usage at the system\u2019s initialization phase. As shown in Table 5, the majority of RAS configurations are indeed used during initializaiton. For example, all the studied systems choose to open error-log files at initialization time, rather than waiting until they have to print the error messages to the log files upon failures.\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 623\nFinding 3: Resulting from Findings 1 and 2, 4.7%\u2013"
        },
        {
            "heading": "38.6% of the studied RAS parameters do not have any early checks and are thereby subject to LC errors which can cause severe impact on the system\u2019s dependability.",
            "text": "Table 6 shows the number of the RAS configuration parameters that are subject to LC errors in each studied system. The threats are prevalent: LC errors can reside in 10+% of the RAS parameters in five out of six systems. As all these LC errors are discovered in the latest versions, any of them could appear in real deployment and would impair the system\u2019s dependability in a latent fashion. Such prevalence of LC errors indicates the need for tool support to systematically rule out the threats.\nAmong the studied systems, HDFS and YARN have a particularly high percentage of RAS parameters subject to LC errors, due to their lazy evaluation of configuration values (refer to Finding 1 for details). HBase applies the same lazy practice as HDFS and YARN, but has fewer parameters subject to LC errors, because most of its RAS parameters are used during its initialization. We also find LC errors in the other studied systems, despite their initial configuration checking efforts."
        },
        {
            "heading": "2.3 Implication",
            "text": "In summary, even mature software systems are subject to LC errors due to the deficiency of configuration checking at the initialization time. While relying on developers\u2019 discipline to add more checking code can help, the reality often fails our expectations, because implementing configuration checking code is tedious and error-prone.\nFortunately, we also observe from the study that except for explicit configuration checking code, the actual usage of configuration values (which already exists in source code) can serve as an implicit form of checking, for example, opening a file path that comes from a configuration value implies a capability check. Such usageimplied checking is often more complete and accurate than the explicit checkers written by developers, because it precisely captures how the configuration values should be used in the actual program execution. Sadly, in reality these usage-implied checking is rarely leveraged to detect LC errors, because the usage often comes too late\nto be useful. A natural question regarding the solution to LC errors is: can we automatically generate configuration checking code from the existing source code that uses configuration values?"
        },
        {
            "heading": "3 PCHECK Design and Implementation",
            "text": "PCHECK is a tool for enabling early detection of configuration errors for a given systems program. The objective of PCHECK is to automatically generate configuration checking code (called checkers) based on the original program, and invoke them at the system initialization phase, in order to detect LC errors.\nPCHECK tries to generate checkers for every configuration parameter. It is not specific to RAS configurations and has no assumption on the existence of any LC errors. The checker of a parameter emulates how the system uses the parameter\u2019s value in the original execution, and captures anomalies exposed during the emulated execution as the evidence of configuration errors.\nPCHECK is built on top of the Soot [3] and LLVM [4] compiler frameworks and works for both Java and C system programs. PCHECK works on the intermediate representations (IR) of the programs (LLVM IR or Soot Jimple). It takes the original IR as inputs, and outputs the generated checkers, and inserts them into bitcode/bytecode files (which are then built into native binaries). This may require prepending the build process by replacing the compiler front-end with Soot or Clang [47].\nPCHECK faces three major challenges: (1) How to automatically emulate the execution that uses configuration values? (2) Since the checkers will be inserted into the original program and will run in the same address space, how does one make the emulation safe without incurring side effects on the system\u2019s internal state and external environment? (3) How to capture anomalies during the emulated execution as the evidence of configuration errors (the emulation alone cannot directly report errors)?\nTo address the first challenge, PCHECK extracts the instructions that transform, propagate, and use the value of every configuration parameter using a static taint tracking method. PCHECK then makes a best effort to produce the context (values of dependent variables) necessary for emulating the execution. The extracted instructions, together with the context, are encapsulated in a checker.\nFor the second challenge, PCHECK \u201csandboxes\u201d the auto-generated checkers by rewriting instructions that would cause side effects. PCHECK avoids modifications to global variables by copying their values to local ones, and rewrites the instructions that may have external side effects on the underlying OS.\nTo address the third challenge, PCHECK leverages system- and language-level error identifiers (including runtime exceptions, system-call error codes, and abnor-\n624 12th USENIX Symposium on Operating Systems Design and Implementation USENIX Association\nmal program exits) to capture the anomalies exposed during the emulation, and report configuration errors.\nFigure 4 illustrates PCHECK\u2019s checker generation for a MySQL configuration parameter, log error, which is subject to LC errors [26]. PCHECK extracts the instructions that use the configuration value and determines the values of the other dependent variables (e.g., mode) as the context. To prevent side effects, it rewrites some call instruction. It detects errors based on the return value.\nLastly, PCHECK inserts the generated checkers into the system program, and invokes these checkers at the end of the system initialization phase (annotated by developers). To detect TOCTTOU errors4, PCHECK supports running checkers periodically in a separate thread.\nUsage. PCHECK requires two inputs from developers: (1) specifications of the configuration interface to help PCHECK identify the initial program variables that store configuration values, as the starting points for analysis (\u00a73.1.1); (2) annotations of the system\u2019s initialization phase where the early checkers will be invoked (\u00a73.4).\nIn addition, PCHECK provides the tuning interface for developers to select and remove any generated checkers, as per their preference and criteria (e.g., after standard\n4A TOCTTOU (Time-Of-Check-To-Time-Of-Use) error occurs after the checking phase and before the use phase, e.g., inadvertently deleting a file that had been checked early but will be used later on.\nsoftware testing of the enhanced system programs). Similarly, PCHECK provides an operational interface that allows sysadmins to enable/disable the invocation of the checkers of any specific parameters in operation."
        },
        {
            "heading": "3.1 Emulating Execution",
            "text": "To emulate the execution that uses a configuration parameter, PCHECK first identifies instructions that load the parameter\u2019s value into program variables (\u00a73.1.1). Starting from there, PCHECK performs forward static taint analysis to extract all the instructions whose execution uses the parameter\u2019s value, and hence are the candidates to be included in the checkers (\u00a73.1.2). It then analyzes backwards to figure out the values of dependent variables in these instructions, as the execution context (\u00a73.1.3). Finally, PCHECK composes checkers using the above instructions and their context (\u00a73.1.4).\nNote that the emulation does not need to include the conditions under which the configurations are used. Instead, it focuses on executing the instructions that consume the configuration values\u2014the goal is to check if using the configuration would cause any anomalies when its value is needed. With this design, PCHECK is able to effectively handle large, non-deterministic software programs, without the need to inject/simulate hard-to-trigger error conditions under which LC errors are exposed."
        },
        {
            "heading": "3.1.1 Identifying Starting Points",
            "text": "As the configuration-consuming execution always starts from loading the configuration value, PCHECK needs to identify the program variables that initially store the value of each parameter, as the starting points.\nPCHECK adopts the common practices presented in previous work [8,22,32,33,52,60,61] to obtain the mapping from configuration parameters to the corresponding variables. The basic idea is to let developers specify the interface5 for retrieving configuration values, and then automatically identify program variables that load the values based on the interface. As pointed out by [52], most mature systems have uniform configuration interfaces for the ease of code maintenance. For instance, to work with HDFS, PCHECK only needs to know the configuration getter functions (e.g., getInt and getString in Figure 3a) declared in a single Java class; identifying them only requires several lines of specifications using regular expressions. In general, specifying interface requires little specification efforts, compared to annotating every single variable for a large number of configuration parameters. In the evaluation, the specifications needed for most systems are less than 10 lines (\u00a74: Table 7).\n5The interface could be APIs, data structures, or parsing functions [52, 35]. It is reported that only three types of interfaces are commonly used to store/retrieve configurations [52, 35].\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 625"
        },
        {
            "heading": "3.1.2 Extracting Instructions Using Configurations",
            "text": "For each configuration parameter, PCHECK extracts the instructions that propagate, transform, and use the parameter\u2019s value using a static taint tracking method. For a given parameter, the initial taints are the program variables that store the parameter\u2019s value (\u00a73.1.1). The taints are propagated via data-flow dependencies (including assignments, type casts, and arithmetic/string operations), but not through control-flow dependencies to avoid overtainting [39]. All the instructions containing taints are extracted, and will be encapsulated in a checker.\nNote that one parameter could be used in multiple execution paths, and thus have multiple checkers. We explain how multiple checkers are aggregated in \u00a73.1.4.\nOrdinarily, the extracted instructions from data-flow analysis do not include branches. However, if a tainted instruction is used as a branch condition whose branch body encloses other tainted instructions, PCHECK performs additional control-flow analysis to retain the control dependency of these instructions. One pattern is using a configuration value p after a null-pointer check, in the form of, if (p != NULL) { use p; }. PCHECK recovers the conditional branch and ensures that if p\u2019s value is NULL, the instructions using p inside the branch would not be reached. Moreover, PCHECK checks if a tainted branch condition leads to abnormal program states, for which it inserts error-reporting instructions (see \u00a73.3).\nThe taint tracking is inter-procedural, context sensitive, and field sensitive. Inter-procedure is necessary because configuration values are commonly passed through procedure calls, as illustrated in Figure 4. We adopt a summary-based inter-procedural analysis, and assemble the execution based on arguments/returns. PCHECK maintains the call sites; thus it naturally enables context sensitivity which helps produce context by backtracking from callees to callers (c.f., \u00a73.1.3). Field sensitivity is needed as configuration values could be stored in data structures or as class fields. PCHECK scales well for realworld software systems, as configuration-related instructions form a small part of the entire code base. We do not explicitly perform alias analysis (though it is easy to integrate), as configuration variables are seldom aliased."
        },
        {
            "heading": "3.1.3 Producing Execution Context",
            "text": "Some of the extracted instructions that use configuration variables may not be directly executable, if they contain variables that are not defined within the extracted instruction set. To execute such instructions, PCHECK needs to determine the values of these undefined variables (which we refer to as \u201cdependent variables\u201d) in order to produce self-contained context.\nPCHECK will include a variable and the corresponding instructions in the emulated execution, only when this\nvariable\u2019s value stems from configuration values (e.g., path in Figure 4) or can be statically determined along the data-flow paths of the configuration value (e.g., mode and stream in Figure 4). PCHECK does not include dependent variables whose values come from indeterminate global variables, external inputs (from I/O or network operations such as read and recv), values defined out of the scope of the starting point, etc. For such dependent variables, PCHECK removes the instruction that uses them as operands, together with the succeeding instructions. Those variables\u2019 values may not be available during the initialization phase of the system execution; using them would lead to unexpected results.\nTo produce the context, PCHECK backtracks each undefined dependent variable first intra-procedurally and then inter-procedurally (to handle the arguments of procedure calls). The backtracking starts from the instruction that uses the variable as its operand, and stops until either PCHECK successfully determines the value of the variable or gives up (the value is indeterminate). In Figure 4, PCHECK backtracks mode used by the tainted instruction and successfully obtains its value \"a\".\nPCHECK only attempts to produce the minimal context necessary to emulate execution for the purpose of checking. As an optimization, PCHECK is aware of how certain types of instructions will be rewritten in later transformations (e.g., for side-effect prevention, \u00a73.2). In Figure 4\u2019s example, PCHECK knows how the freopen call will be rewritten later. Therefore, it only produces the context of mode which is needed to check the file access; the other dependent variable stream is ignored as it is not needed for the checking.\nSometimes, the dependent variables come from other configuration parameters. PCHECK can capture the relationships among multiple configurations, e.g., one parameter\u2019s value has to be larger or smaller than another\u2019s."
        },
        {
            "heading": "3.1.4 Encapsulation",
            "text": "For each configuration parameter, PCHECK encapsulates the configuration-consuming instructions together with their context into a checker, in the form of a function. PCHECK clones the original instructions and their operands. For local variables used as operands, PCHECK clones a new local variable and replaces the original variable with the new one. If the instructions change global variables, PCHECK generates a corresponding local variable and copies the global variable\u2019s value to the local one (to avoid changing the global program state). When it involves procedure calls, PCHECK inlines the callees.\nHandling multiple execution paths. For configuration parameters whose values are used in multiple distinct execution paths, PCHECK generates multiple checkers and\n626 12th USENIX Symposium on Operating Systems Design and Implementation USENIX Association\naggregates their results. The configuration value is considered erroneous if one of these checkers complains.\nPCHECK needs to pay attention to potential path explosion to avoid generating too many checkers. Fortunately, in our experience, configuration values are usually used in a simple and straightforward way, with only a small number of different execution paths to emulate.6 This makes the PCHECK approach feasible.\nMoreover, PCHECK merges two checkers if they are equivalent or if one is equivalent to a subset of the other. PCHECK does this by canonicalizing and comparing the instructions in the checkers\u2019 function bodies. Additionally, PCHECK merges checkers which start with the same transformation instruction sequence by reusing the intermediate transformation results.\nNote that the checkers with no error identifiers (\u00a73.3) or considered redundant (\u00a73.4) will be abandoned. As shown in \u00a74.4, the number of generated checkers are well bounded, and executing them incurs little overhead."
        },
        {
            "heading": "3.2 Preventing Side Effects",
            "text": "PCHECK ensures that the generated checkers are free of side effects\u2014running the checkers does not change the internal program state beyond the checker function itself, or the external system environment (e.g., filesystems and OSes). Therefore, PCHECK cannot blindly execute the original instructions. For example, if the checker contains instructions that call exec, running the checker would destruct the current process image. Similarly, creating or deleting files is not acceptable, as the filesystem state before and after checking would be inconsistent.\nInternal side effects are prevented by design. PCHECK ensures that each checker only has local effects. As discussed in \u00a73.1.4, PCHECK avoids modifying global variables in the checker function; instead, it copies global variable values to local variables and uses the local ones instead. The checker does not manipulate pointers if the pointed values are indeterminate.\nExternal side effects are mainly derived from certain system and library calls that interact with the external environment (e.g., filesystems and OS states). In order to preserve the checking effectiveness without incurring external side effects, PCHECK rewrites the original call instructions to redirect the calls to predefined check utilities. A check utility models a specific system or library call based on the call semantics. It validates the arguments of the call, but does not actually execute the call. PCHECK implements check utilities for standard APIs and data structures (including system calls, libc functions for C, and Java core packages defined in SDK). The check utilities are implemented as libraries that are\n6The emulated execution paths are not the original execution paths\n(they only include the configuration-related instructions).\neither statically linked into the system\u2019s bitcode (for C programs), or included in the system\u2019s classpath (for Java programs). In Figure 4, the check utility of freopen checks the arguments of the call using access and stat which are free of side effects (the original freopen call will close the file stream specified by the third argument).\nPCHECK skips instructions that read/write file content or send/recv network packets, in order to stay away from external side effects and heavy checking overhead. Instead, PCHECK performs metadata checks for files and reachability checks for network addresses. This helps the generated checkers be safe and efficient, while still being able to catch a majority of real-world LC errors.\nFor any library calls that are not defined in PCHECK or do not have known side effects (e.g., some library calls would invoke external programs/commands), PCHECK defensively removes the call instructions (together with the succeeding instructions) to avoid unexpected effects.\nOne alternative approach to preventing external side effect is to running the checkers inside a sandbox or even a virtual machine at the system initialization phase. This may save the efforts of implementing the check utilies and rewriting system/library call instructions. However, such approach would impair the usability of PCHECK, because it requires additional setups from system administrators in order to run the PCHECK-enhanced program."
        },
        {
            "heading": "3.3 Capturing Anomalies",
            "text": "As the checker emulates the execution that uses the configuration value, anomalies exposed during execution indicate that the value contains errors\u2014the same problem that would occur during real execution. In this case, the checker reports errors and pinpoints the parameter.\nPCHECK captures anomalies based on the following three types of error identifiers: (1) runtime exceptions that disrupt the emulated execution (for Java programs); (2) error code returned by system and library calls (for C programs); and (3) abnormal program termination and error logging that indicate abnormal program states.\nFor Java programs, PCHECK captures runtime anomalies based on Java\u2019s Exception interface, the language\u2019s uniform mechanism for capturing error events. PCHECK places the body of the checker function in a try/catch block. The abnormal execution would throw Exception objects and fall into the catch block. In this case, the checker reports errors and prints the stack traces.\nC programs do not have the uniform error interfaces. Thus, PCHECK leverages the error identifiers defined by specific system/library call semantics, i.e., the return values and errno. For example, if the access call returns -1, it means the call failed when accessing the file (with the reason being encoded in errno). In PCHECK, we predefine the error identifiers for commonly-used system and\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 627\nlibc calls to decide whether a call succeeded or failed. If the call fails, the checker reports configuration errors.\nIn addition to the anomalies exposed by system and library APIs, a program usually contains hints of abnormal program states. Such hints are instructions such as exit, abort, throw, false assertion, error logging, etc. PCHECK treats these hints as one type of anomalies. If an instruction is post-dominated by any anomaly hints, the instruction itself indicates an abnormal state of execution. Thus, PCHECK reports configuration errors when the checker emulates such error instructions. PCHECK records these hints during the code analysis in \u00a73.1.2, and inserts error-reporting instructions into the checker at the corresponding locations.\nPCHECK abandons the checkers that do not contain any of the three types of error identifiers discussed above. In other words, running such checkers cannot expose any explicit anomalies (no evidence of configuration errors)."
        },
        {
            "heading": "3.4 Invoking Early Checkers",
            "text": "Once the checkers are generated, PCHECK inserts call instructions to invoke the checkers at the program locations specified by developers. The expected location is at the end of the system initialization phase to make the checkers the last defense against LC errors.\nFigure 5 shows the locations annotated for PCHECK to invoke the auto-generated checkers for Squid and HDFS. For server systems like Squid, the checkers should be invoked before the server starts to listen and wait for client requests. For distributed systems like HDFS, the checkers should be invoked before the system starts to connect and join the cluster. As all the evaluated systems fall in these two patterns, we believe that specifying the invocation locations is a simple practice for developers.\nSome C programs may change user/group identities. Typically, the program starts as root and then switches to unprivileged users/groups (e.g., nobody) at the end of initialization before handling user requests. In Figure 5, the switch is performed inside mainInitialize. As the checkers are invoked in the end of the initialization, the checking results are not affected by user/group switches.\nTo capture the TOCTTOU errors, PCHECK also supports running the generated checkers periodically in a separate thread. Periodical checking is particularly useful for catching configuration errors that occur after the initial checking (e.g., due to environment changes such as remote host failures and inadvertent file deletion).\nAvoiding redundant checking. PCHECK abandons the redundant checkers which are constructed from instructions that would be executed before reaching the invocation location\u2014any configuration errors reported by such checkers should have already been detected by the sys-\ntem\u2019s built-in checks, or have been exposed when the configuration value is used, before the checker is called.\nCreating standalone checking programs. Another option to invoking the early checkers is to create a standalone checking program comprised of the checkers, and run it when the configuration file changes. This approach eliminates the need to deal with internal side effect; on the other hand, the checking program is still prohibited to have external side effect. Note that the generated checkers start from the instructions that load configuration values (\u00a73.1.1); therefore, the checking program needs to include the procedures that parse configuration files and store configuration values. This is straightforward for the software systems with modularized parsing procedures7, but could be difficult if the parsing procedures cannot be easily decoupled from the initialization phase (the initialization may have external side effects)."
        },
        {
            "heading": "4 Experimental Evaluation",
            "text": ""
        },
        {
            "heading": "4.1 Methodology",
            "text": "We first evaluate the effectiveness of PCHECK using the 37 new LC errors discovered in our study. As discussed in \u00a72, all these new LC errors are from the latest versions of the systems; any of them can impair the corresponding RAS features such as fail-over and error handling.\nAs the design of PCHECK is inspired by the above LC errors, our evaluation contains two more sets of benchmarks to evaluate how PCHECK works beyond these errors. First, we evaluate PCHECK on a distinct set of 21 real-world LC errors that caused system failures in the past. These LC errors are collected from the datasets in prior studies related to configurations [6, 11, 51, 55, 59]; all of them were introduced by real users and caused realworld failures. Some of these cases have different code\n7We implement this approach for HDFS, YARN, and HBase which\nuse modularized getter functions to parse/store configuration values.\n628 12th USENIX Symposium on Operating Systems Design and Implementation USENIX Association\npatterns from the ones we discovered in \u00a72. Table 7 lists the number of these LC errors in each system.\nFurthermore, we apply PCHECK to 830 configuration files of the studied systems (except Squid) collected from the official mailing lists of these systems and online technical forums such as ServerFault and StackOverflow [1]. This simulates the experience of using PCHECK on realworld configuration files (\u00a74.2). Moreover, it helps measure the false positive rate of the checking results (\u00a74.6).\nNote that we evaluate PCHECK upon all types of LC errors, instead of any specific error types. Therefore, the evaluation results indicate the checking effectiveness of PCHECK in terms of all possible LC errors. Table 8 categorizes and exemplifies the LC errors used in the evaluation based on their types.\nAlso, the evaluation does not use synthetic errors generated by mutation or fuzzing tools (e.g., ConfErr [23]). Most of the synthetic errors are not LC errors\u2014they are manifested or detected by the system\u2019s built-in checks at the system\u2019s initialization time. Thus, using such errors would make the results less meaningful to LC errors.\nFor each system, we apply PCHECK to generate the early checkers and insert them in the system\u2019s program. Table 7 lists the setup efforts for the each system evaluated, measured by the lines of specifications for identifying the start points (c.f., \u00a73.1.1) and annotations of the invocation locations (c.f., \u00a73.4). Then, we apply the autogenerated checkers to the configuration files that contain these LC errors. We evaluate the effectiveness of PCHECK based on how many of the real-world LC errors can be reported by the auto-generated checkers.\nWe compare the checking results of PCHECK with conf spellchecker [2, 35], a state-of-the-art static configuration checking tool built on top of automatic type inference of configuration values [33, 35]. For each defined type, conf spellchecker implements corresponding checking functions which are invoked to check the validity of the configuration settings."
        },
        {
            "heading": "4.2 Detecting Real-world LC Errors",
            "text": "PCHECK detects 70+% of both historical and new LC errors (as shown in Table 9), preventing the latent manifestation and resultant system damage imposed by these errors. The results are promising, especially considering that we evaluate PCHECK using all types of configuration errors instead of any specific type. Indeed, PCHECK is by design generic to any types of configuration errors that can be exposed through execution emulation. Many of these LC errors cannot be detected by the state-of-theart detection tools, as discussed below and in \u00a74.3.\nAmong the different types of LC errors, PCHECK detects all the errors violating the types/formats and options/ranges constraints. These two types of errors usually go through straightforward code patterns and do not have dependencies with the system\u2019s runtime states. For example, most type/format errors in HDFS and YARN are manifested when these systems read and parse the erroneous settings through the getter functions. As the auto-generated checkers invoke the getter instructions, it triggers exceptions and detects the errors.\nPCHECK detects the majority of LC errors that violate file-related constraints (including special files such as directories and executables). We observe that the majority of the file parameters fall into recognized APIs, such as open, fopen, and FileInputStream. The undetected file-related LC errors are mainly caused by (1) unknown external usage and (2) indeterminate context. The former prevents the generated checkers from being executed, and the latter stops generation of the checkers. For example, some errors reside in parameters whose values are concatenated into shell command strings, used as the argument of system() (to invoke /bin/sh to execute the command). As PCHECK has no knowledge of any\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 629\nshell commands, it removes the system() call because the side effects are unknown. The other undetected errors are in directories or file prefixes which are merged with dynamic contents from user requests which cannot be obtained statically; thereby, the corresponding checkers cannot be generated. These two causes (unknown external usage and indeterminate context) also account for the undetected errors in the \u201cother\u201d category.\nIn general, PCHECK is effective in checking errors that are manifested through execution anomalies with error identifiers defined in \u00a73.3, such as those failing at system/library calls or throwing exceptions in the controlled branch. Whereas, it is hard for PCHECK to detect errors defined by application-specific semantics, such as email addresses, internal error code, etc.\nWe apply conf spellchecker on the same sets of LC errors. Compared with PCHECK, conf spellchecker detects 7 (33.3%) and 11 (29.7%) less LC errors in the historical and new error benchmarks, respectively. The main reason for PCHECK\u2019s outperformance is that the execution emulation can achieve fine-grained checking towards high fidelity to the original execution. For example, conf spellchecker can only infer the type of a configuration setting to be a \u201cFile\u201d. However, it does not understand how the system accesses the file in the execution. Thus, it reports errors if and only if \u201cthe file is neither readable nor writable\u201d [2]. This heuristic would miss LC errors such as read-only files to be written by the system. Furthermore, type alone only describes a subset of constraints. conf spellchecker misses the LC errors that violate other types of constraints such as data ranges."
        },
        {
            "heading": "4.3 Checking Real-world Configuration Files",
            "text": "We apply the checkers generated by PCHECK to 830 real-world configuration files. PCHECK reports 282 true configuration errors and three false alarms (discussed in \u00a74.6). As shown in Table 10, many (37.5%\u201387.8%) of the reported configuration errors can only be detected by considering the system\u2019s native execution environment. These configuration settings are valid in terms of format and syntax (in fact, they are likely to be correct in the original hosts). However, they are erroneous when used on the current system because the values violate environment constraints such as undefined environment vari-\nables, non-existent file paths, unreachable IP addresses, etc. Since PCHECK emulates the execution that uses the configuration values on the system\u2019s native execution environment, it naturally detects these errors. On the other hand, such configuration errors are not likely to be detected by traditional detection methods [29,31,36,46,57] that treat configuration values as string literals, and thus are agnostic to the execution environment."
        },
        {
            "heading": "4.4 Checker Generation",
            "text": "Table 11 shows the number of configuration parameters that have checkers generated by PCHECK and the total number of generated checkers for the evaluated systems (multiple checkers could be generated for a parameter).\nPCHECK generates checkers for every recognized parameter of HDFS, YARN, and HBase. Each emulated execution in these systems starts from the call instructions of getter functions, so the checkers are able to capture all the errors starting from the parsing phase to the usage phase. For Apache, MySQL and Squid, PCHECK generates fewer checkers. As these systems parse and assign parameter settings to corresponding program variables at the initialization stage, PCHECK bypasses the parsing phase and directly starts from the variables that store the configuration value. Since a large number of the Boolean and numeric variables are only used for branch control with no error identifier (both branches are valid), PCHECK does not generate checkers for them (c.f., \u00a73.3). Moreover, many of the variables are only used at the initialization phase before reaching the invocation location, so their checkers are considered redundant and thus are abandoned (c.f., \u00a73.4).\nThe other issues that prevent checker generation include dependencies on the system\u2019s runtime states and uses of customized APIs (e.g., Apache uses customized APR string operations which heavily rely on predefined memory pools). Fortunately, as shown in \u00a74.2, the majority of the LC errors have standard code patterns and can be detected using PCHECK\u2019s approach. Generating checkers for the rest of the errors require more advanced analysis and program-specific semantics.\nAlso, we can see that the total number of checkers are well bounded, which is attributable to the execution merging (\u00a73.1.4) and redundancy elimination (\u00a73.4).\n630 12th USENIX Symposium on Operating Systems Design and Implementation USENIX Association"
        },
        {
            "heading": "4.5 Checking Overhead",
            "text": "The checkers are only invoked at the initialization phase or run in a separate thread, thus they have little impact on the systems\u2019 runtime performance. We measure their overhead to be the time needed to execute these checkers, by inserting time counters before and after invoking all the checkers. Table 12 shows the time in milliseconds (ms) to run the checkers on a 4-core, 2.50GHz processor connected to a local network (for distributed systems like HDFS, YARN, and HBase, the peer nodes are located in the same local network). The checking overhead for Apache and MySQL is negligible (less than 5ms); Squid needs around 100ms because it has a parameter that points to public IP addresses (announce host). The overhead for the three Java programs is less than a second. The main portion of the time is spent on networkand file-related checking. Since PCHECK only performs lightweight checks (e.g., metadata checks and reachability checks), the overhead is small. Note that the checkers are currently executed sequentially. It is straightforward to invoke multiple checkers in parallel to reduce overhead, as all the checkers are independent."
        },
        {
            "heading": "4.6 False Positives",
            "text": "We measure false positives by applying the checkers generated by PCHECK to both the default configuration values of the evaluated systems and the 830 real-world configuration files, and examine whether or not our checkers would falsely report errors. We also manually inspect the code of the generated checkers in LLVM IR and Jimple to look for potential incorrectness.\nAmong all the configuration parameters in the evaluated systems, only three of them have false alarms reported by the auto-generated checkers: two from YARN and one from HBase. All these false positives are caused by the checkers incorrectly skipping conditional instructions affected by the configuration value (\u00a73.1.2), due to unsound static analysis that misses control dependencies. This results in emulating the execution that should never happen in reality\u2014certainly, the anomalies exposed in such execution are unreal. The overall false positive rates are low. YARN has the most configuration parameters with false checkers, with the false positive rate of 1.7% (2 over 116 parameters). Note that checkers with false\npositives can be removed by the developers or disabled by the administrators in the field (c.f., \u00a73: Usage)."
        },
        {
            "heading": "5 Limitations",
            "text": "No tool is perfect. PCHECK is no exception. Like many other error detection tools, PCHECK is neither sound nor complete for its checking scope and the design trade-offs.\nPCHECK targets on the specific type of configuration errors which are manifested through explicit, recognizable instruction-level anomalies (c.f., \u00a73.3). It cannot detect legal misconfigurations [55] that have valid values but do not deliver the intended system behavior. The common legal misconfigurations include inappropriate configuration settings that violate resource constraints or performance requirements (e.g., insufficient heap size and too small timeout). Such misconfigurations are notoriously hard to detect and are often manifested in a latent fashion as well, such as runtime out-of-memory errors [10] (resources are not used up immediately). However, detecting resource- and performance-related misconfigurations would need dynamic information regarding resource usage and performance profiling, which is beyond the static methods of PCHECK.\nIn addition, PCHECK cannot emulate the execution that depends on runtime inputs/workloads, or does not have statically determinate context in the program code (c.f., \u00a73.1.3). Thus, it would miss the configuration errors that are only manifested during such execution. Nevertheless, indeterminate context (e.g., those derived from inputs and workloads) can potentially be modeled with representative values, which could significantly improve the capability of checker generation.\nOne design choice we make is to trade soundness for safety and efficiency\u2014PCHECK aims to detect common LC errors without incurring side effects or much overhead. For example, PCHECK does not look into file contents but only checks if the file can be accessed as expected. Similarly, PCHECK only checks the reachability of a configured IP address or host instead of connecting and sending packets to the remote host. It is possible that certain sophisticated errors can escape from PCHECK (e.g., the configured file is corrupted and thus has wrong contents). As the first step, we target on basic, common errors, as they already account for a large number of real-world LC errors [24, 43, 55]. Efficiently detecting sophisticated errors may require not only deeper analysis but also application semantics."
        },
        {
            "heading": "6 Concluding Remarks",
            "text": "This paper advocates early detection of configuration errors to minimize failure damage, especially in cloud and data-center systems. Despite all the efforts of validation,\nUSENIX Association 12th USENIX Symposium on Operating Systems Design and Implementation 631\nreview, and testing, configuration errors (even those obvious errors) still cause many high-impact incidents of today\u2019s Internet and cloud systems. We believe that this is partly due to the lack of automatic solutions for cloud and data-center systems to detect and defend against configuration errors (the existing solutions are hard to be applied, due to their strong reliance on datasets).\nWe envisage that PCHECK is the first step towards a generic and systematic solution to detect configuration errors. PCHECK does not require collecting any external datasets and is not specific to any specific rules. It detects configuration errors based on how the system actually uses the configuration values. With PCHECK, we demonstrate that such detection method can effectively detect the majority (75+%) of real-world LC errors, with little runtime overhead and setup effort."
        },
        {
            "heading": "7 Acknowledgement",
            "text": "We greatly appreciate the anonymous reviewers and our shepherd, Peter M. Chen, for their insightful comments and feedback. We thank the Opera group, the UCSD Systems and Networking group, and Shelby Thomas for useful discussions and paper proofreading. Tao Cai participated in the implementation of PCHECK. Liqiong Yang contributed to the study of RAS related configuration parameters. Yuanyuan Zhou\u2019s group is supported in part by NSF grants (CCR-1526966, CCR-1321006), and a gift grant from Facebook, and supports from NetApp. Shan Lu\u2019s research is supported in part by NSF grants (IIS1546543, CNS-1563956, CNS-1514256, CCF-1514189, CCF-1439091), and generous supports from Alfred P. Sloan Foundation and Google Faculty Research Award."
        }
    ],
    "title": "Early Detection of Configuration Errors to Reduce Failure Damage",
    "year": 2016
}