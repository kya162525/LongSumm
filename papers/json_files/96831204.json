{
    "abstractText": "Almost all current dependency parsers classify based on millions of sparse indicator features. Not only do these features generalize poorly, but the cost of feature computation restricts parsing speed significantly. In this work, we propose a novel way of learning a neural network classifier for use in a greedy, transition-based dependency parser. Because this classifier learns and uses just a small number of dense features, it can work very fast, while achieving an about 2% improvement in unlabeled and labeled attachment scores on both English and Chinese datasets. Concretely, our parser is able to parse more than 1000 sentences per second at 92.2% unlabeled attachment score on the English Penn Treebank.",
    "authors": [
        {
            "affiliations": [],
            "name": "Danqi Chen"
        },
        {
            "affiliations": [],
            "name": "Christopher D. Manning"
        }
    ],
    "id": "SP:f02f308b79c214b5925221748077dc9b36d5b806",
    "references": [
        {
            "authors": [
                "Bernd Bohnet."
            ],
            "title": "Very high accuracy and fast dependency parsing is not a contradiction",
            "venue": "Coling.",
            "year": 2010
        },
        {
            "authors": [
                "Ronan Collobert",
                "Jason Weston",
                "L\u00e9on Bottou",
                "Michael Karlen",
                "Koray Kavukcuoglu",
                "Pavel Kuksa."
            ],
            "title": "Natural language processing (almost) from scratch",
            "venue": "Journal of Machine Learning Research.",
            "year": 2011
        },
        {
            "authors": [
                "Ronan Collobert."
            ],
            "title": "Deep learning for efficient discriminative parsing",
            "venue": "AISTATS.",
            "year": 2011
        },
        {
            "authors": [
                "Marie-Catherine de Marneffe",
                "Bill MacCartney",
                "Christopher D. Manning."
            ],
            "title": "Generating typed dependency parses from phrase structure parses",
            "venue": "LREC.",
            "year": 2006
        },
        {
            "authors": [
                "Jacob Devlin",
                "Rabih Zbib",
                "Zhongqiang Huang",
                "Thomas Lamar",
                "Richard Schwartz",
                "John Makhoul."
            ],
            "title": "Fast and robust neural network joint models for statistical machine translation",
            "venue": "ACL.",
            "year": 2014
        },
        {
            "authors": [
                "John Duchi",
                "Elad Hazan",
                "Yoram Singer."
            ],
            "title": "Adaptive subgradient methods for online learning and stochastic optimization",
            "venue": "The Journal of Machine Learning Research.",
            "year": 2011
        },
        {
            "authors": [
                "Rong-En Fan",
                "Kai-Wei Chang",
                "Cho-Jui Hsieh",
                "XiangRui Wang",
                "Chih-Jen Lin."
            ],
            "title": "Liblinear: A library for large linear classification",
            "venue": "The Journal of Machine Learning Research.",
            "year": 2008
        },
        {
            "authors": [
                "Nikhil Garg",
                "James Henderson."
            ],
            "title": "Temporal restricted boltzmann machines for dependency parsing",
            "venue": "ACL-HLT.",
            "year": 2011
        },
        {
            "authors": [
                "He He",
                "Hal Daum\u00e9 III",
                "Jason Eisner."
            ],
            "title": "Dynamic feature selection for dependency parsing",
            "venue": "EMNLP.",
            "year": 2013
        },
        {
            "authors": [
                "James Henderson."
            ],
            "title": "Discriminative training of a neural network statistical parser",
            "venue": "ACL.",
            "year": 2004
        },
        {
            "authors": [
                "Geoffrey E. Hinton",
                "Nitish Srivastava",
                "Alex Krizhevsky",
                "Ilya Sutskever",
                "Ruslan Salakhutdinov."
            ],
            "title": "Improving neural networks by preventing co-adaptation of feature detectors",
            "venue": "CoRR, abs/1207.0580.",
            "year": 2012
        },
        {
            "authors": [
                "Liang Huang",
                "Wenbin Jiang",
                "Qun Liu."
            ],
            "title": "Bilingually-constrained (monolingual) shift-reduce parsing",
            "venue": "EMNLP.",
            "year": 2009
        },
        {
            "authors": [
                "Richard Johansson",
                "Pierre Nugues."
            ],
            "title": "Extended constituent-to-dependency conversion for english",
            "venue": "Proceedings of NODALIDA, Tartu, Estonia.",
            "year": 2007
        },
        {
            "authors": [
                "Lingpeng Kong",
                "Noah A. Smith."
            ],
            "title": "An empirical comparison of parsing methods for Stanford dependencies",
            "venue": "CoRR, abs/1404.4314.",
            "year": 2014
        },
        {
            "authors": [
                "Terry Koo",
                "Xavier Carreras",
                "Michael Collins."
            ],
            "title": "Simple semi-supervised dependency parsing",
            "venue": "ACL.",
            "year": 2008
        },
        {
            "authors": [
                "Sandra K\u00fcbler",
                "Ryan McDonald",
                "Joakim Nivre."
            ],
            "title": "Dependency Parsing",
            "venue": "Synthesis Lectures on Human Language Technologies. Morgan & Claypool.",
            "year": 2009
        },
        {
            "authors": [
                "Marshall R. Mayberry III",
                "Risto Miikkulainen."
            ],
            "title": "Sardsrn: A neural network shift-reduce parser",
            "venue": "IJCAI.",
            "year": 1999
        },
        {
            "authors": [
                "Marshall R. Mayberry III",
                "Risto Miikkulainen."
            ],
            "title": "Broad-coverage parsing with neural networks",
            "venue": "Neural Processing Letters.",
            "year": 2005
        },
        {
            "authors": [
                "Ryan McDonald",
                "Fernando Pereira."
            ],
            "title": "Online learning of approximate dependency parsing algorithms",
            "venue": "EACL.",
            "year": 2006
        },
        {
            "authors": [
                "Tomas Mikolov",
                "Ilya Sutskever",
                "Kai Chen",
                "Greg S Corrado",
                "Jeff Dean."
            ],
            "title": "Distributed representations of words and phrases and their compositionality",
            "venue": "NIPS.",
            "year": 2013
        },
        {
            "authors": [
                "Joakim Nivre",
                "Johan Hall",
                "Jens Nilsson."
            ],
            "title": "Maltparser: A data-driven parser-generator for dependency parsing",
            "venue": "LREC.",
            "year": 2006
        },
        {
            "authors": [
                "Richard Socher",
                "John Bauer",
                "Christopher D Manning",
                "Andrew Y Ng."
            ],
            "title": "Parsing with compositional vector grammars",
            "venue": "ACL.",
            "year": 2013
        },
        {
            "authors": [
                "Richard Socher",
                "Andrej Karpathy",
                "Quoc V. Le",
                "Christopher D. Manning",
                "Andrew Y. Ng."
            ],
            "title": "Grounded compositional semantics for finding and describing images with sentences",
            "venue": "TACL.",
            "year": 2014
        },
        {
            "authors": [
                "Pontus Stenetorp."
            ],
            "title": "Transition-based dependency parsing using recursive neural networks",
            "venue": "NIPS Workshop on Deep Learning.",
            "year": 2013
        },
        {
            "authors": [
                "Ivan Titov",
                "James Henderson."
            ],
            "title": "Fast and robust multilingual dependency parsing with a generative latent variable model",
            "venue": "EMNLP-CoNLL.",
            "year": 2007
        },
        {
            "authors": [
                "Kristina Toutanova",
                "Dan Klein",
                "Christopher D. Manning",
                "Yoram Singer."
            ],
            "title": "Feature-rich part-ofspeech tagging with a cyclic dependency network",
            "venue": "NAACL.",
            "year": 2003
        },
        {
            "authors": [
                "Laurens van der Maaten",
                "Geoffrey Hinton."
            ],
            "title": "Visualizing data using t-SNE",
            "venue": "The Journal of Machine Learning Research.",
            "year": 2008
        },
        {
            "authors": [
                "Yue Zhang",
                "Stephen Clark."
            ],
            "title": "A tale of two parsers: Investigating and combining graphbased and transition-based dependency parsing using beam-search",
            "venue": "EMNLP.",
            "year": 2008
        },
        {
            "authors": [
                "Yue Zhang",
                "Joakim Nivre."
            ],
            "title": "Transition-based dependency parsing with rich non-local features",
            "venue": "ACL.",
            "year": 2011
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "In recent years, enormous parsing success has been achieved by the use of feature-based discriminative dependency parsers (Ku\u0308bler et al., 2009). In particular, for practical applications, the speed of the subclass of transition-based dependency parsers has been very appealing.\nHowever, these parsers are not perfect. First, from a statistical perspective, these parsers suffer from the use of millions of mainly poorly estimated feature weights. While in aggregate both lexicalized features and higher-order interaction term features are very important in improving the performance of these systems, nevertheless, there is insufficient data to correctly weight most such features. For this reason, techniques for introducing higher-support features such as word class features have also been very successful in improving parsing performance (Koo et al., 2008). Second, almost all existing parsers rely on a manually designed set of feature templates, which require a lot\nof expertise and are usually incomplete. Third, the use of many feature templates cause a less studied problem: in modern dependency parsers, most of the runtime is consumed not by the core parsing algorithm but in the feature extraction step (He et al., 2013). For instance, Bohnet (2010) reports that his baseline parser spends 99% of its time doing feature extraction, despite that being done in standard efficient ways.\nIn this work, we address all of these problems by using dense features in place of the sparse indicator features. This is inspired by the recent success of distributed word representations in many NLP tasks, e.g., POS tagging (Collobert et al., 2011), machine translation (Devlin et al., 2014), and constituency parsing (Socher et al., 2013). Low-dimensional, dense word embeddings can effectively alleviate sparsity by sharing statistical strength between similar words, and can provide us a good starting point to construct features of words and their interactions.\nNevertheless, there remain challenging problems of how to encode all the available information from the configuration and how to model higher-order features based on the dense representations. In this paper, we train a neural network classifier to make parsing decisions within a transition-based dependency parser. The neural network learns compact dense vector representations of words, part-of-speech (POS) tags, and dependency labels. This results in a fast, compact classifier, which uses only 200 learned dense features while yielding good gains in parsing accuracy and speed on two languages (English and Chinese) and two different dependency representations (CoNLL and Stanford dependencies). The main contributions of this work are: (i) showing the usefulness of dense representations that are learned within the parsing task, (ii) developing a neural network architecture that gives good accuracy and speed, and (iii) introducing a novel acti-\nvation function for the neural network that better captures higher-order interaction features."
        },
        {
            "heading": "2 Transition-based Dependency Parsing",
            "text": "Transition-based dependency parsing aims to predict a transition sequence from an initial configuration to some terminal configuration, which derives a target dependency parse tree, as shown in Figure 1. In this paper, we examine only greedy parsing, which uses a classifier to predict the correct transition based on features extracted from the configuration. This class of parsers is of great interest because of their efficiency, although they tend to perform slightly worse than the searchbased parsers because of subsequent error propagation. However, our greedy parser can achieve comparable accuracy with a very good speed.1\nAs the basis of our parser, we employ the arc-standard system (Nivre, 2004), one of the most popular transition systems. In the arcstandard system, a configuration c = (s, b, A) consists of a stack s, a buffer b, and a set of dependency arcs A. The initial configuration for a sentence w1, . . . , wn is s = [ROOT], b = [w1, . . . , wn], A = \u2205. A configuration c is terminal if the buffer is empty and the stack contains the single node ROOT, and the parse tree is given by Ac. Denoting si (i = 1, 2, . . .) as the ith top element on the stack, and bi (i = 1, 2, . . .) as the ith element on the buffer, the arc-standard system defines three types of transitions:\n\u2022 LEFT-ARC(l): adds an arc s1 \u2192 s2 with label l and removes s2 from the stack. Precondition: |s| \u2265 2.\n\u2022 RIGHT-ARC(l): adds an arc s2 \u2192 s1 with label l and removes s1 from the stack. Precondition: |s| \u2265 2.\n\u2022 SHIFT: moves b1 from the buffer to the stack. Precondition: |b| \u2265 1.\nIn the labeled version of parsing, there are in total |T | = 2Nl + 1 transitions, where Nl is number of different arc labels. Figure 1 illustrates an example of one transition sequence from the initial configuration to a terminal one.\nThe essential goal of a greedy parser is to predict a correct transition from T , based on one\n1Additionally, our parser can be naturally incorporated with beam search, but we leave this to future work.\ngiven configuration. Information that can be obtained from one configuration includes: (1) all the words and their corresponding POS tags (e.g., has / VBZ); (2) the head of a word and its label (e.g., nsubj, dobj) if applicable; (3) the position of a word on the stack/buffer or whether it has already been removed from the stack.\nConventional approaches extract indicator features such as the conjunction of 1 \u223c 3 elements from the stack/buffer using their words, POS tags or arc labels. Table 1 lists a typical set of feature templates chosen from the ones of (Huang et al., 2009; Zhang and Nivre, 2011).2 These features suffer from the following problems:\n\u2022 Sparsity. The features, especially lexicalized features are highly sparse, and this is a common problem in many NLP tasks. The situation is severe in dependency parsing, because it depends critically on word-to-word interactions and thus the high-order features. To give a better understanding, we perform a feature analysis using the features in Table 1 on the English Penn Treebank (CoNLL representations). The results given in Table 2 demonstrate that: (1) lexicalized features are indispensable; (2) Not only are the word-pair features (especially s1 and s2) vital for predictions, the three-word conjunctions (e.g., {s2, s1, b1}, {s2, lc1(s1), s1}) are also very important.\n2We exclude sophisticated features using labels, distance, valency and third-order features in this analysis, but we will include all of them in the final evaluation.\n1\n1\n\u2022 Incompleteness. Incompleteness is an unavoidable issue in all existing feature templates. Because even with expertise and manual handling involved, they still do not include the conjunction of every useful word combination. For example, the conjunction of s1 and b2 is omitted in almost all commonly used feature templates, however it could indicate that we cannot perform a RIGHT-ARC action if there is an arc from s1 to b2. \u2022 Expensive feature computation. The fea-\nture generation of indicator features is generally expensive \u2014 we have to concatenate some words, POS tags, or arc labels for generating feature strings, and look them up in a huge table containing several millions of features. In our experiments, more than 95% of the time is consumed by feature computation during the parsing process.\nSo far, we have discussed preliminaries of\ntransition-based dependency parsing and existing problems of sparse indicator features. In the following sections, we will elaborate our neural network model for learning dense features along with experimental evaluations that prove its efficiency."
        },
        {
            "heading": "3 Neural Network Based Parser",
            "text": "In this section, we first present our neural network model and its main components. Later, we give details of training and speedup of parsing process."
        },
        {
            "heading": "3.1 Model",
            "text": "Figure 2 describes our neural network architecture. First, as usual word embeddings, we represent each word as a d-dimensional vector ewi \u2208 Rd and the full embedding matrix is Ew \u2208 Rd\u00d7Nw where Nw is the dictionary size. Meanwhile, we also map POS tags and arc labels to a ddimensional vector space, where eti, e l j \u2208 Rd are the representations of ith POS tag and jth arc label. Correspondingly, the POS and label embedding matrices are Et \u2208 Rd\u00d7Nt and El \u2208 Rd\u00d7Nl where Nt and Nl are the number of distinct POS tags and arc labels.\nWe choose a set of elements based on the stack / buffer positions for each type of information (word, POS or label), which might be useful for our predictions. We denote the sets as Sw, St, Sl respectively. For example, given the configuration in Figure 2 and St =\n{lc1(s2).t, s2.t, rc1(s2).t, s1.t}, we will extract PRP, VBZ, NULL, JJ in order. Here we use a special token NULL to represent a non-existent element.\nWe build a standard neural network with one hidden layer, where the corresponding embeddings of our chosen elements from Sw, St, Sl will be added to the input layer. Denoting nw, nt, nl as the number of chosen elements of each type, we add xw = [eww1 ; e w w2 ; . . . e w wnw\n] to the input layer, where Sw = {w1, . . . , wnw}. Similarly, we add the POS tag features xt and arc label features xl to the input layer.\nWe map the input layer to a hidden layer with dh nodes through a cube activation function:\nh = (Ww1 x w +W t1x t +W l1x l + b1) 3\nwhere Ww1 \u2208 Rdh\u00d7(d\u00b7nw), W t1 \u2208 Rdh\u00d7(d\u00b7nt), W l1 \u2208 Rdh\u00d7(d\u00b7nl), and b1 \u2208 Rdh is the bias.\nA softmax layer is finally added on the top of the hidden layer for modeling multi-class probabilities p = softmax(W2h), where W2 \u2208 R|T |\u00d7dh .\nPOS and label embeddings To our best knowledge, this is the first attempt to introduce POS tag and arc label embeddings instead of discrete representations.\nAlthough the POS tags P = {NN,NNP, NNS,DT,JJ, . . .} (for English) and arc labels L = {amod,tmod,nsubj,csubj,dobj, . . .} (for Stanford Dependencies on English) are relatively small discrete sets, they still exhibit many semantical similarities like words. For example, NN (singular noun) should be closer to NNS (plural\nnoun) than DT (determiner), and amod (adjective modifier) should be closer to num (numeric modifier) than nsubj (nominal subject). We expect these semantic meanings to be effectively captured by the dense representations.\nCube activation function As stated above, we introduce a novel activation function: cube g(x) = x3 in our model instead of the commonly used tanh or sigmoid functions (Figure 3).\nIntuitively, every hidden unit is computed by a (non-linear) mapping on a weighted sum of input units plus a bias. Using g(x) = x3 can model the product terms of xixjxk for any three different elements at the input layer directly:\ng(w1x1 + . . .+ wmxm + b) =\u2211 i,j,k (wiwjwk)xixjxk + \u2211 i,j b(wiwj)xixj . . .\nIn our case, xi, xj , xk could come from different dimensions of three embeddings. We believe that this better captures the interaction of three ele-\nments, which is a very desired property of dependency parsing.\nExperimental results also verify the success of the cube activation function empirically (see more comparisons in Section 4). However, the expressive power of this activation function is still open to investigate theoretically.\nThe choice of Sw, St, Sl\nFollowing (Zhang and Nivre, 2011), we pick a rich set of elements for our final parser. In detail, Sw contains nw = 18 elements: (1) The top 3 words on the stack and buffer: s1, s2, s3, b1, b2, b3; (2) The first and second leftmost / rightmost children of the top two words on the stack: lc1(si), rc1(si), lc2(si), rc2(si), i = 1, 2. (3) The leftmost of leftmost / rightmost of rightmost children of the top two words on the stack: lc1(lc1(si)), rc1(rc1(si)), i = 1, 2.\nWe use the corresponding POS tags for St (nt = 18), and the corresponding arc labels of words excluding those 6 words on the stack/buffer for Sl (nl = 12). A good advantage of our parser is that we can add a rich set of elements cheaply, instead of hand-crafting many more indicator features."
        },
        {
            "heading": "3.2 Training",
            "text": "We first generate training examples {(ci, ti)}mi=1 from the training sentences and their gold parse trees using a \u201cshortest stack\u201d oracle which always prefers LEFT-ARCl over SHIFT, where ci is a configuration, ti \u2208 T is the oracle transition.\nThe final training objective is to minimize the cross-entropy loss, plus a l2-regularization term:\nL(\u03b8) = \u2212 \u2211 i log pti + \u03bb 2 \u2016\u03b8\u20162\nwhere \u03b8 is the set of all parameters {Ww1 ,W t1,W l1, b1,W2, Ew, Et, El}. A slight variation is that we compute the softmax probabilities only among the feasible transitions in practice.\nFor initialization of parameters, we use pretrained word embeddings to initialize Ew and use random initialization within (\u22120.01, 0.01) for Et and El. Concretely, we use the pre-trained word embeddings from (Collobert et al., 2011) for English (#dictionary = 130,000, coverage = 72.7%), and our trained 50-dimensional word2vec embeddings (Mikolov et al., 2013) on Wikipedia and Gigaword corpus for Chinese (#dictionary =\n285,791, coverage = 79.0%). We will also compare with random initialization of Ew in Section 4. The training error derivatives will be backpropagated to these embeddings during the training process.\nWe use mini-batched AdaGrad (Duchi et al., 2011) for optimization and also apply a dropout (Hinton et al., 2012) with 0.5 rate. The parameters which achieve the best unlabeled attachment score on the development set will be chosen for final evaluation."
        },
        {
            "heading": "3.3 Parsing",
            "text": "We perform greedy decoding in parsing. At each step, we extract all the corresponding word, POS and label embeddings from the current configuration c, compute the hidden layer h(c) \u2208 Rdh , and pick the transition with the highest score: t = argmaxt is feasible W2(t, \u00b7)h(c), and then execute c\u2192 t(c).\nComparing with indicator features, our parser does not need to compute conjunction features and look them up in a huge feature table, and thus greatly reduces feature generation time. Instead, it involves many matrix addition and multiplication operations. To further speed up the parsing time, we apply a pre-computation trick, similar to (Devlin et al., 2014). For each position chosen from Sw, we pre-compute matrix multiplications for most top frequent 10, 000 words. Thus, computing the hidden layer only requires looking up the table for these frequent words, and adding the dh-dimensional vector. Similarly, we also precompute matrix computations for all positions and all POS tags and arc labels. We only use this optimization in the neural network parser, but it is only feasible for a parser like the neural network parser which uses a small number of features. In practice, this pre-computation step increases the speed of our parser 8 \u223c 10 times."
        },
        {
            "heading": "4 Experiments",
            "text": ""
        },
        {
            "heading": "4.1 Datasets",
            "text": "We conduct our experiments on the English Penn Treebank (PTB) and the Chinese Penn Treebank (CTB) datasets.\nFor English, we follow the standard splits of PTB3, using sections 2-21 for training, section 22 as development set and 23 as test set. We adopt two different dependency representations: CoNLL Syntactic Dependencies (CD) (Johansson\nand Nugues, 2007) using the LTH Constituent-toDependency Conversion Tool3 and Stanford Basic Dependencies (SD) (de Marneffe et al., 2006) using the Stanford parser v3.3.0.4 The POS tags are assigned using Stanford POS tagger (Toutanova et al., 2003) with ten-way jackknifing of the training data (accuracy \u2248 97.3%).\nFor Chinese, we adopt the same split of CTB5 as described in (Zhang and Clark, 2008). Dependencies are converted using the Penn2Malt tool5 with the head-finding rules of (Zhang and Clark, 2008). And following (Zhang and Clark, 2008; Zhang and Nivre, 2011), we use gold segmentation and POS tags for the input.\nTable 3 gives statistics of the three datasets.6 In particular, over 99% of the trees are projective in all datasets."
        },
        {
            "heading": "4.2 Results",
            "text": "The following hyper-parameters are used in all experiments: embedding size d = 50, hidden layer size h = 200, regularization parameter \u03bb = 10\u22128, initial learning rate of Adagrad \u03b1 = 0.01.\nTo situate the performance of our parser, we first make a comparison with our own implementation of greedy arc-eager and arc-standard parsers. These parsers are trained with structured averaged perceptron using the \u201cearly-update\u201d strategy. The feature templates of (Zhang and Nivre, 2011) are used for the arc-eager system, and they are also adapted to the arc-standard system.7\nFurthermore, we also compare our parser with two popular, off-the-shelf parsers: MaltParser \u2014 a greedy transition-based dependency parser (Nivre et al., 2006),8 and MSTParser \u2014\n3http://nlp.cs.lth.se/software/treebank converter/ 4http://nlp.stanford.edu/software/lex-parser.shtml 5http://stp.lingfil.uu.se/ nivre/research/Penn2Malt.html 6Pennconverter and Stanford dependencies generate slightly different tokenization, e.g., Pennconverter splits the token WCRS\\/Boston NNP into three tokens WCRS NNP / CC Boston NNP.\n7Since arc-standard is bottom-up, we remove all features using the head of stack elements, and also add the right child features of the first stack element.\n8http://www.maltparser.org/\na first-order graph-based parser (McDonald and Pereira, 2006).9 In this comparison, for MaltParser, we select stackproj (arc-standard) and nivreeager (arc-eager) as parsing algorithms, and liblinear (Fan et al., 2008) for optimization.10 For MSTParser, we use default options. On all datasets, we report unlabeled attachment scores (UAS) and labeled attachment scores (LAS) and punctuation is excluded in all evaluation metrics.11 Our parser and the baseline arcstandard and arc-eager parsers are all implemented in Java. The parsing speeds are measured on an Intel Core i7 2.7GHz CPU with 16GB RAM and the runtime does not include pre-computation or parameter loading time.\nTable 4, Table 5 and Table 6 show the comparison of accuracy and parsing speed on PTB (CoNLL dependencies), PTB (Stanford dependencies) and CTB respectively.\nClearly, our parser is superior in terms of both accuracy and speed. Comparing with the baselines of arc-eager and arc-standard parsers, our parser achieves around 2% improvement in UAS and LAS on all datasets, while running about 20 times faster.\nIt is worth noting that the efficiency of our 9http://www.seas.upenn.edu/ strctlrn/MSTParser/ MSTParser.html 10We do not compare with libsvm optimization, which is known to be sightly more accurate, but orders of magnitude slower (Kong and Smith, 2014).\n11A token is a punctuation if its gold POS tag is {\u201c \u201d : , .} for English and PU for Chinese.\nparser even surpasses MaltParser using liblinear, which is known to be highly optimized, while our parser achieves much better accuracy.\nAlso, despite the fact that the graph-based MSTParser achieves a similar result to ours on PTB (CoNLL dependencies), our parser is nearly 100 times faster. In particular, our transition-based parser has a great advantage in LAS, especially for the fine-grained label set of Stanford dependencies."
        },
        {
            "heading": "4.3 Effects of Parser Components",
            "text": "Herein, we examine components that account for the performance of our parser.\nCube activation function\nWe compare our cube activation function (x3) with two widely used non-linear functions: tanh ( e\nx\u2212e\u2212x ex+e\u2212x ), sigmoid ( 1 1+e\u2212x ), and also the identity function (x), as shown in Figure 4 (left).\nIn short, cube outperforms all other activation functions significantly and identity works the worst. Concretely, cube can achieve 0.8% \u223c 1.2% improvement in UAS over tanh and other functions, thus verifying the effectiveness of the cube activation function empirically.\nInitialization of pre-trained word embeddings We further analyze the influence of using pretrained word embeddings for initialization. Figure 4 (middle) shows that using pre-trained word embeddings can obtain around 0.7% improvement on PTB and 1.7% improvement on CTB, compared with using random initialization within (\u22120.01, 0.01). On the one hand, the pre-trained word embeddings of Chinese appear more useful than those of English; on the other hand, our model is still able to achieve comparable accuracy without the help of pre-trained word embeddings.\nPOS tag and arc label embeddings As shown in Figure 4 (right), POS embeddings yield around 1.7% improvement on PTB and nearly 10% improvement on CTB and the label embeddings yield a much smaller 0.3% and 1.4% improvement respectively.\nHowever, we can obtain little gain from label embeddings when the POS embeddings are present. This may be because the POS tags of two tokens already capture most of the label information between them."
        },
        {
            "heading": "4.4 Model Analysis",
            "text": "Last but not least, we will examine the parameters we have learned, and hope to investigate what these dense features capture. We use the weights learned from the English Penn Treebank using Stanford dependencies for analysis.\nWhat do Et, El capture? We first introduced Et and El as the dense representations of all POS tags and arc labels, and we wonder whether these embeddings could carry some semantic information.\nFigure 5 presents t-SNE visualizations (van der Maaten and Hinton, 2008) of these embeddings. It clearly shows that these embeddings effectively exhibit the similarities between POS tags or arc labels. For instance, the three adjective POS tags JJ, JJR, JJS have very close embeddings, and also the three labels representing clausal complements acomp, ccomp, xcomp are grouped together.\nSince these embeddings can effectively encode the semantic regularities, we believe that they can be also used as alternative features of POS tags (or arc labels) in other NLP tasks, and help boost the performance.\nWhat do Ww1 , W t1 , W l1 capture? Knowing that Et and El (as well as the word embeddings Ew) can capture semantic information very well, next we hope to investigate what each feature in the hidden layer has really learned.\nSince we currently only have h = 200 learned dense features, we wonder if it is sufficient to learn the word conjunctions as sparse indicator features, or even more. We examine the weights Ww1 (k, \u00b7) \u2208 Rd\u00b7nw , W t1(k, \u00b7) \u2208 Rd\u00b7nt , W l1(k, \u00b7) \u2208 Rd\u00b7nl for each hidden unit k, and reshape them to d \u00d7 nt, d \u00d7 nw, d \u00d7 nl matrices, such that the weights of each column corresponds to the embeddings of one specific element (e.g., s1.t).\nWe pick the weights with absolute value > 0.2, and visualize them for each feature. Figure 6 gives the visualization of three sampled features, and it exhibits many interesting phenomena:\n\u2022 Different features have varied distributions of the weights. However, most of the discriminative weights come from W t1 (the middle zone in Figure 6), and this further justifies the importance of POS tags in dependency parsing.\n\u2022 We carefully examine many of the h = 200 features, and find that they actually encode very different views of information. For the three sampled features in Figure 6, the largest weights are dominated by:\n\u2013 Feature 1: s1.t, s2.t, lc(s1).t. \u2013 Feautre 2: rc(s1).t, s1.t, b1.t. \u2013 Feature 3: s1.t, s1.w, lc(s1).t, lc(s1).l.\nThese features all seem very plausible, as observed in the experiments on indicator feature systems. Thus our model is able to automatically identify the most useful information for predictions, instead of hand-crafting them as indicator features.\n\u2022 More importantly, we can extract features regarding the conjunctions of more than 3 elements easily, and also those not presented in the indicator feature systems. For example, the 3rd feature above captures the conjunction of words and POS tags of s1, the tag of its leftmost child, and also the label between them, while this information is not encoded in the original feature templates of (Zhang and Nivre, 2011)."
        },
        {
            "heading": "5 Related Work",
            "text": "There have been several lines of earlier work in using neural networks for parsing which have points of overlap but also major differences from our work here. One big difference is that much early work uses localist one-hot word representations rather than the distributed representations of modern work. (Mayberry III and Miikkulainen, 1999) explored a shift reduce constituency parser with one-hot word representations and did subsequent parsing work in (Mayberry III and Miikkulainen, 2005).\n(Henderson, 2004) was the first to attempt to use neural networks in a broad-coverage Penn Treebank parser, using a simple synchrony network to predict parse decisions in a constituency parser. More recently, (Titov and Henderson, 2007) applied Incremental Sigmoid Belief Networks to constituency parsing and then (Garg and Henderson, 2011) extended this work to transition-based dependency parsers using a Temporal Restricted Boltzman Machine. These are very different neural network architectures, and are much less scalable and in practice a restricted vocabulary was used to make the architecture practical.\nThere have been a number of recent uses of deep learning for constituency parsing (Collobert, 2011; Socher et al., 2013). (Socher et al., 2014) has also built models over dependency representations but this work has not attempted to learn neural networks for dependency parsing.\nMost recently, (Stenetorp, 2013) attempted to build recursive neural networks for transitionbased dependency parsing, however the empirical performance of his model is still unsatisfactory."
        },
        {
            "heading": "6 Conclusion",
            "text": "We have presented a novel dependency parser using neural networks. Experimental evaluations show that our parser outperforms other greedy parsers using sparse indicator features in both accuracy and speed. This is achieved by representing all words, POS tags and arc labels as dense vectors, and modeling their interactions through a novel cube activation function. Our model only relies on dense features, and is able to automatically learn the most useful feature conjunctions for making predictions.\nAn interesting line of future work is to combine our neural network based classifier with searchbased models to further improve accuracy. Also,\nthere is still room for improvement in our architecture, such as better capturing word conjunctions, or adding richer features (e.g., distance, valency)."
        },
        {
            "heading": "Acknowledgments",
            "text": "Stanford University gratefully acknowledges the support of the Defense Advanced Research Projects Agency (DARPA) Deep Exploration and Filtering of Text (DEFT) Program under Air Force Research Laboratory (AFRL) contract no. FA8750-13-2-0040 and the Defense Threat Reduction Agency (DTRA) under Air Force Research Laboratory (AFRL) contract no. FA865010-C-7020. Any opinions, findings, and conclusion or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of the DARPA, AFRL, or the US government."
        }
    ],
    "title": "A Fast and Accurate Dependency Parser using Neural Networks",
    "year": 2014
}