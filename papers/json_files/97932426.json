{
    "abstractText": "Deep learning yields great results across many fields, from speech recognition, image classification, to translation. But for each problem, getting a deep model to work well involves research into the architecture and a long period of tuning. We present a single model that yields good results on a number of problems spanning multiple domains. In particular, this single model is trained concurrently on ImageNet, multiple translation tasks, image captioning (COCO dataset), a speech recognition corpus, and an English parsing task. Our model architecture incorporates building blocks from multiple domains. It contains convolutional layers, an attention mechanism, and sparsely-gated layers. Each of these computational blocks is crucial for a subset of the tasks we train on. Interestingly, even if a block is not crucial for a task, we observe that adding it never hurts performance and in most cases improves it on all tasks. We also show that tasks with less data benefit largely from joint training with other tasks, while performance on large tasks degrades only slightly if at all.",
    "authors": [
        {
            "affiliations": [],
            "name": "Aidan N. Gomez"
        },
        {
            "affiliations": [],
            "name": "Noam Shazeer"
        },
        {
            "affiliations": [],
            "name": "Niki Parmar"
        }
    ],
    "id": "SP:5061f591aa8ff224cd20cdcb3b62d156fb187bed",
    "references": [
        {
            "authors": [
                "Noam Shazeer"
            ],
            "title": "Attention is all you need",
            "venue": "arXiv preprint arXiv:1706.03762,",
            "year": 2017
        },
        {
            "authors": [
                "Dzmitry Bahdanau",
                "Kyunghyun Cho",
                "Yoshua Bengio"
            ],
            "title": "Neural machine translation by jointly learning to align and translate",
            "venue": "CoRR, abs/1409.0473,",
            "year": 2014
        },
        {
            "authors": [
                "Kyunghyun Cho",
                "Bart van Merrienboer",
                "Caglar Gulcehre",
                "Fethi Bougares",
                "Holger Schwenk",
                "Yoshua Bengio"
            ],
            "title": "Learning phrase representations using rnn encoder-decoder for statistical machine translation",
            "venue": "CoRR, abs/1406.1078,",
            "year": 2014
        },
        {
            "authors": [
                "Francois Chollet"
            ],
            "title": "Xception: Deep learning with depthwise separable convolutions",
            "venue": "arXiv preprint arXiv:1610.02357,",
            "year": 2016
        },
        {
            "authors": [
                "Ronan Collobert",
                "Jason Weston"
            ],
            "title": "A unified architecture for natural language processing: deep neural networks with multitask learning",
            "venue": "In Proceedings of the 25th International Conference on Machine learning,",
            "year": 2008
        },
        {
            "authors": [
                "George E. Dahl",
                "Dong Yu",
                "Li Deng",
                "Alex Acero"
            ],
            "title": "Context-dependent pre-trained deep neural networks for large-vocabulary speech recognition",
            "venue": "IEEE Transactions on Audio, Speech & Language Processing,",
            "year": 2012
        },
        {
            "authors": [
                "Sepp Hochreiter",
                "J\u00fcrgen Schmidhuber"
            ],
            "title": "Long short-term memory",
            "venue": "Neural computation,",
            "year": 1997
        },
        {
            "authors": [
                "Nal Kalchbrenner",
                "Phil Blunsom"
            ],
            "title": "Recurrent continuous translation models",
            "venue": "In Proceedings EMNLP",
            "year": 2013
        },
        {
            "authors": [
                "Nal Kalchbrenner",
                "Lasse Espeholt",
                "Karen Simonyan",
                "Aaron van den Oord",
                "Alex Graves",
                "Koray Kavukcuoglu"
            ],
            "title": "Neural machine translation in linear time",
            "venue": "arXiv preprint arXiv:1610.10099,",
            "year": 2016
        },
        {
            "authors": [
                "Diederik P. Kingma",
                "Jimmy Ba"
            ],
            "title": "Adam: A method for stochastic optimization",
            "venue": "CoRR, abs/1412.6980,",
            "year": 2014
        },
        {
            "authors": [
                "Alex Krizhevsky",
                "Ilya Sutskever",
                "Geoffrey Hinton"
            ],
            "title": "Imagenet classification with deep convolutional neural network",
            "venue": "In Advances in Neural Information Processing Systems,",
            "year": 2012
        },
        {
            "authors": [
                "Francois Chollet \u0141ukasz Kaiser",
                "Aidan N. Gomez"
            ],
            "title": "Depthwise separable convolutions for neural machine translation",
            "venue": "arXiv preprint arXiv:1706.03059,",
            "year": 2017
        },
        {
            "authors": [
                "Samy Bengio \u0141ukasz Kaiser"
            ],
            "title": "Can active memory replace attention",
            "venue": "In Advances in Neural Information Processing Systems,",
            "year": 2016
        },
        {
            "authors": [
                "Mike Schuster"
            ],
            "title": "Google\u2019s multilingual neural machine translation system: Enabling zero-shot translation",
            "venue": "arXiv preprint arXiv:1611.04558,",
            "year": 2016
        },
        {
            "authors": [
                "Fandong Meng",
                "Zhengdong Lu",
                "Mingxuan Wang",
                "Hang Li",
                "Wenbin Jiang",
                "Qun Liu"
            ],
            "title": "Encoding source language with convolutional neural network for machine translation",
            "venue": "In ACL,",
            "year": 2015
        },
        {
            "authors": [
                "Jiquan Ngiam",
                "Aditya Khosla",
                "Mingyu Kim",
                "Juhan Nam",
                "Honglak Lee",
                "Andrew Y. Ng"
            ],
            "title": "Multimodal deep learning",
            "venue": "In Proceedings of ICML\u201911,",
            "year": 2011
        },
        {
            "authors": [
                "Azalia Mirhoseini"
            ],
            "title": "Outrageously large neural networks: The sparsely-gated mixture-of-experts",
            "venue": "layer. arXiv",
            "year": 2017
        },
        {
            "authors": [
                "Bernardino Romera-Paredes",
                "Andreas Argyriou",
                "Nadia Berthouze",
                "Massimiliano Pontil"
            ],
            "title": "Exploiting unrelated tasks in multi-task learning",
            "venue": "In JMLR Proceedings of AISTATS\u201912,",
            "year": 2012
        },
        {
            "authors": [
                "Michael L. Seltzer",
                "Jasha Droppo"
            ],
            "title": "Multi-task learning in deep neural networks for improved phoneme recognition",
            "venue": "In Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP\u201913),",
            "year": 2013
        },
        {
            "authors": [
                "Rico Sennrich",
                "Barry Haddow",
                "Alexandra Birch"
            ],
            "title": "Neural machine translation of rare words with subword units",
            "year": 2015
        },
        {
            "authors": [
                "Laurent Sifre",
                "St\u00e9phane Mallat"
            ],
            "title": "Rotation, scaling and deformation invariant scattering for texture discrimination",
            "venue": "IEEE Conference on Computer Vision and Pattern Recognition,",
            "year": 2013
        },
        {
            "authors": [
                "Ilya Sutskever",
                "Oriol Vinyals",
                "Quoc VV Le"
            ],
            "title": "Sequence to sequence learning with neural networks",
            "venue": "In Advances in Neural Information Processing Systems, pages 3104\u20133112,",
            "year": 2014
        },
        {
            "authors": [
                "Christian Szegedy",
                "Sergey Ioffe",
                "Vincent Vanhoucke"
            ],
            "title": "Inception-v4, inception-resnet and the impact of residual connections on learning",
            "year": 2016
        },
        {
            "authors": [
                "A\u00e4ron van den Oord",
                "Sander Dieleman",
                "Heiga Zen",
                "Karen Simonyan",
                "Oriol Vinyals",
                "Alex Graves",
                "Nal Kalchbrenner",
                "Andrew Senior",
                "Koray Kavukcuoglu"
            ],
            "title": "Wavenet: A generative model for raw audio",
            "venue": "CoRR abs/1609.03499,",
            "year": 2016
        },
        {
            "authors": [
                "Fisher Yu",
                "Vladlen Koltun"
            ],
            "title": "Multi-scale context aggregation by dilated convolutions",
            "venue": "arXiv preprint arXiv:1511.07122,",
            "year": 2015
        },
        {
            "authors": [
                "Z. Loy C.C. Tang X. Zhang",
                "P. Luo"
            ],
            "title": "Facial landmark detection by deep multi-task learning",
            "venue": "In Proceedings of ECCV\u201914,",
            "year": 2014
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "Recent successes of deep neural networks have spanned many domains, from computer vision [13] to speech recognition [8] and many other tasks. Convolutional networks excel at tasks related to vision, while recurrent neural networks have proven successful at natural language processing tasks, e.g., at machine translation [27, 3, 4]. But in each case, the network was designed and tuned specifically for the problem at hand. This limits the impact of deep learning, as this effort needs to be repeated for each new task. It is also very different from the general nature of the human brain, which is able to learn many different tasks and benefit from transfer learning. The natural question arises:\nCan we create a unified deep learning model to solve tasks across multiple domains?\nThe question about multi-task models has been studied in many papers in the deep learning literature. Natural language processing models have been shown to benefit from a multi-task approach a long time ago [6], and recently machine translation models have even been shown to exhibit zero-shot learning when trained on multiple langauges [18]. Speech recognition has also been shown to benefit from multi-task training [24], as have some vision problems, such as facial landmark detection [31]. But all these models are trained on other tasks from the same domain: translation tasks are trained with other translation tasks, vision tasks with other vision tasks, speech tasks with other speech tasks. Multi-modal learning has been shown to improve learned representations in the unsupervised\n\u2217Work performed while at Google Brain. Code available at https://github.com/tensorflow/tensor2tensor\nar X\niv :1\n70 6.\n05 13\n7v 1\n[ cs\n.L G\n] 1\n6 Ju\nsetting [20] and when used as a-priori known unrelated tasks [22]. But no competitive multi-task multi-modal model has been proposed, so the above question remains unanswered.\nIn this work, we take a step toward positively answering the above question by introducing the MultiModel architecture, a single deep-learning model that can simultaneously learn multiple tasks from various domains. Concretely, we train the MultiModel simultaneously on the following 8 corpora:\n(1) WSJ speech corpus [7] (2) ImageNet dataset [23] (3) COCO image captioning dataset [14] (4) WSJ parsing dataset [17] (5) WMT English-German translation corpus (6) The reverse of the above: German-English translation. (7) WMT English-French translation corpus (8) The reverse of the above: German-French translation.\nThe model learns all of the above tasks and achieves good performance: not state-of-the-art at present, but above many task-specific models studied in recent past (see the Section 3 for details). Figure 1 illustrates some decodes taken directly from the model: it is clear that it can caption images, categorize them, translate to French and German and construct parse trees. While the MultiModel is only a first step and will be tuned and improved in the future, two key insights are crucial to making it work at all and are the main contributions of this work.\nSmall modality-specific sub-networks convert into a unified representation and back from it. To allow training on input data of widely different sizes and dimensions, such as images, sound waves and text, we need sub-networks to convert inputs into a joint representation space. We call these sub-networks modality nets as they are specific to each modality (images, speech, text) and define transformations between these external domains and a unified representation. We design modality nets to be computationally minimal, promoting heavy feature extraction and ensuring that the majority of computation is performed within the domain-agnostic body of the model. Since our model is auto-regressive, modality nets need to both convert the inputs into the unified representation and later convert from this representation into the output space. Two design decisions were important:\n\u2022 The unified representation is variable-size. While a fixed-size representation is tempting and easier to implement, it creates a bottleneck and limits the performance of the model.\n\u2022 Different tasks from the same domain share modality nets. We avoid creating a sub-network for every task, and prefer only to create one for every input modality. For example, all translation tasks share the same modality-net (and vocabulary), no matter for which language pair. This encourages generalization across tasks and allows to add new tasks on the fly.\nComputational blocks of different kinds are crucial for good results on various problems. The body of the MultiModel incorporates building blocks from mutiple domains. We use depthwiseseparable convolutions, an attention mechanism, and sparsely-gated mixture-of-experts layers. These blocks were introduced in papers that belonged to different domains and were not studied before on tasks from other domains. For example, separable convolutions were introduced in the Xception architecture [5] and were not applied to text or speech processing before. On the other hand, the sparsely-gated mixture-of-experts [21] had been introduced for language processing tasks and has not been studied on image problems. We find that each of these mechanisms is indeed crucial for the domain it was introduced, e.g., attention is far more important for language-related tasks than for image-related ones. But, interestingly, adding these computational blocks never hurts performance, even on tasks they were not designed for. In fact we find that both attention and mixture-of-experts layers slightly improve performance of MultiModel on ImageNet, the task that needs them the least."
        },
        {
            "heading": "2 MultiModel Architecture",
            "text": "The MultiModel consists of a few small modality-nets, an encoder, I/O mixer, and an autoregressive decoder, as depicted in Figure 2. As already said above, the encoder and decoder are constructed using 3 key computational blocks to get good performance across different problems:\n(1) Convolutions allow the model to detect local patterns and generalize across space.\n(2) Attention layers allow to focus on specific elements to improve performance of the model.\n(3) Sparsely-gated mixture-of-experts gives the model capacity without excessive computation cost.\nWe start by describing the architecture of each of these 3 blocks and then introduce the encoder, decoder and the architecture of our modality-nets."
        },
        {
            "heading": "2.1 Convolutional Blocks",
            "text": "To perform local computation, we use blocks of convolutions with ReLU non-linearities and normalization. A block of convolutions gets as input a tensor of shape [batch size, sequence length, feature channels] and returns a tensor of the same shape, processed as follows.\nFor convolution operations, we use depthwise separable convolutions, introduced in [5], in a way similar to [15]. Depthwise separable convolutions are a parameter- and computationally-efficient variant of the traditional convolution. They are defined by a convolution on each feature channel separately, followed by a pointwise convolution to project to the desired feature depth. We refer the reader to [5] for a complete definition; here we will denote a depthwise separable convolution with weights Wh\u00d7w corresponding to f kernels of size h\u00d7 w applied to an input tensor x with stride s and dilated by a factor d (see [30]) as SepConvd,s,f (W,x). Note that subscripts for stride, dilation and output size are omitted when dilation d or stride s are equal to 1, or output size f is equal to the input\u2019s feature depth.\nWe use convolutions in blocks that consist of three components: a ReLU activation of the inputs, followed by a SepConv, followed by layer normalization. Layer normalization [2] acts over the h hidden units of the layer below, computing layer-wise statistics for each batch example and normalizing accordingly. These normalized units are then scaled and shifted by scalar learned parameters G and B respectively, producing the final units to be activated by a non-linearity. The complete convolution step is therefore defined as:\nConvStepd,s,f (W,x) = LN(SepConvd,s,f (W,ReLU(x))).\nThe convolutional steps are composed into blocks by stacking them and adding residual connections as depicted in Figure 3. We use stacks of four convolutional blocks with two skip-connections between the stack input and the outputs of the second and fourth convolutional steps, and with the first two having 3\u00d7 1 kernels and the next two having 15\u00d7 1 kernels, with the final one dilated by 8 to provide a wide receptive field. We also add 40% dropout at the end of each block, so the complete block is defined as follows:\nhidden1(x) = ConvStep(W 3\u00d71h1 , x) hidden2(x) = x + ConvStep(W 3\u00d71h2 , hidden1(x)) hidden3(x) = ConvStep(W 15\u00d71h3 , hidden2(x)) hidden4(x) = x + ConvStepd=8(W 15\u00d71 h4 , hidden3(x))\nConvBlock(x) = { Dropout(hidden4(x), 0.4) during training hidden4(x) otherwise"
        },
        {
            "heading": "2.2 Attention Blocks",
            "text": "For attention, we use a multi-head dot-product attention mechanism inspired by [3] and similar to [1], as depicted in Figure 3. The inputs to the attention layer are two tensors: a source tensor and a target tensor both with the shape [batch size, sequence length, feature channels] The target tensor is additively composed with a timing signal and mixed using two convolutional blocks. This mixed tensor is then self-attended using a multi-head dot-product attention, which is a dot-product attention with inputs split into g = 8 separate tensors representing each attention head, as shown in Figure 3. The timing signals are the main difference between this attention mechanism and the ones used previously. They allow this content-based attention to focus based on their position. They are constructed by concatenating sine and cosine curves:\n\u2206(2d) = 1e4\u2212 2d depth\ntiming(t, [2d, 2d + 1]) = [sin(t\u2206(2d)) \u20162 cos(t\u2206(2d))]\nwhere [a||db] represent concatenation of a and b along the dth dimension. The source tensor is finally passed through two different pointwise convolutions to generate the memory keys K and values V and the query keys, memory keys and memory values are used to apply the attention mechanism between the self-attended target and the source (see Figure 3)."
        },
        {
            "heading": "2.3 Mixture-of-Experts Blocks",
            "text": "We use sparsely-gated mixture-of-experts layers of the same kind as introduced in [21]: A mixture-ofexperts layer consists of a number of simple feed-forward neural networks (experts) and a trainable gating network which selects a sparse combination of the experts to process each input. We refer the reader to [21] for details as we use exactly the architecture described there. In particular, during training we select k = 4 experts out of the whole expert pool and add the additional load-balancing cost as in [21]. In each of the two mixture-of-experts layers in our model, we use a pool of 240 experts when training on 8 problems jointly, and 60 experts when training on each problem separately."
        },
        {
            "heading": "2.4 Encoder and Mixer and Decoder",
            "text": "The body of the MultiModel consists of 3 parts: the encoder that only processes the inputs, the mixer that mixes the encoded inputs with previous outputs (autoregressive part), and a decoder that processes the inputs and the mixture to generate new outputs.\nThe encoder, mixer and decoder are structured similarly to previous fully convolutional sequence to sequence models such as ByteNet [11] or WaveNet [29], but differ in the computational blocks that are used. We depict their architecture in Figure 3. As can be seen there, the encoder consists of 6 repeated convolutional blocks (described before) with a mixture-of-experts layer in the middle. The mixer consists of an attention block and 2 convolutional blocks. The decoder consists of 4 blocks of convolutions and attention, with a mixture-of-experts layer in the middle. Crucially, the convolutions in the mixer and decoder are padded on the left, so they can never access any information in the future. This allows the model to be autoregressive, and this convolutional autoregressive generation scheme offers large receptive fields over the inputs and past outputs, which are capable of establishing long term dependencies.\nTo allow the decoder to produce outputs for different tasks even with the same modality, we always start decoding with a command-token, such as To-English or To-Parse-Tree. We learn an embedding vector corresponding to each of the tokens during training."
        },
        {
            "heading": "2.5 Modality Nets",
            "text": "We have 4 modality nets, for language (text data), images, audio, and categorical data."
        },
        {
            "heading": "2.5.1 Language modality net",
            "text": "Our language-based data is all tokenized using the same vocabulary with 8k subword-units, following the method from [25]. The language input modality takes a sequence of tokens ending in a termination token. This sequence of tokens is mapped to the correct dimensionality for the body using a learned embedding. On the output side, the language modality takes the decoded output of the body and performs a learned linear mapping, followed by a Softmax, resulting in a probability distribution over the token vocabulary.\nLanguageModalityin(x,WE) = WE \u00b7 x LanguageModalityout(x,WS) = Softmax(WS \u00b7 x)"
        },
        {
            "heading": "2.5.2 Image modality net",
            "text": "The image input modality is analogous to the Xception entry flow [5]. The input image\u2019s feature depth is gradually deepened using residual convolution blocks which we call ConvRes and define as follows:\nc1(x, F ) = ConvStepf=F (W 3\u00d73, x)\nc2(x, F ) = ConvStepf=F (W 3\u00d73, c1(x, F ))\np1(x, F ) = MaxPool2([3\u00d7 3], c2(x, F )) ConvRes(x, F ) = p1(x, F ) + ConvSteps=2(W 1\u00d71, x),\nwhere MaxPools([h\u00d7w], x) is a max-pooling layer over x with stride s and window shape [h\u00d7w]. The ImageModality input flow with network depth d (we use d = 1024) is defined as:\nh1(x) = ConvSteps=2,f=32(W 3\u00d73, x)\nh2(x) = ConvStepf=64(W 3\u00d73, h1(x))\nr1(x) = ConvRes(h2(x), 128)\nr2(x) = ConvRes(r1(x), 256)\nImageModalityin(x) = ConvRes(r2(x), d)"
        },
        {
            "heading": "2.5.3 Categorical modality net",
            "text": "The categorical output modality is analogous to the Xception exit flow [5]. If the network inputs are two-dimensional data such as image or spectral audio data, then the one-dimensional output from the model body is first reshaped into two-dimensions again, followed by progressive down-sampling:\nskip(x) = ConvSteps=2(W 3\u00d73 skip , x)\nh1(x) = ConvStep(W 3\u00d73h1 , x) h2(x) = ConvStep(W 3\u00d73h2 , h1(x)) h3(x) = skip(x) + MaxPool2([3\u00d7 3], h2(x)) h4(x) = ConvStepf=1536(W 3\u00d73 h4 , h3(x)) h5(x) = ConvStepf=2048(W 3\u00d73, h4(x))\nh6(x) = GlobalAvgPool(ReLU(h5(x)))\nCategoricalModalityout(x) = PointwiseConv(W classes, h6(x))\nGlobalAvgPool denotes a mean taken across all spatial and temporal dimensions."
        },
        {
            "heading": "2.5.4 Audio modality net",
            "text": "We accept audio input in the form of a 1-dimensional waveform over time or as a 2-dimensional spectrogram. Both the waveform and spectral input modalities use a stack of 8 ConvRes blocks from the ImageInputModality (Section 2.5.2). The ith block has the form: li = ConvRes(li\u22121, 2i). The spectral modality does not perform any striding along the frequency bin dimension, preserving full resolution in the spectral domain."
        },
        {
            "heading": "2.6 Related Models",
            "text": "The MultiModel architecture draws from eariler encoder-decoder architectures applied to neural machine translation. Earlier sequence-to-sequence models for translation [27, 3, 4] used recurrent neural networks (RNNs) with long short-term memory cells [9]). Convolutional architectures yielded good results on word-level neural machine translation starting from [10] and later in [19]. These early models used a standard RNN on top of the convolution to generate the output and had a bottleneck there that hurt performance, especially on longer sentences, similarly to the limitations of RNN sequence-to-sequence models without attention [27, 4]. Fully convolutional neural machine translation without this bottleneck was presented in [16, 11]. The model in [16] (Extended Neural GPU) used a recurrent stack of gated convolutional layers, while the model in [11] (ByteNet) did away with recursion and used left-padded convolutions in the decoder. This idea, introduced in WaveNet [29] and also used in MultiModel (see above) significantly improves efficiency. Depthwise separable convolutions were first studied by Sifre [26] and later they were used to get good results on large-scale image classification with Xception [5]."
        },
        {
            "heading": "3 Experiments",
            "text": "We implemented the MultiModel architecture described above using TensorFlow and trained it in a number of configurations. In all training runs reported below we used the same set of hyperparameters and the Adam optimizer [12] with gradient clipping. We will release the implementation\nas open-source together with the details of our setup and all used hyper-parameters. We focused our experiments so as to answer the following questions:\n(1) How far is the MultiModel trained on 8 tasks simultaneously from state-of-the-art results?\n(2) How does training on 8 tasks simultaneously compare to training on each task separately?\n(3) How do the different computational blocks discussed above influence different tasks?\nIn answering the above questions, we don\u2019t always consider all 8 problems. Especially the 4 translation problems behave very similarly, so we decided to not include them all in each comparison but we focused on the more varied problems instead.\nTo answer question (1), we compare the performance of the 8-problem MultiModel with state-of-theart results in Table 1. We did not invest much time yet in tuning hyper-parameters of the MultiModel, so we believe that the difference seen there will become much smaller with more tuning. The results we achieve are similar to the ones task-specific models get without heavy tuning, e.g., on English-French translation we improve on the Extended Neural GPU results reported last year [16].\nTo answer question (2), we compare the MultiModel trained jointly with MultiModel trained separately just on a single task. When training jointly on 8 tasks, we had a separate worker training on each task with shared parameters of the model. When training on a single task, we used only a single worker training on this task for a similar number of steps. Since we are comparing different instantiations of the same model, we report two internal metrics: the negative log-perplexity and per-token accuracy (measured on the development set). As can be seen from the results in Table 2, the joint 8-problem model performs similarly to single-model on large tasks, and better, sometimes significantly, on tasks where less data is available, such as parsing.\nThe large improvement on parsing seen in Table 2 is not that surprising taking into account the large number of text data in translation tasks. But we were curious if training parsing just with ImageNet, a seemingly unrelated task, would also bring any improvements. This is indeed the case, as can be seen in Table 3. The difference in performance is significant, and since we use both dropout and early stopping, we conjecture that it is not related to over-fitting. Rather, it seems, there are computational primitives shared between different tasks that allow for some transfer learning even between such seemingly unrelated tasks as ImageNet and parsing.\nTo answer question (3), we check how training without the mixture-of-experts layers or without the attention mechanism influences performance on different problems. Since both these mechanisms were designed with machine translation in mind, we check the English-French translation. But we also include ImageNet, since this is the problem that stands the least to benefit from those blocks. In fact, one could expect that removing these blocks will improve performance on ImageNet alone if they were truly useless for this task. In contrast, we see in Table 4 that these blocks either don\u2019t affect\nor slightly improve performance. This leads us to conclude that mixing different computation blocks is in fact a good way to improve performance on many various tasks."
        },
        {
            "heading": "4 Conclusions",
            "text": "We demonstrate, for the first time, that a single deep learning model can jointly learn a number of large-scale tasks from multiple domains. The key to success comes from designing a multi-modal architecture in which as many parameters as possible are shared and from using computational blocks from different domains together. We believe that this treads a path towards interesting future work on more general deep learning architectures, especially since our model shows transfer learning from tasks with a large amount of available data to ones where the data is limited."
        }
    ],
    "year": 2017
}